{"ast":null,"code":"import{authStorage}from'./auth';// API configuration\nconst getApiConfig=()=>{// Определяем окружение\nconst isDevelopment=process.env.NODE_ENV==='development';const isLocalBackend=process.env.REACT_APP_USE_LOCAL_BACKEND==='true';const forcedApiUrl=process.env.REACT_APP_FORCE_API_URL;const serverEnv=process.env.REACT_APP_ENV==='server';// URL для разных окружений\nconst LOCAL_BACKEND_URL=process.env.REACT_APP_LOCAL_BACKEND_URL||'http://localhost:3001';const REMOTE_BACKEND_URL=process.env.REACT_APP_REMOTE_BACKEND_URL||'https://chrono-back-kramushka.amvera.io';const SERVER_DEFAULT_BACKEND_URL=process.env.REACT_APP_SERVER_BACKEND_URL||'http://amvera-kramushka-run-chrono-back';// Выбираем URL в зависимости от настроек\nlet apiUrl;if(forcedApiUrl){apiUrl=forcedApiUrl;console.log('🚩 Принудительно задан backend:',apiUrl);}else if(serverEnv){apiUrl=process.env.REACT_APP_API_URL||SERVER_DEFAULT_BACKEND_URL;console.log('🏷️ Режим сервера: backend =',apiUrl);}else if(isDevelopment&&isLocalBackend){apiUrl=LOCAL_BACKEND_URL;console.log('🔧 Используется локальный backend:',apiUrl);}else{apiUrl=process.env.REACT_APP_API_URL||REMOTE_BACKEND_URL;console.log('🌐 Используется удаленный backend:',apiUrl);}return{baseUrl:apiUrl,timeout:10000,// 10 секунд\nretries:2};};const API_CONFIG=getApiConfig();const API_BASE_URL=API_CONFIG.baseUrl;// Safe decode function\nconst safeDecode=str=>{try{return decodeURIComponent(escape(str));}catch(error){console.warn('Failed to decode string:',str,error);return str;}};// Helper function for API requests with retry logic\nconst apiRequest=async function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let lastError=null;for(let attempt=0;attempt<=API_CONFIG.retries;attempt++){try{const controller=new AbortController();const timeoutId=setTimeout(()=>controller.abort(),API_CONFIG.timeout);const response=await fetch(url,{...options,signal:controller.signal});clearTimeout(timeoutId);return response;}catch(error){lastError=error;console.warn(`API request attempt ${attempt+1} failed:`,error);if(attempt<API_CONFIG.retries){// Ждем перед повторной попыткой (экспоненциальная задержка)\nawait new Promise(resolve=>setTimeout(resolve,Math.pow(2,attempt)*1000));}}}throw lastError||new Error('API request failed after all retries');};// Types for API responses\n// Helper function to build query string from filters\nconst buildQueryString=filters=>{const params=new URLSearchParams();if(filters.category){params.append('category',filters.category);}if(filters.country){params.append('country',filters.country);}if(filters.startYear!==undefined){params.append('startYear',filters.startYear.toString());}if(filters.endYear!==undefined){params.append('endYear',filters.endYear.toString());}return params.toString();};// Get persons with optional filters\nexport const getPersons=async function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};try{const queryString=buildQueryString(filters);const url=`${API_BASE_URL}/api/persons${queryString?`?${queryString}`:''}`;const response=await apiRequest(url);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}const data=await response.json();// Преобразуем данные в правильный формат с безопасной декодировкой\nlet transformedData=data.map(person=>({id:person.id,name:safeDecode(person.name||''),birthYear:person.birthYear,deathYear:person.deathYear,category:safeDecode(person.category||''),country:safeDecode(person.country||''),description:safeDecode(person.description||''),imageUrl:person.imageUrl,reignStart:person.reignStart,reignEnd:person.reignEnd,achievementYear1:person.achievementYear1,achievementYear2:person.achievementYear2,achievementYear3:person.achievementYear3,achievements:Array.isArray(person.achievements)?person.achievements.map(a=>safeDecode(a||'')):[]}));// Дополнительная фильтрация на клиенте для множественных стран\nif(filters.country){const selectedCountries=filters.country.split(',').map(c=>c.trim());transformedData=transformedData.filter(person=>{const personCountries=person.country.includes('/')?person.country.split('/').map(c=>c.trim()):[person.country];return selectedCountries.some(selected=>personCountries.includes(selected));});}return transformedData;}catch(error){console.error('Error fetching persons:',error);// Return empty array as fallback\nreturn[];}};// Get all categories\nexport const getCategories=async()=>{try{const url=`${API_BASE_URL}/api/categories`;const response=await apiRequest(url);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}const data=await response.json();// Безопасная декодировка категорий\nreturn data.map(category=>safeDecode(category||''));}catch(error){console.error('Error fetching categories:',error);// Return default categories as fallback\nreturn['Политик','Ученый','Художник','Писатель','Военачальник'];}};// Get all countries\nexport const getCountries=async()=>{try{const url=`${API_BASE_URL}/api/countries`;const response=await apiRequest(url);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}const data=await response.json();// Безопасная декодировка стран и разбивка множественных стран\nconst allCountries=new Set();data.forEach(country=>{const decodedCountry=safeDecode(country||'');if(decodedCountry.includes('/')){// Разбиваем множественные страны на отдельные\nconst countries=decodedCountry.split('/').map(c=>c.trim());countries.forEach(c=>{if(c)allCountries.add(c);});}else{allCountries.add(decodedCountry);}});// Сортируем страны по алфавиту\nreturn Array.from(allCountries).sort();}catch(error){console.error('Error fetching countries:',error);// Return default countries as fallback\nreturn['Древний Рим','Древняя Греция','Древний Египет','Китай','Индия'];}};// Test connection to backend\nexport const testBackendConnection=async()=>{try{const response=await apiRequest(`${API_BASE_URL}/api/health`);return response.ok;}catch(error){console.error('Backend connection test failed:',error);return false;}};// Get backend info\nexport const getBackendInfo=()=>{return{baseUrl:API_BASE_URL,isLocal:API_BASE_URL.includes('localhost'),config:API_CONFIG};};// --- Auth-aware fetch with 401 handling and token refresh ---\nlet isRefreshing=false;let pendingRequests=[];async function refreshTokenIfNeeded(){if(isRefreshing){await new Promise(resolve=>pendingRequests.push(resolve));return;}isRefreshing=true;try{var _data$data,_data$data2,_data$data3;const state=authStorage.load();if(!state.refreshToken)throw new Error('No refresh token');const res=await apiRequest(`${API_BASE_URL}/api/auth/refresh`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({refresh_token:state.refreshToken})});if(!res.ok)throw new Error('Refresh failed');const data=await res.json();const newState={user:(data===null||data===void 0?void 0:(_data$data=data.data)===null||_data$data===void 0?void 0:_data$data.user)||state.user,accessToken:(data===null||data===void 0?void 0:(_data$data2=data.data)===null||_data$data2===void 0?void 0:_data$data2.access_token)||null,refreshToken:(data===null||data===void 0?void 0:(_data$data3=data.data)===null||_data$data3===void 0?void 0:_data$data3.refresh_token)||state.refreshToken};authStorage.save(newState);}finally{isRefreshing=false;pendingRequests.forEach(resolve=>resolve());pendingRequests=[];}}export async function apiFetch(path){let init=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const url=`${API_BASE_URL}${path}`;const state=authStorage.load();const headers=new Headers(init.headers||{});if(state.accessToken&&!headers.has('Authorization')){headers.set('Authorization',`Bearer ${state.accessToken}`);}try{const res=await apiRequest(url,{...init,headers});if(res.status!==401)return res;// Try refresh and retry once\nawait refreshTokenIfNeeded();const refreshed=authStorage.load();const retryHeaders=new Headers(init.headers||{});if(refreshed.accessToken)retryHeaders.set('Authorization',`Bearer ${refreshed.accessToken}`);return apiRequest(url,{...init,headers:retryHeaders});}catch(e){throw e;}}","map":{"version":3,"names":["authStorage","getApiConfig","isDevelopment","process","env","NODE_ENV","isLocalBackend","REACT_APP_USE_LOCAL_BACKEND","forcedApiUrl","REACT_APP_FORCE_API_URL","serverEnv","REACT_APP_ENV","LOCAL_BACKEND_URL","REACT_APP_LOCAL_BACKEND_URL","REMOTE_BACKEND_URL","REACT_APP_REMOTE_BACKEND_URL","SERVER_DEFAULT_BACKEND_URL","REACT_APP_SERVER_BACKEND_URL","apiUrl","console","log","REACT_APP_API_URL","baseUrl","timeout","retries","API_CONFIG","API_BASE_URL","safeDecode","str","decodeURIComponent","escape","error","warn","apiRequest","url","options","arguments","length","undefined","lastError","attempt","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","clearTimeout","Promise","resolve","Math","pow","Error","buildQueryString","filters","params","URLSearchParams","category","append","country","startYear","toString","endYear","getPersons","queryString","ok","status","data","json","transformedData","map","person","id","name","birthYear","deathYear","description","imageUrl","reignStart","reignEnd","achievementYear1","achievementYear2","achievementYear3","achievements","Array","isArray","a","selectedCountries","split","c","trim","filter","personCountries","includes","some","selected","getCategories","getCountries","allCountries","Set","forEach","decodedCountry","countries","add","from","sort","testBackendConnection","getBackendInfo","isLocal","config","isRefreshing","pendingRequests","refreshTokenIfNeeded","push","_data$data","_data$data2","_data$data3","state","load","refreshToken","res","method","headers","body","JSON","stringify","refresh_token","newState","user","accessToken","access_token","save","apiFetch","path","init","Headers","has","set","refreshed","retryHeaders","e"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/services/api.ts"],"sourcesContent":["import { authStorage } from './auth';\n// API configuration\nconst getApiConfig = () => {\n  // Определяем окружение\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  const isLocalBackend = process.env.REACT_APP_USE_LOCAL_BACKEND === 'true';\n  const forcedApiUrl = process.env.REACT_APP_FORCE_API_URL;\n  const serverEnv = process.env.REACT_APP_ENV === 'server';\n  \n  // URL для разных окружений\n  const LOCAL_BACKEND_URL = process.env.REACT_APP_LOCAL_BACKEND_URL || 'http://localhost:3001';\n  const REMOTE_BACKEND_URL = process.env.REACT_APP_REMOTE_BACKEND_URL || 'https://chrono-back-kramushka.amvera.io';\n  const SERVER_DEFAULT_BACKEND_URL = process.env.REACT_APP_SERVER_BACKEND_URL || 'http://amvera-kramushka-run-chrono-back';\n  \n  // Выбираем URL в зависимости от настроек\n  let apiUrl: string;\n  if (forcedApiUrl) {\n    apiUrl = forcedApiUrl;\n    console.log('🚩 Принудительно задан backend:', apiUrl);\n  } else if (serverEnv) {\n    apiUrl = process.env.REACT_APP_API_URL || SERVER_DEFAULT_BACKEND_URL;\n    console.log('🏷️ Режим сервера: backend =', apiUrl);\n  } else if (isDevelopment && isLocalBackend) {\n    apiUrl = LOCAL_BACKEND_URL;\n    console.log('🔧 Используется локальный backend:', apiUrl);\n  } else {\n    apiUrl = process.env.REACT_APP_API_URL || REMOTE_BACKEND_URL;\n    console.log('🌐 Используется удаленный backend:', apiUrl);\n  }\n  \n  return {\n    baseUrl: apiUrl,\n    timeout: 10000, // 10 секунд\n    retries: 2\n  };\n};\n\nconst API_CONFIG = getApiConfig();\nconst API_BASE_URL = API_CONFIG.baseUrl;\n\n// Safe decode function\nconst safeDecode = (str: string): string => {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (error) {\n    console.warn('Failed to decode string:', str, error);\n    return str;\n  }\n};\n\n// Helper function for API requests with retry logic\nconst apiRequest = async (url: string, options: RequestInit = {}): Promise<Response> => {\n  let lastError: Error | null = null;\n  \n  for (let attempt = 0; attempt <= API_CONFIG.retries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);\n      \n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      lastError = error as Error;\n      console.warn(`API request attempt ${attempt + 1} failed:`, error);\n      \n      if (attempt < API_CONFIG.retries) {\n        // Ждем перед повторной попыткой (экспоненциальная задержка)\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n      }\n    }\n  }\n  \n  throw lastError || new Error('API request failed after all retries');\n};\n\n// Types for API responses\ninterface Person {\n  id: string;\n  name: string;\n  birthYear: number;\n  deathYear: number;\n  category: string;\n  country: string;\n  description: string;\n  imageUrl?: string;\n  reignStart?: number;\n  reignEnd?: number;\n  achievementYear1?: number;\n  achievementYear2?: number;\n  achievementYear3?: number;\n  achievements: string[];\n}\n\ninterface ApiFilters {\n  category?: string;\n  country?: string;\n  startYear?: number;\n  endYear?: number;\n}\n\n// Helper function to build query string from filters\nconst buildQueryString = (filters: ApiFilters): string => {\n  const params = new URLSearchParams();\n  \n  if (filters.category) {\n    params.append('category', filters.category);\n  }\n  if (filters.country) {\n    params.append('country', filters.country);\n  }\n  if (filters.startYear !== undefined) {\n    params.append('startYear', filters.startYear.toString());\n  }\n  if (filters.endYear !== undefined) {\n    params.append('endYear', filters.endYear.toString());\n  }\n  \n  return params.toString();\n};\n\n// Get persons with optional filters\nexport const getPersons = async (filters: ApiFilters = {}): Promise<Person[]> => {\n  try {\n    const queryString = buildQueryString(filters);\n    const url = `${API_BASE_URL}/api/persons${queryString ? `?${queryString}` : ''}`;\n    \n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Преобразуем данные в правильный формат с безопасной декодировкой\n    let transformedData = data.map((person: {\n      id: string;\n      name?: string;\n      birthYear: number;\n      deathYear: number;\n      category?: string;\n      country?: string;\n      description?: string;\n      imageUrl?: string;\n      reignStart?: number;\n      reignEnd?: number;\n      achievementYear1?: number;\n      achievementYear2?: number;\n      achievementYear3?: number;\n      achievements?: string[];\n    }) => ({\n      id: person.id,\n      name: safeDecode(person.name || ''),\n      birthYear: person.birthYear,\n      deathYear: person.deathYear,\n      category: safeDecode(person.category || ''),\n      country: safeDecode(person.country || ''),\n      description: safeDecode(person.description || ''),\n      imageUrl: person.imageUrl,\n      reignStart: person.reignStart,\n      reignEnd: person.reignEnd,\n      achievementYear1: person.achievementYear1,\n      achievementYear2: person.achievementYear2,\n      achievementYear3: person.achievementYear3,\n      achievements: Array.isArray(person.achievements) ? person.achievements.map((a: string) => safeDecode(a || '')) : []\n    }));\n    \n    // Дополнительная фильтрация на клиенте для множественных стран\n    if (filters.country) {\n      const selectedCountries = filters.country.split(',').map((c: string) => c.trim());\n      transformedData = transformedData.filter((person: Person) => {\n        const personCountries = person.country.includes('/') \n          ? person.country.split('/').map((c: string) => c.trim())\n          : [person.country];\n        return selectedCountries.some((selected: string) => personCountries.includes(selected));\n      });\n    }\n    \n    return transformedData;\n  } catch (error) {\n    console.error('Error fetching persons:', error);\n    // Return empty array as fallback\n    return [];\n  }\n};\n\n// Get all categories\nexport const getCategories = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/categories`;\n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка категорий\n    return data.map((category: string) => safeDecode(category || ''));\n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    // Return default categories as fallback\n    return ['Политик', 'Ученый', 'Художник', 'Писатель', 'Военачальник'];\n  }\n};\n\n// Get all countries\nexport const getCountries = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/countries`;\n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка стран и разбивка множественных стран\n    const allCountries = new Set<string>();\n    \n    data.forEach((country: string | null) => {\n      const decodedCountry = safeDecode(country || '');\n      if (decodedCountry.includes('/')) {\n        // Разбиваем множественные страны на отдельные\n        const countries = decodedCountry.split('/').map(c => c.trim());\n        countries.forEach(c => {\n          if (c) allCountries.add(c);\n        });\n      } else {\n        allCountries.add(decodedCountry);\n      }\n    });\n    \n    // Сортируем страны по алфавиту\n    return Array.from(allCountries).sort();\n  } catch (error) {\n    console.error('Error fetching countries:', error);\n    // Return default countries as fallback\n    return ['Древний Рим', 'Древняя Греция', 'Древний Египет', 'Китай', 'Индия'];\n  }\n};\n\n// Test connection to backend\nexport const testBackendConnection = async (): Promise<boolean> => {\n  try {\n    const response = await apiRequest(`${API_BASE_URL}/api/health`);\n    return response.ok;\n  } catch (error) {\n    console.error('Backend connection test failed:', error);\n    return false;\n  }\n};\n\n// Get backend info\nexport const getBackendInfo = () => {\n  return {\n    baseUrl: API_BASE_URL,\n    isLocal: API_BASE_URL.includes('localhost'),\n    config: API_CONFIG\n  };\n}; \n\n// --- Auth-aware fetch with 401 handling and token refresh ---\n\nlet isRefreshing = false;\nlet pendingRequests: Array<() => void> = [];\n\nasync function refreshTokenIfNeeded(): Promise<void> {\n  if (isRefreshing) {\n    await new Promise<void>((resolve) => pendingRequests.push(resolve));\n    return;\n  }\n  isRefreshing = true;\n  try {\n    const state = authStorage.load();\n    if (!state.refreshToken) throw new Error('No refresh token');\n    const res = await apiRequest(`${API_BASE_URL}/api/auth/refresh`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ refresh_token: state.refreshToken })\n    });\n    if (!res.ok) throw new Error('Refresh failed');\n    const data = await res.json();\n    const newState = {\n      user: data?.data?.user || state.user,\n      accessToken: data?.data?.access_token || null,\n      refreshToken: data?.data?.refresh_token || state.refreshToken\n    };\n    authStorage.save(newState);\n  } finally {\n    isRefreshing = false;\n    pendingRequests.forEach((resolve) => resolve());\n    pendingRequests = [];\n  }\n}\n\nexport async function apiFetch(path: string, init: RequestInit = {}) {\n  const url = `${API_BASE_URL}${path}`;\n  const state = authStorage.load();\n  const headers = new Headers(init.headers || {});\n  if (state.accessToken && !headers.has('Authorization')) {\n    headers.set('Authorization', `Bearer ${state.accessToken}`);\n  }\n  try {\n    const res = await apiRequest(url, { ...init, headers });\n    if (res.status !== 401) return res;\n    // Try refresh and retry once\n    await refreshTokenIfNeeded();\n    const refreshed = authStorage.load();\n    const retryHeaders = new Headers(init.headers || {});\n    if (refreshed.accessToken) retryHeaders.set('Authorization', `Bearer ${refreshed.accessToken}`);\n    return apiRequest(url, { ...init, headers: retryHeaders });\n  } catch (e) {\n    throw e;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}