{"ast":null,"code":"// Функция для конвертации в римские цифры\nexport const toRomanNumeral=num=>{const romanNumerals=[{value:1000,numeral:'M'},{value:900,numeral:'CM'},{value:500,numeral:'D'},{value:400,numeral:'CD'},{value:100,numeral:'C'},{value:90,numeral:'XC'},{value:50,numeral:'L'},{value:40,numeral:'XL'},{value:10,numeral:'X'},{value:9,numeral:'IX'},{value:5,numeral:'V'},{value:4,numeral:'IV'},{value:1,numeral:'I'}];let result='';let remaining=Math.abs(num);for(const{value,numeral}of romanNumerals){while(remaining>=value){result+=numeral;remaining-=value;}}return num<0?`-${result}`:result;};// Функция для получения номера века\nexport const getCenturyNumber=year=>{if(year<0){// Для отрицательных лет: -1 до -100 = 1 век до н.э., -101 до -200 = 2 век до н.э.\nreturn Math.floor((Math.abs(year)-1)/100)+1;}else if(year===0){// Год 0 не существует в исторической хронологии\nreturn 1;}else{// Для положительных лет: 1-100 = 1 век, 101-200 = 2 век и т.д.\nreturn Math.floor((year-1)/100)+1;}};// Функция для получения цвета века\nexport const getCenturyColor=(year,minYear)=>{const colors=['rgba(255, 107, 107, 0.1)',// Светло-красный\n'rgba(78, 205, 196, 0.1)',// Светло-голубой\n'rgba(150, 206, 180, 0.1)',// Светло-зеленый\n'rgba(255, 234, 167, 0.1)',// Светло-оранжевый\n'rgba(221, 160, 221, 0.1)',// Светло-фиолетовый\n'rgba(120, 219, 255, 0.1)',// Светло-бирюзовый\n'rgba(255, 255, 229, 0.1)',// Светло-желтый\n'rgba(255, 229, 240, 0.1)'// Светло-розовый\n];const centuryIndex=Math.floor((year-minYear)/100);return colors[centuryIndex%colors.length];};// Функция для генерации границ веков\nexport const generateCenturyBoundaries=(minYear,maxYear)=>{const boundaries=[];const startCentury=Math.floor(minYear/100)*100;const endCentury=Math.ceil(maxYear/100)*100;for(let year=startCentury;year<=endCentury;year+=100){// Включаем границу, если она попадает в диапазон данных или является границей века\nif(year<=maxYear){boundaries.push(year);}}return boundaries;};// Функция для вычисления позиции в пикселях\nexport const getPosition=(year,minYear,pixelsPerYear,leftPadding)=>{return leftPadding+(year-minYear)*pixelsPerYear;};// Функция для вычисления ширины полоски в пикселях\nexport const getWidth=(birthYear,deathYear,pixelsPerYear)=>{return(deathYear-birthYear)*pixelsPerYear;};// Вспомогательная функция для извлечения первой страны из списка\nexport const getFirstCountry=countryString=>{const countries=countryString.split('/').map(c=>c.trim());return countries[0]||countryString;};","map":{"version":3,"names":["toRomanNumeral","num","romanNumerals","value","numeral","result","remaining","Math","abs","getCenturyNumber","year","floor","getCenturyColor","minYear","colors","centuryIndex","length","generateCenturyBoundaries","maxYear","boundaries","startCentury","endCentury","ceil","push","getPosition","pixelsPerYear","leftPadding","getWidth","birthYear","deathYear","getFirstCountry","countryString","countries","split","map","c","trim"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/utils/timelineUtils.ts"],"sourcesContent":["// Функция для конвертации в римские цифры\r\nexport const toRomanNumeral = (num: number): string => {\r\n  const romanNumerals = [\r\n    { value: 1000, numeral: 'M' },\r\n    { value: 900, numeral: 'CM' },\r\n    { value: 500, numeral: 'D' },\r\n    { value: 400, numeral: 'CD' },\r\n    { value: 100, numeral: 'C' },\r\n    { value: 90, numeral: 'XC' },\r\n    { value: 50, numeral: 'L' },\r\n    { value: 40, numeral: 'XL' },\r\n    { value: 10, numeral: 'X' },\r\n    { value: 9, numeral: 'IX' },\r\n    { value: 5, numeral: 'V' },\r\n    { value: 4, numeral: 'IV' },\r\n    { value: 1, numeral: 'I' }\r\n  ]\r\n\r\n  let result = ''\r\n  let remaining = Math.abs(num)\r\n\r\n  for (const { value, numeral } of romanNumerals) {\r\n    while (remaining >= value) {\r\n      result += numeral\r\n      remaining -= value\r\n    }\r\n  }\r\n\r\n  return num < 0 ? `-${result}` : result\r\n}\r\n\r\n// Функция для получения номера века\r\nexport const getCenturyNumber = (year: number): number => {\r\n  if (year < 0) {\r\n    // Для отрицательных лет: -1 до -100 = 1 век до н.э., -101 до -200 = 2 век до н.э.\r\n    return Math.floor((Math.abs(year) - 1) / 100) + 1\r\n  } else if (year === 0) {\r\n    // Год 0 не существует в исторической хронологии\r\n    return 1\r\n  } else {\r\n    // Для положительных лет: 1-100 = 1 век, 101-200 = 2 век и т.д.\r\n    return Math.floor((year - 1) / 100) + 1\r\n  }\r\n}\r\n\r\n// Функция для получения цвета века\r\nexport const getCenturyColor = (year: number, minYear: number) => {\r\n  const colors = [\r\n    'rgba(255, 107, 107, 0.1)', // Светло-красный\r\n    'rgba(78, 205, 196, 0.1)', // Светло-голубой\r\n    'rgba(150, 206, 180, 0.1)', // Светло-зеленый\r\n    'rgba(255, 234, 167, 0.1)', // Светло-оранжевый\r\n    'rgba(221, 160, 221, 0.1)', // Светло-фиолетовый\r\n    'rgba(120, 219, 255, 0.1)', // Светло-бирюзовый\r\n    'rgba(255, 255, 229, 0.1)', // Светло-желтый\r\n    'rgba(255, 229, 240, 0.1)', // Светло-розовый\r\n  ]\r\n  \r\n  const centuryIndex = Math.floor((year - minYear) / 100)\r\n  return colors[centuryIndex % colors.length]\r\n}\r\n\r\n// Функция для генерации границ веков\r\nexport const generateCenturyBoundaries = (minYear: number, maxYear: number) => {\r\n  const boundaries = []\r\n  const startCentury = Math.floor(minYear / 100) * 100\r\n  const endCentury = Math.ceil(maxYear / 100) * 100\r\n  \r\n  for (let year = startCentury; year <= endCentury; year += 100) {\r\n    // Включаем границу, если она попадает в диапазон данных или является границей века\r\n    if (year <= maxYear) {\r\n      boundaries.push(year)\r\n    }\r\n  }\r\n  return boundaries\r\n}\r\n\r\n// Функция для вычисления позиции в пикселях\r\nexport const getPosition = (year: number, minYear: number, pixelsPerYear: number, leftPadding: number) => {\r\n  return leftPadding + (year - minYear) * pixelsPerYear\r\n}\r\n\r\n// Функция для вычисления ширины полоски в пикселях\r\nexport const getWidth = (birthYear: number, deathYear: number, pixelsPerYear: number) => {\r\n  return (deathYear - birthYear) * pixelsPerYear\r\n}\r\n\r\n// Вспомогательная функция для извлечения первой страны из списка\r\nexport const getFirstCountry = (countryString: string): string => {\r\n  const countries = countryString.split('/').map(c => c.trim())\r\n  return countries[0] || countryString\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}