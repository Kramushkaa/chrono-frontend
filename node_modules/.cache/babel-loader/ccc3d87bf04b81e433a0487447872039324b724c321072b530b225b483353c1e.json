{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Selecty\\\\Documents\\\\PetProjects\\\\chronoline-frontend\\\\src\\\\App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { AppHeader } from './components/AppHeader';\nimport { Timeline } from './components/Timeline';\nimport { Tooltips } from './components/Tooltips';\nimport { MobilePersonPanel } from './components/MobilePersonPanel';\nimport { useTimelineData } from './hooks/useTimelineData';\nimport { useFilters } from './hooks/useFilters';\nimport { useSlider } from './hooks/useSlider';\nimport { useTooltip } from './hooks/useTooltip';\nimport { useTimelineDrag } from './hooks/useTimelineDrag';\nimport { generateCenturyBoundaries, getFirstCountry } from './utils/timelineUtils';\nimport { getGroupColor, getGroupColorDark, getGroupColorMuted, getPersonGroup, sortGroupedData } from './utils/groupingUtils';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [isScrolled, setIsScrolled] = useState(false);\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState(null);\n  const [selectedPerson, setSelectedPerson] = useState(null);\n  const [showControls, setShowControls] = useState(true);\n\n  // Используем кастомные хуки\n  const {\n    filters,\n    setFilters,\n    groupingType,\n    setGroupingType,\n    yearInputs,\n    setYearInputs,\n    applyYearFilter,\n    handleYearKeyPress,\n    resetAllFilters\n  } = useFilters();\n  const {\n    persons,\n    allCategories,\n    allCountries,\n    isLoading\n  } = useTimelineData(filters);\n  const {\n    isDraggingSlider,\n    handleSliderMouseDown,\n    handleSliderMouseMove,\n    handleSliderMouseUp\n  } = useSlider();\n  const {\n    hoveredPerson,\n    mousePosition,\n    showTooltip,\n    hoveredAchievement,\n    achievementTooltipPosition,\n    showAchievementTooltip,\n    hoverTimerRef,\n    handlePersonHover,\n    handleAchievementHover\n  } = useTooltip();\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    // Проверяем, что все функции определены\n    if (!handleSliderMouseMove || !handleSliderMouseDown || !handleSliderMouseUp) {\n      console.error('Slider functions are not defined:', {\n        handleSliderMouseMove,\n        handleSliderMouseDown,\n        handleSliderMouseUp\n      });\n      return;\n    }\n    if (isDraggingSlider) {\n      const handleMouseMove = e => handleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs);\n      const handleMouseUp = () => handleSliderMouseUp();\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      document.addEventListener('touchmove', handleMouseMove);\n      document.addEventListener('touchend', handleMouseUp);\n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        document.removeEventListener('touchmove', handleMouseMove);\n        document.removeEventListener('touchend', handleMouseUp);\n      };\n    }\n  }, [isDraggingSlider, handleSliderMouseMove, handleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs, setFilters]);\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType);\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n\n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      let newTimeRange = {\n        ...filters.timeRange\n      };\n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n\n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n\n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      setIsScrolled(scrollTop > 50);\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  // Обработчик для закрытия achievement tooltip на мобильных\n  useEffect(() => {\n    const handleCloseAchievementTooltip = () => {\n      handleAchievementHover(null, 0, 0);\n    };\n    const handleClickOutside = event => {\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\n      const target = event.target;\n      const tooltip = document.getElementById('achievement-tooltip');\n      const isClickInsideTooltip = tooltip === null || tooltip === void 0 ? void 0 : tooltip.contains(target);\n      const isClickOnMarker = target.closest('.achievement-marker');\n\n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\n        if (event.type === 'touchstart') {\n          setTimeout(() => {\n            handleAchievementHover(null, 0, 0);\n          }, 100);\n        } else {\n          handleAchievementHover(null, 0, 0);\n        }\n      }\n    };\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('touchstart', handleClickOutside);\n    return () => {\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('touchstart', handleClickOutside);\n    };\n  }, [handleAchievementHover, showAchievementTooltip]);\n\n  // Мемоизируем вычисления диапазона лет\n  const {\n    minYear,\n    totalYears,\n    effectiveMinYear,\n    effectiveMaxYear\n  } = useMemo(() => {\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start);\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end);\n    const totalYears = maxYear - minYear;\n    const effectiveMinYear = filters.hideEmptyCenturies ? Math.min(...sortedData.map(p => p.birthYear)) : minYear;\n    const effectiveMaxYear = filters.hideEmptyCenturies ? Math.max(...sortedData.map(p => p.deathYear)) : maxYear;\n    return {\n      minYear,\n      totalYears,\n      effectiveMinYear,\n      effectiveMaxYear\n    };\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies]);\n\n  // Настройки масштаба\n  const pixelsPerYear = 3; // 3 пикселя на год\n  const LEFT_PADDING_PX = 30; // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX;\n\n  // Хук для перетаскивания timeline\n  const {\n    timelineRef,\n    isDragging,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isDraggingTimeline,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  } = useTimelineDrag({\n    timelineWidth,\n    containerWidth: window.innerWidth\n  });\n\n  // Мемоизируем границы веков\n  const centuryBoundaries = useMemo(() => generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear), [effectiveMinYear, effectiveMaxYear]);\n\n  // Мемоизируем алгоритм размещения полосок на строках\n  const calculateRowPlacement = useCallback(people => {\n    const rows = [];\n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows = [];\n      people.forEach(person => {\n        let placed = false;\n\n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex];\n          let canPlaceInRow = true;\n\n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n              canPlaceInRow = false;\n              break;\n            }\n          }\n\n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person);\n            placed = true;\n            break;\n          }\n        }\n\n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person]);\n        }\n      });\n      return allRows;\n    }\n\n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country';\n    const allGroups = groupingType === 'category' ? allCategories : allCountries;\n    const groups = {};\n\n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue;\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country);\n      } else {\n        groupValue = person[groupField];\n      }\n      if (!groups[groupValue]) {\n        groups[groupValue] = [];\n      }\n      groups[groupValue].push(person);\n    });\n\n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue];\n        const groupRows = [];\n\n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false;\n\n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex];\n            let canPlaceInRow = true;\n\n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n                canPlaceInRow = false;\n                break;\n              }\n            }\n\n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person);\n              placed = true;\n              break;\n            }\n          }\n\n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person]);\n          }\n        });\n\n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows);\n\n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([]);\n        }\n      }\n    });\n    return rows;\n  }, [groupingType, allCategories, allCountries]);\n\n  // Мемоизируем размещение по строкам\n  const rowPlacement = useMemo(() => calculateRowPlacement(sortedData), [calculateRowPlacement, sortedData]);\n\n  // Мемоизируем общую высоту\n  const totalHeight = useMemo(() => rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70); // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0), [rowPlacement]);\n\n  // Функция для создания разделителей категорий\n  // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Мемоизируем вычисление позиций строк\n  const rowTops = useMemo(() => {\n    const tops = [];\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      tops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n    return tops;\n  }, [rowPlacement]);\n  const createCategoryDividers = useCallback(() => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n    const dividers = [];\n    let currentGroup = '';\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue;\n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({\n              category: currentGroup,\n              top: rowTops[rowIndex] - 5\n            });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({\n        category: currentGroup,\n        top: rowTops[rowPlacement.length - 1] - 5\n      });\n    }\n    return dividers;\n  }, [groupingType, rowPlacement, rowTops]);\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    id: \"chrononinja-app\",\n    role: \"main\",\n    \"aria-label\": \"Chrono Ninja - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",\n    children: [/*#__PURE__*/_jsxDEV(AppHeader, {\n      isScrolled: isScrolled,\n      showControls: showControls,\n      setShowControls: setShowControls,\n      filters: filters,\n      setFilters: setFilters,\n      groupingType: groupingType,\n      setGroupingType: setGroupingType,\n      allCategories: allCategories,\n      allCountries: allCountries,\n      yearInputs: yearInputs,\n      setYearInputs: setYearInputs,\n      applyYearFilter: applyYearFilter,\n      handleYearKeyPress: handleYearKeyPress,\n      resetAllFilters: resetAllFilters,\n      getCategoryColor: getGroupColor,\n      sortedData: sortedData,\n      handleSliderMouseDown: handleSliderMouseDown || (() => {}),\n      handleSliderMouseMove: handleSliderMouseMove || (() => {}),\n      handleSliderMouseUp: handleSliderMouseUp || (() => {}),\n      isDraggingSlider: isDraggingSlider\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 436,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"timeline-wrapper\",\n      children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading-overlay\",\n        role: \"status\",\n        \"aria-live\": \"polite\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"spinner\",\n          \"aria-hidden\": \"true\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 463,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 464,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 462,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n        ref: timelineRef,\n        className: `timeline-container ${isDragging ? 'dragging' : ''}`,\n        id: \"timeline-viewport\",\n        role: \"region\",\n        \"aria-label\": \"\\u041E\\u0431\\u043B\\u0430\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0430 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 \\u043B\\u0438\\u043D\\u0438\\u0438\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onTouchStart: handleTouchStart,\n        onTouchMove: handleTouchMove,\n        onTouchEnd: handleTouchEnd,\n        children: /*#__PURE__*/_jsxDEV(Timeline, {\n          isLoading: false,\n          timelineWidth: timelineWidth,\n          totalHeight: totalHeight,\n          centuryBoundaries: centuryBoundaries,\n          minYear: minYear,\n          pixelsPerYear: pixelsPerYear,\n          LEFT_PADDING_PX: LEFT_PADDING_PX,\n          rowPlacement: rowPlacement,\n          filters: filters,\n          groupingType: groupingType,\n          categoryDividers: categoryDividers,\n          getGroupColor: getGroupColor,\n          getGroupColorDark: getGroupColorDark,\n          getGroupColorMuted: getGroupColorMuted,\n          getPersonGroup: person => getPersonGroup(person, groupingType),\n          hoveredPerson: hoveredPerson,\n          setHoveredPerson: person => {\n            if (person) {\n              // Используем текущую позицию мыши из состояния\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\n            } else {\n              handlePersonHover(null, 0, 0);\n            }\n          },\n          mousePosition: mousePosition,\n          setMousePosition: position => {\n            // Обновляем позицию мыши\n            if (hoveredPerson) {\n              handlePersonHover(hoveredPerson, position.x, position.y);\n            }\n          },\n          showTooltip: showTooltip,\n          setShowTooltip: show => {\n            if (!show && hoveredPerson) {\n              handlePersonHover(null, 0, 0);\n            }\n          },\n          activeAchievementMarker: activeAchievementMarker,\n          setActiveAchievementMarker: setActiveAchievementMarker,\n          hoveredAchievement: hoveredAchievement,\n          setHoveredAchievement: achievement => {\n            if (achievement) {\n              // Используем текущую позицию мыши из состояния\n              handleAchievementHover(achievement, achievementTooltipPosition.x, achievementTooltipPosition.y);\n            } else {\n              handleAchievementHover(null, 0, 0);\n            }\n          },\n          achievementTooltipPosition: achievementTooltipPosition,\n          setAchievementTooltipPosition: position => {\n            if (hoveredAchievement) {\n              handleAchievementHover(hoveredAchievement, position.x, position.y);\n            }\n          },\n          showAchievementTooltip: showAchievementTooltip,\n          setShowAchievementTooltip: show => {\n            if (!show && hoveredAchievement) {\n              handleAchievementHover(null, 0, 0);\n            }\n          },\n          handlePersonHover: handlePersonHover,\n          hoverTimerRef: hoverTimerRef,\n          sortedData: sortedData,\n          selectedPerson: selectedPerson,\n          setSelectedPerson: setSelectedPerson\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 482,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 468,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 459,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"aside\", {\n      className: \"tooltips-container\",\n      id: \"tooltips-aside\",\n      \"aria-label\": \"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",\n      children: /*#__PURE__*/_jsxDEV(Tooltips, {\n        hoveredPerson: hoveredPerson,\n        showTooltip: showTooltip,\n        mousePosition: mousePosition,\n        hoveredAchievement: hoveredAchievement,\n        showAchievementTooltip: showAchievementTooltip,\n        achievementTooltipPosition: achievementTooltipPosition,\n        getGroupColor: getGroupColor,\n        getPersonGroup: person => getPersonGroup(person, groupingType),\n        getCategoryColor: getGroupColor\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 553,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 552,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MobilePersonPanel, {\n      selectedPerson: selectedPerson,\n      onClose: () => setSelectedPerson(null),\n      getGroupColor: getGroupColor,\n      getPersonGroup: person => getPersonGroup(person, groupingType),\n      getCategoryColor: getGroupColor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 567,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 435,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"OIUXR5MjIvG53xX38PqBElvJn7w=\", false, function () {\n  return [useFilters, useTimelineData, useSlider, useTooltip, useTimelineDrag];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useMemo","useCallback","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","useFilters","useSlider","useTooltip","useTimelineDrag","generateCenturyBoundaries","getFirstCountry","getGroupColor","getGroupColorDark","getGroupColorMuted","getPersonGroup","sortGroupedData","jsxDEV","_jsxDEV","App","_s","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","showControls","setShowControls","filters","setFilters","groupingType","setGroupingType","yearInputs","setYearInputs","applyYearFilter","handleYearKeyPress","resetAllFilters","persons","allCategories","allCountries","isLoading","isDraggingSlider","handleSliderMouseDown","handleSliderMouseMove","handleSliderMouseUp","hoveredPerson","mousePosition","showTooltip","hoveredAchievement","achievementTooltipPosition","showAchievementTooltip","hoverTimerRef","handlePersonHover","handleAchievementHover","console","error","handleMouseMove","e","handleMouseUp","document","addEventListener","removeEventListener","sortedData","hideEmptyCenturies","length","effectiveMinYear","Math","min","map","p","birthYear","effectiveMaxYear","max","deathYear","hasActiveFilters","categories","countries","newTimeRange","timeRange","start","end","prev","toString","handleScroll","scrollTop","window","pageYOffset","documentElement","handleCloseAchievementTooltip","handleClickOutside","event","target","tooltip","getElementById","isClickInsideTooltip","contains","isClickOnMarker","closest","type","setTimeout","minYear","totalYears","maxYear","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","timelineRef","isDragging","isDraggingTimeline","handleMouseDown","handleTouchStart","handleTouchMove","handleTouchEnd","containerWidth","innerWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","person","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","country","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","tops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","category","top","categoryDividers","className","id","role","children","getCategoryColor","fileName","_jsxFileName","lineNumber","columnNumber","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","setHoveredPerson","x","y","setMousePosition","position","setShowTooltip","show","setHoveredAchievement","achievement","setAchievementTooltipPosition","setShowAchievementTooltip","onClose","_c","$RefreshReg$"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react'\nimport { Person } from './types'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { useFilters } from './hooks/useFilters'\nimport { useSlider } from './hooks/useSlider'\nimport { useTooltip } from './hooks/useTooltip'\nimport { useTimelineDrag } from './hooks/useTimelineDrag'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport { \n  getGroupColor, \n  getGroupColorDark, \n  getGroupColorMuted, \n  getPersonGroup,\n  sortGroupedData\n} from './utils/groupingUtils'\nimport './App.css'\n\nfunction App() {\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const [showControls, setShowControls] = useState(true)\n\n  // Используем кастомные хуки\n  const { \n    filters, \n    setFilters, \n    groupingType, \n    setGroupingType, \n    yearInputs, \n    setYearInputs, \n    applyYearFilter, \n    handleYearKeyPress, \n    resetAllFilters \n  } = useFilters()\n  \n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  const { \n    isDraggingSlider, \n    handleSliderMouseDown, \n    handleSliderMouseMove, \n    handleSliderMouseUp \n  } = useSlider()\n\n\n  \n  const { \n    hoveredPerson, \n    mousePosition, \n    showTooltip, \n    hoveredAchievement, \n    achievementTooltipPosition, \n    showAchievementTooltip, \n    hoverTimerRef, \n    handlePersonHover, \n    handleAchievementHover \n  } = useTooltip()\n\n\n\n\n\n\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    // Проверяем, что все функции определены\n    if (!handleSliderMouseMove || !handleSliderMouseDown || !handleSliderMouseUp) {\n      console.error('Slider functions are not defined:', { handleSliderMouseMove, handleSliderMouseDown, handleSliderMouseUp });\n      return;\n    }\n\n    if (isDraggingSlider) {\n      const handleMouseMove = (e: MouseEvent | TouchEvent) => \n        handleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs)\n      \n      const handleMouseUp = () => handleSliderMouseUp()\n      \n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.addEventListener('touchmove', handleMouseMove)\n      document.addEventListener('touchend', handleMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleMouseMove)\n        document.removeEventListener('touchend', handleMouseUp)\n      }\n    }\n  }, [isDraggingSlider, handleSliderMouseMove, handleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs, setFilters])\n\n\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType)\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Обработчик для закрытия achievement tooltip на мобильных\n  useEffect(() => {\n    const handleCloseAchievementTooltip = () => {\n      handleAchievementHover(null, 0, 0);\n    };\n\n    const handleClickOutside = (event: Event) => {\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\n      const target = event.target as Element;\n      const tooltip = document.getElementById('achievement-tooltip');\n      const isClickInsideTooltip = tooltip?.contains(target);\n      const isClickOnMarker = target.closest('.achievement-marker');\n      \n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\n        if (event.type === 'touchstart') {\n          setTimeout(() => {\n            handleAchievementHover(null, 0, 0);\n          }, 100);\n        } else {\n          handleAchievementHover(null, 0, 0);\n        }\n      }\n    };\n\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('touchstart', handleClickOutside);\n    \n    return () => {\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('touchstart', handleClickOutside);\n    };\n  }, [handleAchievementHover, showAchievementTooltip]);\n\n  // Мемоизируем вычисления диапазона лет\n  const { minYear, totalYears, effectiveMinYear, effectiveMaxYear } = useMemo(() => {\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n    const totalYears = maxYear - minYear\n    \n    const effectiveMinYear = filters.hideEmptyCenturies \n      ? Math.min(...sortedData.map(p => p.birthYear))\n      : minYear\n    const effectiveMaxYear = filters.hideEmptyCenturies \n      ? Math.max(...sortedData.map(p => p.deathYear))\n      : maxYear\n    \n    return { minYear, totalYears, effectiveMinYear, effectiveMaxYear }\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies])\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Хук для перетаскивания timeline\n  const {\n    timelineRef,\n    isDragging,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isDraggingTimeline,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  } = useTimelineDrag({\n    timelineWidth,\n    containerWidth: window.innerWidth\n  })\n\n  // Мемоизируем границы веков\n  const centuryBoundaries = useMemo(() => \n    generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear),\n    [effectiveMinYear, effectiveMaxYear]\n  )\n\n  // Мемоизируем алгоритм размещения полосок на строках\n  const calculateRowPlacement = useCallback((people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }, [groupingType, allCategories, allCountries])\n\n  // Мемоизируем размещение по строкам\n  const rowPlacement = useMemo(() => \n    calculateRowPlacement(sortedData),\n    [calculateRowPlacement, sortedData]\n  )\n\n  // Мемоизируем общую высоту\n  const totalHeight = useMemo(() => \n    rowPlacement.reduce((height, row) => {\n      return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n    }, 0),\n    [rowPlacement]\n  )\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Мемоизируем вычисление позиций строк\n  const rowTops = useMemo(() => {\n    const tops: number[] = [];\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      tops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n    return tops;\n  }, [rowPlacement]);\n\n  const createCategoryDividers = useCallback(() => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  }, [groupingType, rowPlacement, rowTops]);\n\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\n\n  return (\n    <div className=\"app\" id=\"chrononinja-app\" role=\"main\" aria-label=\"Chrono Ninja - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getGroupColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={handleSliderMouseDown || (() => {})}\n        handleSliderMouseMove={handleSliderMouseMove || (() => {})}\n        handleSliderMouseUp={handleSliderMouseUp || (() => {})}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <div className=\"timeline-wrapper\">\n        {/* Загрузка только для области timeline */}\n        {isLoading && (\n          <div className=\"loading-overlay\" role=\"status\" aria-live=\"polite\">\n            <div className=\"spinner\" aria-hidden=\"true\"></div>\n            <span>Загрузка данных...</span>\n          </div>\n        )}\n        \n        <main \n          ref={timelineRef}\n          className={`timeline-container ${isDragging ? 'dragging' : ''}`}\n          id=\"timeline-viewport\" \n          role=\"region\" \n          aria-label=\"Область просмотра временной линии\"\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onTouchStart={handleTouchStart}\n          onTouchMove={handleTouchMove}\n          onTouchEnd={handleTouchEnd}\n        >\n          <Timeline\n          isLoading={false}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={(person) => {\n            if (person) {\n              // Используем текущую позицию мыши из состояния\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\n            } else {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          mousePosition={mousePosition}\n          setMousePosition={(position) => {\n            // Обновляем позицию мыши\n            if (hoveredPerson) {\n              handlePersonHover(hoveredPerson, position.x, position.y);\n            }\n          }}\n          showTooltip={showTooltip}\n          setShowTooltip={(show) => {\n            if (!show && hoveredPerson) {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={(achievement) => {\n            if (achievement) {\n              // Используем текущую позицию мыши из состояния\n              handleAchievementHover(achievement, achievementTooltipPosition.x, achievementTooltipPosition.y);\n            } else {\n              handleAchievementHover(null, 0, 0);\n            }\n          }}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={(position) => {\n            if (hoveredAchievement) {\n              handleAchievementHover(hoveredAchievement, position.x, position.y);\n            }\n          }}\n          showAchievementTooltip={showAchievementTooltip}\n                  setShowAchievementTooltip={(show) => {\n          if (!show && hoveredAchievement) {\n            handleAchievementHover(null, 0, 0);\n          }\n        }}\n        handlePersonHover={handlePersonHover}\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n        </main>\n      </div>\n\n      <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          getCategoryColor={getGroupColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n        getCategoryColor={getGroupColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}