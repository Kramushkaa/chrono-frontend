{"ast":null,"code":"import React,{useState,useEffect,useMemo,useCallback}from'react';import{AppHeader}from'./components/AppHeader';import{Timeline}from'./components/Timeline';import{Tooltips}from'./components/Tooltips';import{MobilePersonPanel}from'./components/MobilePersonPanel';import{useTimelineData}from'./hooks/useTimelineData';import{useFilters}from'./hooks/useFilters';import{useSlider}from'./hooks/useSlider';import{useTooltip}from'./hooks/useTooltip';import{useTimelineDrag}from'./hooks/useTimelineDrag';import{generateCenturyBoundaries,getFirstCountry}from'./utils/timelineUtils';import{getGroupColor,getGroupColorDark,getGroupColorMuted,getPersonGroup,sortGroupedData}from'./utils/groupingUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const[isScrolled,setIsScrolled]=useState(false);const[activeAchievementMarker,setActiveAchievementMarker]=useState(null);const[selectedPerson,setSelectedPerson]=useState(null);const[showControls,setShowControls]=useState(true);// Используем кастомные хуки\nconst{filters,setFilters,groupingType,setGroupingType,yearInputs,setYearInputs,applyYearFilter,handleYearKeyPress,resetAllFilters}=useFilters();const{persons,allCategories,allCountries,isLoading}=useTimelineData(filters);const{isDraggingSlider,handleSliderMouseDown,handleSliderMouseMove,handleSliderMouseUp}=useSlider();const{hoveredPerson,mousePosition,showTooltip,hoveredAchievement,achievementTooltipPosition,showAchievementTooltip,hoverTimerRef,handlePersonHover,handleAchievementHover}=useTooltip();// Добавляем обработчики событий мыши и touch\nuseEffect(()=>{if(isDraggingSlider){const handleMouseMove=e=>handleSliderMouseMove(e,yearInputs,applyYearFilter,setYearInputs);const handleMouseUp=()=>handleSliderMouseUp();document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',handleMouseUp);document.addEventListener('touchmove',handleMouseMove);document.addEventListener('touchend',handleMouseUp);return()=>{document.removeEventListener('mousemove',handleMouseMove);document.removeEventListener('mouseup',handleMouseUp);document.removeEventListener('touchmove',handleMouseMove);document.removeEventListener('touchend',handleMouseUp);};}},[isDraggingSlider,handleSliderMouseMove,handleSliderMouseUp,yearInputs,applyYearFilter,setYearInputs,setFilters]);// Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\nconst sortedData=sortGroupedData(persons,groupingType);// Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\nuseEffect(()=>{if(filters.hideEmptyCenturies&&sortedData.length>0){// Вычисляем эффективный диапазон на основе отфильтрованных данных\nconst effectiveMinYear=Math.min(...sortedData.map(p=>p.birthYear));const effectiveMaxYear=Math.max(...sortedData.map(p=>p.deathYear));// Проверяем, есть ли активные фильтры (категории или страны)\nconst hasActiveFilters=filters.categories.length>0||filters.countries.length>0;let newTimeRange={...filters.timeRange};if(hasActiveFilters){// Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\nnewTimeRange={start:Math.max(filters.timeRange.start,effectiveMinYear),end:Math.min(filters.timeRange.end,effectiveMaxYear)};}else{// Если нет активных фильтров, НЕ сужаем диапазон\n// Пользователь может хотеть видеть данные за пределами текущего диапазона\nnewTimeRange=filters.timeRange;}// Обновляем только если диапазон изменился\nif(newTimeRange.start!==filters.timeRange.start||newTimeRange.end!==filters.timeRange.end){setFilters(prev=>({...prev,timeRange:newTimeRange}));// Обновляем поля ввода\nsetYearInputs({start:newTimeRange.start.toString(),end:newTimeRange.end.toString()});}}},[filters.hideEmptyCenturies,sortedData,filters.categories,filters.countries,filters.timeRange,setFilters,setYearInputs]);// Отслеживаем скролл\nuseEffect(()=>{const handleScroll=()=>{const scrollTop=window.pageYOffset||document.documentElement.scrollTop;setIsScrolled(scrollTop>50);};window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);// Обработчик для закрытия achievement tooltip на мобильных\nuseEffect(()=>{const handleCloseAchievementTooltip=()=>{handleAchievementHover(null,0,0);};const handleClickOutside=event=>{// Проверяем, что клик был вне tooltip'а и вне маркеров достижений\nconst target=event.target;const tooltip=document.getElementById('achievement-tooltip');const isClickInsideTooltip=tooltip===null||tooltip===void 0?void 0:tooltip.contains(target);const isClickOnMarker=target.closest('.achievement-marker');// Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\nif(!isClickInsideTooltip&&!isClickOnMarker&&showAchievementTooltip){if(event.type==='touchstart'){setTimeout(()=>{handleAchievementHover(null,0,0);},100);}else{handleAchievementHover(null,0,0);}}};window.addEventListener('closeAchievementTooltip',handleCloseAchievementTooltip);document.addEventListener('mousedown',handleClickOutside);document.addEventListener('touchstart',handleClickOutside);return()=>{window.removeEventListener('closeAchievementTooltip',handleCloseAchievementTooltip);document.removeEventListener('mousedown',handleClickOutside);document.removeEventListener('touchstart',handleClickOutside);};},[handleAchievementHover,showAchievementTooltip]);// Мемоизируем вычисления диапазона лет\nconst{minYear,totalYears,effectiveMinYear,effectiveMaxYear}=useMemo(()=>{const minYear=Math.min(...sortedData.map(p=>p.birthYear),filters.timeRange.start);const maxYear=Math.max(...sortedData.map(p=>p.deathYear),filters.timeRange.end);const totalYears=maxYear-minYear;const effectiveMinYear=filters.hideEmptyCenturies?Math.min(...sortedData.map(p=>p.birthYear)):minYear;const effectiveMaxYear=filters.hideEmptyCenturies?Math.max(...sortedData.map(p=>p.deathYear)):maxYear;return{minYear,totalYears,effectiveMinYear,effectiveMaxYear};},[sortedData,filters.timeRange.start,filters.timeRange.end,filters.hideEmptyCenturies]);// Настройки масштаба\nconst pixelsPerYear=3;// 3 пикселя на год\nconst LEFT_PADDING_PX=30;// отступ слева, чтобы крайняя левая подпись не упиралась в край\nconst timelineWidth=totalYears*pixelsPerYear+LEFT_PADDING_PX;// Хук для перетаскивания timeline\nconst{timelineRef,isDragging,isDraggingTimeline,handleMouseDown,handleMouseMove,handleMouseUp,handleTouchStart,handleTouchMove,handleTouchEnd}=useTimelineDrag({timelineWidth,containerWidth:window.innerWidth});// Мемоизируем границы веков\nconst centuryBoundaries=useMemo(()=>generateCenturyBoundaries(effectiveMinYear,effectiveMaxYear),[effectiveMinYear,effectiveMaxYear]);// Мемоизируем алгоритм размещения полосок на строках\nconst calculateRowPlacement=useCallback(people=>{const rows=[];if(groupingType==='none'){// Без группировки - просто размещаем всех в строки\nconst allRows=[];people.forEach(person=>{let placed=false;// Проверяем каждую существующую строку\nfor(let rowIndex=0;rowIndex<allRows.length;rowIndex++){const row=allRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){allRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){allRows.push([person]);}});return allRows;}// Группировка по категориям или странам\nconst groupField=groupingType==='category'?'category':'country';const allGroups=groupingType==='category'?allCategories:allCountries;const groups={};// Группируем людей по выбранному полю\npeople.forEach(person=>{let groupValue;if(groupField==='country'){// Для стран берем первую из списка, если есть несколько через \"/\"\ngroupValue=getFirstCountry(person.country);}else{groupValue=person[groupField];}if(!groups[groupValue]){groups[groupValue]=[];}groups[groupValue].push(person);});// Обрабатываем каждую группу в заданном порядке\nallGroups.forEach(groupValue=>{if(groups[groupValue]){const groupPeople=groups[groupValue];const groupRows=[];// Размещаем людей данной группы в отдельные строки\ngroupPeople.forEach(person=>{let placed=false;// Проверяем каждую существующую строку для этой группы\nfor(let rowIndex=0;rowIndex<groupRows.length;rowIndex++){const row=groupRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){groupRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){groupRows.push([person]);}});// Добавляем строки данной группы к общему списку\nrows.push(...groupRows);// Добавляем пустую строку для визуального разделения (кроме последней группы)\nif(groupValue!==allGroups[allGroups.length-1]){rows.push([]);}}});return rows;},[groupingType,allCategories,allCountries]);// Мемоизируем размещение по строкам\nconst rowPlacement=useMemo(()=>calculateRowPlacement(sortedData),[calculateRowPlacement,sortedData]);// Мемоизируем общую высоту\nconst totalHeight=useMemo(()=>rowPlacement.reduce((height,row)=>{return height+(row.length===0?20:70);// 20px для пустых строк, 70px для обычных (60px + 10px margin)\n},0),[rowPlacement]);// Функция для создания разделителей категорий\n// Высота строки и отступ вниз для непустой строки\nconst ROW_HEIGHT=60;const ROW_MARGIN=10;// margin-bottom, используется только для непустых строк\nconst EMPTY_ROW_HEIGHT=20;// Мемоизируем вычисление позиций строк\nconst rowTops=useMemo(()=>{const tops=[];let acc=0;rowPlacement.forEach(row=>{tops.push(acc);if(row.length===0){acc+=EMPTY_ROW_HEIGHT;}else{acc+=ROW_HEIGHT+ROW_MARGIN;}});return tops;},[rowPlacement]);const createCategoryDividers=useCallback(()=>{if(groupingType==='none'){return[];// Без группировки нет разделителей\n}const dividers=[];let currentGroup='';rowPlacement.forEach((row,rowIndex)=>{if(row.length>0){const firstPersonInRow=row[0];let currentGroupValue;if(groupingType==='category'){currentGroupValue=firstPersonInRow.category;}else if(groupingType==='country'){// Для стран берем первую из списка\ncurrentGroupValue=getFirstCountry(firstPersonInRow.country);}else{currentGroupValue=firstPersonInRow.category;}if(currentGroupValue!==currentGroup){if(currentGroup!==''){// закрываем предыдущую группу\ndividers.push({category:currentGroup,top:rowTops[rowIndex]-5});}currentGroup=currentGroupValue;}}});// Добавляем разделитель для последней группы\nif(currentGroup!==''){dividers.push({category:currentGroup,top:rowTops[rowPlacement.length-1]-5});}return dividers;},[groupingType,rowPlacement,rowTops]);const categoryDividers=useMemo(()=>createCategoryDividers(),[createCategoryDividers]);return/*#__PURE__*/_jsxs(\"div\",{className:\"app\",id:\"chrononinja-app\",role:\"main\",\"aria-label\":\"Chrono Ninja - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",children:[/*#__PURE__*/_jsx(AppHeader,{isScrolled:isScrolled,showControls:showControls,setShowControls:setShowControls,filters:filters,setFilters:setFilters,groupingType:groupingType,setGroupingType:setGroupingType,allCategories:allCategories,allCountries:allCountries,yearInputs:yearInputs,setYearInputs:setYearInputs,applyYearFilter:applyYearFilter,handleYearKeyPress:handleYearKeyPress,resetAllFilters:resetAllFilters,getCategoryColor:getGroupColor,sortedData:sortedData,handleSliderMouseDown:handleSliderMouseDown,handleSliderMouseMove:handleSliderMouseMove,handleSliderMouseUp:handleSliderMouseUp,isDraggingSlider:isDraggingSlider}),/*#__PURE__*/_jsxs(\"div\",{className:\"timeline-wrapper\",children:[isLoading&&/*#__PURE__*/_jsxs(\"div\",{className:\"loading-overlay\",role:\"status\",\"aria-live\":\"polite\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"spinner\",\"aria-hidden\":\"true\"}),/*#__PURE__*/_jsx(\"span\",{children:\"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445...\"})]}),/*#__PURE__*/_jsx(\"main\",{ref:timelineRef,className:`timeline-container ${isDragging?'dragging':''}`,id:\"timeline-viewport\",role:\"region\",\"aria-label\":\"\\u041E\\u0431\\u043B\\u0430\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0430 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 \\u043B\\u0438\\u043D\\u0438\\u0438\",onMouseDown:handleMouseDown,onMouseMove:handleMouseMove,onMouseUp:handleMouseUp,onMouseLeave:handleMouseUp,onTouchStart:handleTouchStart,onTouchMove:handleTouchMove,onTouchEnd:handleTouchEnd,children:/*#__PURE__*/_jsx(Timeline,{isLoading:false,timelineWidth:timelineWidth,totalHeight:totalHeight,centuryBoundaries:centuryBoundaries,minYear:minYear,pixelsPerYear:pixelsPerYear,LEFT_PADDING_PX:LEFT_PADDING_PX,rowPlacement:rowPlacement,filters:filters,groupingType:groupingType,categoryDividers:categoryDividers,getGroupColor:getGroupColor,getGroupColorDark:getGroupColorDark,getGroupColorMuted:getGroupColorMuted,getPersonGroup:person=>getPersonGroup(person,groupingType),hoveredPerson:hoveredPerson,setHoveredPerson:person=>{if(person){// Используем текущую позицию мыши из состояния\nhandlePersonHover(person,mousePosition.x,mousePosition.y);}else{handlePersonHover(null,0,0);}},mousePosition:mousePosition,setMousePosition:position=>{// Обновляем позицию мыши\nif(hoveredPerson){handlePersonHover(hoveredPerson,position.x,position.y);}},showTooltip:showTooltip,setShowTooltip:show=>{if(!show&&hoveredPerson){handlePersonHover(null,0,0);}},activeAchievementMarker:activeAchievementMarker,setActiveAchievementMarker:setActiveAchievementMarker,hoveredAchievement:hoveredAchievement,setHoveredAchievement:achievement=>{if(achievement){// Используем текущую позицию мыши из состояния\nhandleAchievementHover(achievement,achievementTooltipPosition.x,achievementTooltipPosition.y);}else{handleAchievementHover(null,0,0);}},achievementTooltipPosition:achievementTooltipPosition,setAchievementTooltipPosition:position=>{if(hoveredAchievement){handleAchievementHover(hoveredAchievement,position.x,position.y);}},showAchievementTooltip:showAchievementTooltip,setShowAchievementTooltip:show=>{if(!show&&hoveredAchievement){handleAchievementHover(null,0,0);}},handlePersonHover:handlePersonHover,hoverTimerRef:hoverTimerRef,sortedData:sortedData,selectedPerson:selectedPerson,setSelectedPerson:setSelectedPerson})})]}),/*#__PURE__*/_jsx(\"aside\",{className:\"tooltips-container\",id:\"tooltips-aside\",\"aria-label\":\"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",children:/*#__PURE__*/_jsx(Tooltips,{hoveredPerson:hoveredPerson,showTooltip:showTooltip,mousePosition:mousePosition,hoveredAchievement:hoveredAchievement,showAchievementTooltip:showAchievementTooltip,achievementTooltipPosition:achievementTooltipPosition,getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})}),/*#__PURE__*/_jsx(MobilePersonPanel,{selectedPerson:selectedPerson,onClose:()=>setSelectedPerson(null),getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})]});}export default App;","map":{"version":3,"names":["React","useState","useEffect","useMemo","useCallback","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","useFilters","useSlider","useTooltip","useTimelineDrag","generateCenturyBoundaries","getFirstCountry","getGroupColor","getGroupColorDark","getGroupColorMuted","getPersonGroup","sortGroupedData","jsx","_jsx","jsxs","_jsxs","App","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","showControls","setShowControls","filters","setFilters","groupingType","setGroupingType","yearInputs","setYearInputs","applyYearFilter","handleYearKeyPress","resetAllFilters","persons","allCategories","allCountries","isLoading","isDraggingSlider","handleSliderMouseDown","handleSliderMouseMove","handleSliderMouseUp","hoveredPerson","mousePosition","showTooltip","hoveredAchievement","achievementTooltipPosition","showAchievementTooltip","hoverTimerRef","handlePersonHover","handleAchievementHover","handleMouseMove","e","handleMouseUp","document","addEventListener","removeEventListener","sortedData","hideEmptyCenturies","length","effectiveMinYear","Math","min","map","p","birthYear","effectiveMaxYear","max","deathYear","hasActiveFilters","categories","countries","newTimeRange","timeRange","start","end","prev","toString","handleScroll","scrollTop","window","pageYOffset","documentElement","handleCloseAchievementTooltip","handleClickOutside","event","target","tooltip","getElementById","isClickInsideTooltip","contains","isClickOnMarker","closest","type","setTimeout","minYear","totalYears","maxYear","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","timelineRef","isDragging","isDraggingTimeline","handleMouseDown","handleTouchStart","handleTouchMove","handleTouchEnd","containerWidth","innerWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","person","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","country","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","tops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","category","top","categoryDividers","className","id","role","children","getCategoryColor","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","setHoveredPerson","x","y","setMousePosition","position","setShowTooltip","show","setHoveredAchievement","achievement","setAchievementTooltipPosition","setShowAchievementTooltip","onClose"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react'\r\nimport { Person } from './types'\r\nimport { AppHeader } from './components/AppHeader'\r\nimport { Timeline } from './components/Timeline'\r\nimport { Tooltips } from './components/Tooltips'\r\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\r\nimport { useTimelineData } from './hooks/useTimelineData'\r\nimport { useFilters } from './hooks/useFilters'\r\nimport { useSlider } from './hooks/useSlider'\r\nimport { useTooltip } from './hooks/useTooltip'\r\nimport { useTimelineDrag } from './hooks/useTimelineDrag'\r\nimport { \r\n  generateCenturyBoundaries,\r\n  getFirstCountry\r\n} from './utils/timelineUtils'\r\nimport { \r\n  getGroupColor, \r\n  getGroupColorDark, \r\n  getGroupColorMuted, \r\n  getPersonGroup,\r\n  sortGroupedData\r\n} from './utils/groupingUtils'\r\nimport './App.css'\r\n\r\nfunction App() {\r\n  const [isScrolled, setIsScrolled] = useState(false)\r\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\r\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\r\n  const [showControls, setShowControls] = useState(true)\r\n\r\n  // Используем кастомные хуки\r\n  const { \r\n    filters, \r\n    setFilters, \r\n    groupingType, \r\n    setGroupingType, \r\n    yearInputs, \r\n    setYearInputs, \r\n    applyYearFilter, \r\n    handleYearKeyPress, \r\n    resetAllFilters \r\n  } = useFilters()\r\n  \r\n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\r\n\r\n  const { \r\n    isDraggingSlider, \r\n    handleSliderMouseDown, \r\n    handleSliderMouseMove, \r\n    handleSliderMouseUp \r\n  } = useSlider()\r\n  \r\n  const { \r\n    hoveredPerson, \r\n    mousePosition, \r\n    showTooltip, \r\n    hoveredAchievement, \r\n    achievementTooltipPosition, \r\n    showAchievementTooltip, \r\n    hoverTimerRef, \r\n    handlePersonHover, \r\n    handleAchievementHover \r\n  } = useTooltip()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  // Добавляем обработчики событий мыши и touch\r\n  useEffect(() => {\r\n    if (isDraggingSlider) {\r\n      const handleMouseMove = (e: MouseEvent | TouchEvent) => \r\n        handleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs)\r\n      \r\n      const handleMouseUp = () => handleSliderMouseUp()\r\n      \r\n      document.addEventListener('mousemove', handleMouseMove)\r\n      document.addEventListener('mouseup', handleMouseUp)\r\n      document.addEventListener('touchmove', handleMouseMove)\r\n      document.addEventListener('touchend', handleMouseUp)\r\n      \r\n      return () => {\r\n        document.removeEventListener('mousemove', handleMouseMove)\r\n        document.removeEventListener('mouseup', handleMouseUp)\r\n        document.removeEventListener('touchmove', handleMouseMove)\r\n        document.removeEventListener('touchend', handleMouseUp)\r\n      }\r\n    }\r\n  }, [isDraggingSlider, handleSliderMouseMove, handleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs, setFilters])\r\n\r\n\r\n\r\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\r\n  const sortedData = sortGroupedData(persons, groupingType)\r\n\r\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\r\n  useEffect(() => {\r\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\r\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\r\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\r\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\r\n      \r\n      // Проверяем, есть ли активные фильтры (категории или страны)\r\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\r\n      \r\n      let newTimeRange = { ...filters.timeRange };\r\n      \r\n      if (hasActiveFilters) {\r\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\r\n        newTimeRange = {\r\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\r\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\r\n        };\r\n      } else {\r\n        // Если нет активных фильтров, НЕ сужаем диапазон\r\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\r\n        newTimeRange = filters.timeRange;\r\n      }\r\n      \r\n      // Обновляем только если диапазон изменился\r\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\r\n        setFilters(prev => ({\r\n          ...prev,\r\n          timeRange: newTimeRange\r\n        }));\r\n        \r\n        // Обновляем поля ввода\r\n        setYearInputs({\r\n          start: newTimeRange.start.toString(),\r\n          end: newTimeRange.end.toString()\r\n        });\r\n      }\r\n    }\r\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\r\n\r\n  // Отслеживаем скролл\r\n  useEffect(() => {\r\n    const handleScroll = () => {\r\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\r\n      setIsScrolled(scrollTop > 50)\r\n    }\r\n\r\n    window.addEventListener('scroll', handleScroll)\r\n    return () => window.removeEventListener('scroll', handleScroll)\r\n  }, [])\r\n\r\n  // Обработчик для закрытия achievement tooltip на мобильных\r\n  useEffect(() => {\r\n    const handleCloseAchievementTooltip = () => {\r\n      handleAchievementHover(null, 0, 0);\r\n    };\r\n\r\n    const handleClickOutside = (event: Event) => {\r\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\r\n      const target = event.target as Element;\r\n      const tooltip = document.getElementById('achievement-tooltip');\r\n      const isClickInsideTooltip = tooltip?.contains(target);\r\n      const isClickOnMarker = target.closest('.achievement-marker');\r\n      \r\n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\r\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\r\n        if (event.type === 'touchstart') {\r\n          setTimeout(() => {\r\n            handleAchievementHover(null, 0, 0);\r\n          }, 100);\r\n        } else {\r\n          handleAchievementHover(null, 0, 0);\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\r\n    document.addEventListener('mousedown', handleClickOutside);\r\n    document.addEventListener('touchstart', handleClickOutside);\r\n    \r\n    return () => {\r\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n      document.removeEventListener('touchstart', handleClickOutside);\r\n    };\r\n  }, [handleAchievementHover, showAchievementTooltip]);\r\n\r\n  // Мемоизируем вычисления диапазона лет\r\n  const { minYear, totalYears, effectiveMinYear, effectiveMaxYear } = useMemo(() => {\r\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\r\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\r\n    const totalYears = maxYear - minYear\r\n    \r\n    const effectiveMinYear = filters.hideEmptyCenturies \r\n      ? Math.min(...sortedData.map(p => p.birthYear))\r\n      : minYear\r\n    const effectiveMaxYear = filters.hideEmptyCenturies \r\n      ? Math.max(...sortedData.map(p => p.deathYear))\r\n      : maxYear\r\n    \r\n    return { minYear, totalYears, effectiveMinYear, effectiveMaxYear }\r\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies])\r\n\r\n  // Настройки масштаба\r\n  const pixelsPerYear = 3 // 3 пикселя на год\r\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\r\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\r\n\r\n  // Хук для перетаскивания timeline\r\n  const {\r\n    timelineRef,\r\n    isDragging,\r\n    isDraggingTimeline,\r\n    handleMouseDown,\r\n    handleMouseMove,\r\n    handleMouseUp,\r\n    handleTouchStart,\r\n    handleTouchMove,\r\n    handleTouchEnd\r\n  } = useTimelineDrag({\r\n    timelineWidth,\r\n    containerWidth: window.innerWidth\r\n  })\r\n\r\n  // Мемоизируем границы веков\r\n  const centuryBoundaries = useMemo(() => \r\n    generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear),\r\n    [effectiveMinYear, effectiveMaxYear]\r\n  )\r\n\r\n  // Мемоизируем алгоритм размещения полосок на строках\r\n  const calculateRowPlacement = useCallback((people: Person[]) => {\r\n    const rows: Person[][] = []\r\n    \r\n    if (groupingType === 'none') {\r\n      // Без группировки - просто размещаем всех в строки\r\n      const allRows: Person[][] = []\r\n      \r\n      people.forEach(person => {\r\n        let placed = false\r\n        \r\n        // Проверяем каждую существующую строку\r\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\r\n          const row = allRows[rowIndex]\r\n          let canPlaceInRow = true\r\n          \r\n          // Проверяем, не пересекается ли с кем-то в этой строке\r\n          for (const existingPerson of row) {\r\n            const BUFFER = 20; // минимальный зазор между персонами\r\n            if (\r\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\r\n              person.deathYear + BUFFER >= existingPerson.birthYear\r\n            ) {\r\n              canPlaceInRow = false\r\n              break\r\n            }\r\n          }\r\n          \r\n          // Если можно разместить в этой строке\r\n          if (canPlaceInRow) {\r\n            allRows[rowIndex].push(person)\r\n            placed = true\r\n            break\r\n          }\r\n        }\r\n        \r\n        // Если не удалось разместить в существующих строках, создаем новую\r\n        if (!placed) {\r\n          allRows.push([person])\r\n        }\r\n      })\r\n      \r\n      return allRows\r\n    }\r\n    \r\n    // Группировка по категориям или странам\r\n    const groupField = groupingType === 'category' ? 'category' : 'country'\r\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\r\n    const groups: { [key: string]: Person[] } = {}\r\n    \r\n    // Группируем людей по выбранному полю\r\n    people.forEach(person => {\r\n      let groupValue: string\r\n      if (groupField === 'country') {\r\n        // Для стран берем первую из списка, если есть несколько через \"/\"\r\n        groupValue = getFirstCountry(person.country)\r\n      } else {\r\n        groupValue = person[groupField]\r\n      }\r\n      \r\n      if (!groups[groupValue]) {\r\n        groups[groupValue] = []\r\n      }\r\n      groups[groupValue].push(person)\r\n    })\r\n    \r\n    // Обрабатываем каждую группу в заданном порядке\r\n    allGroups.forEach(groupValue => {\r\n      if (groups[groupValue]) {\r\n        const groupPeople = groups[groupValue]\r\n        const groupRows: Person[][] = []\r\n        \r\n        // Размещаем людей данной группы в отдельные строки\r\n        groupPeople.forEach(person => {\r\n          let placed = false\r\n          \r\n          // Проверяем каждую существующую строку для этой группы\r\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\r\n            const row = groupRows[rowIndex]\r\n            let canPlaceInRow = true\r\n            \r\n            // Проверяем, не пересекается ли с кем-то в этой строке\r\n            for (const existingPerson of row) {\r\n              const BUFFER = 20; // минимальный зазор между персонами\r\n              if (\r\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\r\n                person.deathYear + BUFFER >= existingPerson.birthYear\r\n              ) {\r\n                canPlaceInRow = false\r\n                break\r\n              }\r\n            }\r\n            \r\n            // Если можно разместить в этой строке\r\n            if (canPlaceInRow) {\r\n              groupRows[rowIndex].push(person)\r\n              placed = true\r\n              break\r\n            }\r\n          }\r\n          \r\n          // Если не удалось разместить в существующих строках, создаем новую\r\n          if (!placed) {\r\n            groupRows.push([person])\r\n          }\r\n        })\r\n        \r\n        // Добавляем строки данной группы к общему списку\r\n        rows.push(...groupRows)\r\n        \r\n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\r\n        if (groupValue !== allGroups[allGroups.length - 1]) {\r\n          rows.push([])\r\n        }\r\n      }\r\n    })\r\n    \r\n    return rows\r\n  }, [groupingType, allCategories, allCountries])\r\n\r\n  // Мемоизируем размещение по строкам\r\n  const rowPlacement = useMemo(() => \r\n    calculateRowPlacement(sortedData),\r\n    [calculateRowPlacement, sortedData]\r\n  )\r\n\r\n  // Мемоизируем общую высоту\r\n  const totalHeight = useMemo(() => \r\n    rowPlacement.reduce((height, row) => {\r\n      return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\r\n    }, 0),\r\n    [rowPlacement]\r\n  )\r\n\r\n  // Функция для создания разделителей категорий\r\n    // Высота строки и отступ вниз для непустой строки\r\n  const ROW_HEIGHT = 60;\r\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\r\n  const EMPTY_ROW_HEIGHT = 20;\r\n\r\n  // Мемоизируем вычисление позиций строк\r\n  const rowTops = useMemo(() => {\r\n    const tops: number[] = [];\r\n    let acc = 0;\r\n    rowPlacement.forEach(row => {\r\n      tops.push(acc);\r\n      if (row.length === 0) {\r\n        acc += EMPTY_ROW_HEIGHT;\r\n      } else {\r\n        acc += ROW_HEIGHT + ROW_MARGIN;\r\n      }\r\n    });\r\n    return tops;\r\n  }, [rowPlacement]);\r\n\r\n  const createCategoryDividers = useCallback(() => {\r\n    if (groupingType === 'none') {\r\n      return []; // Без группировки нет разделителей\r\n    }\r\n\r\n    const dividers: { category: string; top: number }[] = [];\r\n    let currentGroup = '';\r\n\r\n    rowPlacement.forEach((row, rowIndex) => {\r\n      if (row.length > 0) {\r\n        const firstPersonInRow = row[0];\r\n        let currentGroupValue: string;\r\n        \r\n        if (groupingType === 'category') {\r\n          currentGroupValue = firstPersonInRow.category;\r\n        } else if (groupingType === 'country') {\r\n          // Для стран берем первую из списка\r\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\r\n        } else {\r\n          currentGroupValue = firstPersonInRow.category;\r\n        }\r\n        \r\n        if (currentGroupValue !== currentGroup) {\r\n          if (currentGroup !== '') {\r\n            // закрываем предыдущую группу\r\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\r\n          }\r\n          currentGroup = currentGroupValue;\r\n        }\r\n      }\r\n    });\r\n\r\n    // Добавляем разделитель для последней группы\r\n    if (currentGroup !== '') {\r\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\r\n    }\r\n\r\n    return dividers;\r\n  }, [groupingType, rowPlacement, rowTops]);\r\n\r\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\r\n\r\n  return (\r\n    <div className=\"app\" id=\"chrononinja-app\" role=\"main\" aria-label=\"Chrono Ninja - Интерактивная временная линия исторических личностей\">\r\n      <AppHeader\r\n        isScrolled={isScrolled}\r\n        showControls={showControls}\r\n        setShowControls={setShowControls}\r\n        filters={filters}\r\n        setFilters={setFilters}\r\n        groupingType={groupingType}\r\n        setGroupingType={setGroupingType}\r\n        allCategories={allCategories}\r\n        allCountries={allCountries}\r\n        yearInputs={yearInputs}\r\n        setYearInputs={setYearInputs}\r\n        applyYearFilter={applyYearFilter}\r\n        handleYearKeyPress={handleYearKeyPress}\r\n        resetAllFilters={resetAllFilters}\r\n        getCategoryColor={getGroupColor}\r\n        sortedData={sortedData}\r\n        handleSliderMouseDown={handleSliderMouseDown}\r\n        handleSliderMouseMove={handleSliderMouseMove}\r\n        handleSliderMouseUp={handleSliderMouseUp}\r\n        isDraggingSlider={isDraggingSlider}\r\n      />\r\n      \r\n      <div className=\"timeline-wrapper\">\r\n        {/* Загрузка только для области timeline */}\r\n        {isLoading && (\r\n          <div className=\"loading-overlay\" role=\"status\" aria-live=\"polite\">\r\n            <div className=\"spinner\" aria-hidden=\"true\"></div>\r\n            <span>Загрузка данных...</span>\r\n          </div>\r\n        )}\r\n        \r\n        <main \r\n          ref={timelineRef}\r\n          className={`timeline-container ${isDragging ? 'dragging' : ''}`}\r\n          id=\"timeline-viewport\" \r\n          role=\"region\" \r\n          aria-label=\"Область просмотра временной линии\"\r\n          onMouseDown={handleMouseDown}\r\n          onMouseMove={handleMouseMove}\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={handleMouseUp}\r\n          onTouchStart={handleTouchStart}\r\n          onTouchMove={handleTouchMove}\r\n          onTouchEnd={handleTouchEnd}\r\n        >\r\n          <Timeline\r\n          isLoading={false}\r\n          timelineWidth={timelineWidth}\r\n          totalHeight={totalHeight}\r\n          centuryBoundaries={centuryBoundaries}\r\n          minYear={minYear}\r\n          pixelsPerYear={pixelsPerYear}\r\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\r\n          rowPlacement={rowPlacement}\r\n          filters={filters}\r\n          groupingType={groupingType}\r\n          categoryDividers={categoryDividers}\r\n          getGroupColor={getGroupColor}\r\n          getGroupColorDark={getGroupColorDark}\r\n          getGroupColorMuted={getGroupColorMuted}\r\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\r\n          hoveredPerson={hoveredPerson}\r\n          setHoveredPerson={(person) => {\r\n            if (person) {\r\n              // Используем текущую позицию мыши из состояния\r\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\r\n            } else {\r\n              handlePersonHover(null, 0, 0);\r\n            }\r\n          }}\r\n          mousePosition={mousePosition}\r\n          setMousePosition={(position) => {\r\n            // Обновляем позицию мыши\r\n            if (hoveredPerson) {\r\n              handlePersonHover(hoveredPerson, position.x, position.y);\r\n            }\r\n          }}\r\n          showTooltip={showTooltip}\r\n          setShowTooltip={(show) => {\r\n            if (!show && hoveredPerson) {\r\n              handlePersonHover(null, 0, 0);\r\n            }\r\n          }}\r\n          activeAchievementMarker={activeAchievementMarker}\r\n          setActiveAchievementMarker={setActiveAchievementMarker}\r\n          hoveredAchievement={hoveredAchievement}\r\n          setHoveredAchievement={(achievement) => {\r\n            if (achievement) {\r\n              // Используем текущую позицию мыши из состояния\r\n              handleAchievementHover(achievement, achievementTooltipPosition.x, achievementTooltipPosition.y);\r\n            } else {\r\n              handleAchievementHover(null, 0, 0);\r\n            }\r\n          }}\r\n          achievementTooltipPosition={achievementTooltipPosition}\r\n          setAchievementTooltipPosition={(position) => {\r\n            if (hoveredAchievement) {\r\n              handleAchievementHover(hoveredAchievement, position.x, position.y);\r\n            }\r\n          }}\r\n          showAchievementTooltip={showAchievementTooltip}\r\n                  setShowAchievementTooltip={(show) => {\r\n          if (!show && hoveredAchievement) {\r\n            handleAchievementHover(null, 0, 0);\r\n          }\r\n        }}\r\n        handlePersonHover={handlePersonHover}\r\n          hoverTimerRef={hoverTimerRef}\r\n          sortedData={sortedData}\r\n          selectedPerson={selectedPerson}\r\n          setSelectedPerson={setSelectedPerson}\r\n        />\r\n        </main>\r\n      </div>\r\n\r\n      <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\r\n        <Tooltips\r\n          hoveredPerson={hoveredPerson}\r\n          showTooltip={showTooltip}\r\n          mousePosition={mousePosition}\r\n          hoveredAchievement={hoveredAchievement}\r\n          showAchievementTooltip={showAchievementTooltip}\r\n          achievementTooltipPosition={achievementTooltipPosition}\r\n          getGroupColor={getGroupColor}\r\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\r\n          getCategoryColor={getGroupColor}\r\n        />\r\n      </aside>\r\n      \r\n      {/* Мобильная панель с информацией о человеке */}\r\n      <MobilePersonPanel\r\n        selectedPerson={selectedPerson}\r\n        onClose={() => setSelectedPerson(null)}\r\n        getGroupColor={getGroupColor}\r\n        getPersonGroup={(person) => getPersonGroup(person, groupingType)}\r\n        getCategoryColor={getGroupColor}\r\n      />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App "],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,QAAQ,CAAEC,SAAS,CAAEC,OAAO,CAAEC,WAAW,KAAQ,OAAO,CAExE,OAASC,SAAS,KAAQ,wBAAwB,CAClD,OAASC,QAAQ,KAAQ,uBAAuB,CAChD,OAASC,QAAQ,KAAQ,uBAAuB,CAChD,OAASC,iBAAiB,KAAQ,gCAAgC,CAClE,OAASC,eAAe,KAAQ,yBAAyB,CACzD,OAASC,UAAU,KAAQ,oBAAoB,CAC/C,OAASC,SAAS,KAAQ,mBAAmB,CAC7C,OAASC,UAAU,KAAQ,oBAAoB,CAC/C,OAASC,eAAe,KAAQ,yBAAyB,CACzD,OACEC,yBAAyB,CACzBC,eAAe,KACV,uBAAuB,CAC9B,OACEC,aAAa,CACbC,iBAAiB,CACjBC,kBAAkB,CAClBC,cAAc,CACdC,eAAe,KACV,uBAAuB,CAC9B,MAAO,WAAW,QAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,yBAElB,QAAS,CAAAC,GAAGA,CAAA,CAAG,CACb,KAAM,CAACC,UAAU,CAAEC,aAAa,CAAC,CAAG1B,QAAQ,CAAC,KAAK,CAAC,CACnD,KAAM,CAAC2B,uBAAuB,CAAEC,0BAA0B,CAAC,CAAG5B,QAAQ,CAA6C,IAAI,CAAC,CACxH,KAAM,CAAC6B,cAAc,CAAEC,iBAAiB,CAAC,CAAG9B,QAAQ,CAAgB,IAAI,CAAC,CACzE,KAAM,CAAC+B,YAAY,CAAEC,eAAe,CAAC,CAAGhC,QAAQ,CAAC,IAAI,CAAC,CAEtD;AACA,KAAM,CACJiC,OAAO,CACPC,UAAU,CACVC,YAAY,CACZC,eAAe,CACfC,UAAU,CACVC,aAAa,CACbC,eAAe,CACfC,kBAAkB,CAClBC,eACF,CAAC,CAAGhC,UAAU,CAAC,CAAC,CAEhB,KAAM,CAAEiC,OAAO,CAAEC,aAAa,CAAEC,YAAY,CAAEC,SAAU,CAAC,CAAGrC,eAAe,CAACyB,OAAO,CAAC,CAEpF,KAAM,CACJa,gBAAgB,CAChBC,qBAAqB,CACrBC,qBAAqB,CACrBC,mBACF,CAAC,CAAGvC,SAAS,CAAC,CAAC,CAEf,KAAM,CACJwC,aAAa,CACbC,aAAa,CACbC,WAAW,CACXC,kBAAkB,CAClBC,0BAA0B,CAC1BC,sBAAsB,CACtBC,aAAa,CACbC,iBAAiB,CACjBC,sBACF,CAAC,CAAG/C,UAAU,CAAC,CAAC,CAQhB;AACAV,SAAS,CAAC,IAAM,CACd,GAAI6C,gBAAgB,CAAE,CACpB,KAAM,CAAAa,eAAe,CAAIC,CAA0B,EACjDZ,qBAAqB,CAACY,CAAC,CAAEvB,UAAU,CAAEE,eAAe,CAAED,aAAa,CAAC,CAEtE,KAAM,CAAAuB,aAAa,CAAGA,CAAA,GAAMZ,mBAAmB,CAAC,CAAC,CAEjDa,QAAQ,CAACC,gBAAgB,CAAC,WAAW,CAAEJ,eAAe,CAAC,CACvDG,QAAQ,CAACC,gBAAgB,CAAC,SAAS,CAAEF,aAAa,CAAC,CACnDC,QAAQ,CAACC,gBAAgB,CAAC,WAAW,CAAEJ,eAAe,CAAC,CACvDG,QAAQ,CAACC,gBAAgB,CAAC,UAAU,CAAEF,aAAa,CAAC,CAEpD,MAAO,IAAM,CACXC,QAAQ,CAACE,mBAAmB,CAAC,WAAW,CAAEL,eAAe,CAAC,CAC1DG,QAAQ,CAACE,mBAAmB,CAAC,SAAS,CAAEH,aAAa,CAAC,CACtDC,QAAQ,CAACE,mBAAmB,CAAC,WAAW,CAAEL,eAAe,CAAC,CAC1DG,QAAQ,CAACE,mBAAmB,CAAC,UAAU,CAAEH,aAAa,CAAC,CACzD,CAAC,CACH,CACF,CAAC,CAAE,CAACf,gBAAgB,CAAEE,qBAAqB,CAAEC,mBAAmB,CAAEZ,UAAU,CAAEE,eAAe,CAAED,aAAa,CAAEJ,UAAU,CAAC,CAAC,CAI1H;AACA,KAAM,CAAA+B,UAAU,CAAG9C,eAAe,CAACuB,OAAO,CAAEP,YAAY,CAAC,CAEzD;AACAlC,SAAS,CAAC,IAAM,CACd,GAAIgC,OAAO,CAACiC,kBAAkB,EAAID,UAAU,CAACE,MAAM,CAAG,CAAC,CAAE,CACvD;AACA,KAAM,CAAAC,gBAAgB,CAAGC,IAAI,CAACC,GAAG,CAAC,GAAGL,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACC,SAAS,CAAC,CAAC,CACtE,KAAM,CAAAC,gBAAgB,CAAGL,IAAI,CAACM,GAAG,CAAC,GAAGV,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACI,SAAS,CAAC,CAAC,CAEtE;AACA,KAAM,CAAAC,gBAAgB,CAAG5C,OAAO,CAAC6C,UAAU,CAACX,MAAM,CAAG,CAAC,EAAIlC,OAAO,CAAC8C,SAAS,CAACZ,MAAM,CAAG,CAAC,CAEtF,GAAI,CAAAa,YAAY,CAAG,CAAE,GAAG/C,OAAO,CAACgD,SAAU,CAAC,CAE3C,GAAIJ,gBAAgB,CAAE,CACpB;AACAG,YAAY,CAAG,CACbE,KAAK,CAAEb,IAAI,CAACM,GAAG,CAAC1C,OAAO,CAACgD,SAAS,CAACC,KAAK,CAAEd,gBAAgB,CAAC,CAC1De,GAAG,CAAEd,IAAI,CAACC,GAAG,CAACrC,OAAO,CAACgD,SAAS,CAACE,GAAG,CAAET,gBAAgB,CACvD,CAAC,CACH,CAAC,IAAM,CACL;AACA;AACAM,YAAY,CAAG/C,OAAO,CAACgD,SAAS,CAClC,CAEA;AACA,GAAID,YAAY,CAACE,KAAK,GAAKjD,OAAO,CAACgD,SAAS,CAACC,KAAK,EAAIF,YAAY,CAACG,GAAG,GAAKlD,OAAO,CAACgD,SAAS,CAACE,GAAG,CAAE,CAChGjD,UAAU,CAACkD,IAAI,GAAK,CAClB,GAAGA,IAAI,CACPH,SAAS,CAAED,YACb,CAAC,CAAC,CAAC,CAEH;AACA1C,aAAa,CAAC,CACZ4C,KAAK,CAAEF,YAAY,CAACE,KAAK,CAACG,QAAQ,CAAC,CAAC,CACpCF,GAAG,CAAEH,YAAY,CAACG,GAAG,CAACE,QAAQ,CAAC,CACjC,CAAC,CAAC,CACJ,CACF,CACF,CAAC,CAAE,CAACpD,OAAO,CAACiC,kBAAkB,CAAED,UAAU,CAAEhC,OAAO,CAAC6C,UAAU,CAAE7C,OAAO,CAAC8C,SAAS,CAAE9C,OAAO,CAACgD,SAAS,CAAE/C,UAAU,CAAEI,aAAa,CAAC,CAAC,CAEjI;AACArC,SAAS,CAAC,IAAM,CACd,KAAM,CAAAqF,YAAY,CAAGA,CAAA,GAAM,CACzB,KAAM,CAAAC,SAAS,CAAGC,MAAM,CAACC,WAAW,EAAI3B,QAAQ,CAAC4B,eAAe,CAACH,SAAS,CAC1E7D,aAAa,CAAC6D,SAAS,CAAG,EAAE,CAAC,CAC/B,CAAC,CAEDC,MAAM,CAACzB,gBAAgB,CAAC,QAAQ,CAAEuB,YAAY,CAAC,CAC/C,MAAO,IAAME,MAAM,CAACxB,mBAAmB,CAAC,QAAQ,CAAEsB,YAAY,CAAC,CACjE,CAAC,CAAE,EAAE,CAAC,CAEN;AACArF,SAAS,CAAC,IAAM,CACd,KAAM,CAAA0F,6BAA6B,CAAGA,CAAA,GAAM,CAC1CjC,sBAAsB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CACpC,CAAC,CAED,KAAM,CAAAkC,kBAAkB,CAAIC,KAAY,EAAK,CAC3C;AACA,KAAM,CAAAC,MAAM,CAAGD,KAAK,CAACC,MAAiB,CACtC,KAAM,CAAAC,OAAO,CAAGjC,QAAQ,CAACkC,cAAc,CAAC,qBAAqB,CAAC,CAC9D,KAAM,CAAAC,oBAAoB,CAAGF,OAAO,SAAPA,OAAO,iBAAPA,OAAO,CAAEG,QAAQ,CAACJ,MAAM,CAAC,CACtD,KAAM,CAAAK,eAAe,CAAGL,MAAM,CAACM,OAAO,CAAC,qBAAqB,CAAC,CAE7D;AACA,GAAI,CAACH,oBAAoB,EAAI,CAACE,eAAe,EAAI5C,sBAAsB,CAAE,CACvE,GAAIsC,KAAK,CAACQ,IAAI,GAAK,YAAY,CAAE,CAC/BC,UAAU,CAAC,IAAM,CACf5C,sBAAsB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CACpC,CAAC,CAAE,GAAG,CAAC,CACT,CAAC,IAAM,CACLA,sBAAsB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CACpC,CACF,CACF,CAAC,CAED8B,MAAM,CAACzB,gBAAgB,CAAC,yBAAyB,CAAE4B,6BAA6B,CAAC,CACjF7B,QAAQ,CAACC,gBAAgB,CAAC,WAAW,CAAE6B,kBAAkB,CAAC,CAC1D9B,QAAQ,CAACC,gBAAgB,CAAC,YAAY,CAAE6B,kBAAkB,CAAC,CAE3D,MAAO,IAAM,CACXJ,MAAM,CAACxB,mBAAmB,CAAC,yBAAyB,CAAE2B,6BAA6B,CAAC,CACpF7B,QAAQ,CAACE,mBAAmB,CAAC,WAAW,CAAE4B,kBAAkB,CAAC,CAC7D9B,QAAQ,CAACE,mBAAmB,CAAC,YAAY,CAAE4B,kBAAkB,CAAC,CAChE,CAAC,CACH,CAAC,CAAE,CAAClC,sBAAsB,CAAEH,sBAAsB,CAAC,CAAC,CAEpD;AACA,KAAM,CAAEgD,OAAO,CAAEC,UAAU,CAAEpC,gBAAgB,CAAEM,gBAAiB,CAAC,CAAGxE,OAAO,CAAC,IAAM,CAChF,KAAM,CAAAqG,OAAO,CAAGlC,IAAI,CAACC,GAAG,CAAC,GAAGL,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACC,SAAS,CAAC,CAAExC,OAAO,CAACgD,SAAS,CAACC,KAAK,CAAC,CACtF,KAAM,CAAAuB,OAAO,CAAGpC,IAAI,CAACM,GAAG,CAAC,GAAGV,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACI,SAAS,CAAC,CAAE3C,OAAO,CAACgD,SAAS,CAACE,GAAG,CAAC,CACpF,KAAM,CAAAqB,UAAU,CAAGC,OAAO,CAAGF,OAAO,CAEpC,KAAM,CAAAnC,gBAAgB,CAAGnC,OAAO,CAACiC,kBAAkB,CAC/CG,IAAI,CAACC,GAAG,CAAC,GAAGL,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACC,SAAS,CAAC,CAAC,CAC7C8B,OAAO,CACX,KAAM,CAAA7B,gBAAgB,CAAGzC,OAAO,CAACiC,kBAAkB,CAC/CG,IAAI,CAACM,GAAG,CAAC,GAAGV,UAAU,CAACM,GAAG,CAACC,CAAC,EAAIA,CAAC,CAACI,SAAS,CAAC,CAAC,CAC7C6B,OAAO,CAEX,MAAO,CAAEF,OAAO,CAAEC,UAAU,CAAEpC,gBAAgB,CAAEM,gBAAiB,CAAC,CACpE,CAAC,CAAE,CAACT,UAAU,CAAEhC,OAAO,CAACgD,SAAS,CAACC,KAAK,CAAEjD,OAAO,CAACgD,SAAS,CAACE,GAAG,CAAElD,OAAO,CAACiC,kBAAkB,CAAC,CAAC,CAE5F;AACA,KAAM,CAAAwC,aAAa,CAAG,CAAC,CAAC;AACxB,KAAM,CAAAC,eAAe,CAAG,EAAE,CAAC;AAC3B,KAAM,CAAAC,aAAa,CAAGJ,UAAU,CAAGE,aAAa,CAAGC,eAAe,CAElE;AACA,KAAM,CACJE,WAAW,CACXC,UAAU,CACVC,kBAAkB,CAClBC,eAAe,CACfrD,eAAe,CACfE,aAAa,CACboD,gBAAgB,CAChBC,eAAe,CACfC,cACF,CAAC,CAAGvG,eAAe,CAAC,CAClBgG,aAAa,CACbQ,cAAc,CAAE5B,MAAM,CAAC6B,UACzB,CAAC,CAAC,CAEF;AACA,KAAM,CAAAC,iBAAiB,CAAGpH,OAAO,CAAC,IAChCW,yBAAyB,CAACuD,gBAAgB,CAAEM,gBAAgB,CAAC,CAC7D,CAACN,gBAAgB,CAAEM,gBAAgB,CACrC,CAAC,CAED;AACA,KAAM,CAAA6C,qBAAqB,CAAGpH,WAAW,CAAEqH,MAAgB,EAAK,CAC9D,KAAM,CAAAC,IAAgB,CAAG,EAAE,CAE3B,GAAItF,YAAY,GAAK,MAAM,CAAE,CAC3B;AACA,KAAM,CAAAuF,OAAmB,CAAG,EAAE,CAE9BF,MAAM,CAACG,OAAO,CAACC,MAAM,EAAI,CACvB,GAAI,CAAAC,MAAM,CAAG,KAAK,CAElB;AACA,IAAK,GAAI,CAAAC,QAAQ,CAAG,CAAC,CAAEA,QAAQ,CAAGJ,OAAO,CAACvD,MAAM,CAAE2D,QAAQ,EAAE,CAAE,CAC5D,KAAM,CAAAC,GAAG,CAAGL,OAAO,CAACI,QAAQ,CAAC,CAC7B,GAAI,CAAAE,aAAa,CAAG,IAAI,CAExB;AACA,IAAK,KAAM,CAAAC,cAAc,GAAI,CAAAF,GAAG,CAAE,CAChC,KAAM,CAAAG,MAAM,CAAG,EAAE,CAAE;AACnB,GACEN,MAAM,CAACnD,SAAS,CAAGyD,MAAM,EAAID,cAAc,CAACrD,SAAS,EACrDgD,MAAM,CAAChD,SAAS,CAAGsD,MAAM,EAAID,cAAc,CAACxD,SAAS,CACrD,CACAuD,aAAa,CAAG,KAAK,CACrB,MACF,CACF,CAEA;AACA,GAAIA,aAAa,CAAE,CACjBN,OAAO,CAACI,QAAQ,CAAC,CAACK,IAAI,CAACP,MAAM,CAAC,CAC9BC,MAAM,CAAG,IAAI,CACb,MACF,CACF,CAEA;AACA,GAAI,CAACA,MAAM,CAAE,CACXH,OAAO,CAACS,IAAI,CAAC,CAACP,MAAM,CAAC,CAAC,CACxB,CACF,CAAC,CAAC,CAEF,MAAO,CAAAF,OAAO,CAChB,CAEA;AACA,KAAM,CAAAU,UAAU,CAAGjG,YAAY,GAAK,UAAU,CAAG,UAAU,CAAG,SAAS,CACvE,KAAM,CAAAkG,SAAS,CAAGlG,YAAY,GAAK,UAAU,CAAGQ,aAAa,CAAGC,YAAY,CAC5E,KAAM,CAAA0F,MAAmC,CAAG,CAAC,CAAC,CAE9C;AACAd,MAAM,CAACG,OAAO,CAACC,MAAM,EAAI,CACvB,GAAI,CAAAW,UAAkB,CACtB,GAAIH,UAAU,GAAK,SAAS,CAAE,CAC5B;AACAG,UAAU,CAAGzH,eAAe,CAAC8G,MAAM,CAACY,OAAO,CAAC,CAC9C,CAAC,IAAM,CACLD,UAAU,CAAGX,MAAM,CAACQ,UAAU,CAAC,CACjC,CAEA,GAAI,CAACE,MAAM,CAACC,UAAU,CAAC,CAAE,CACvBD,MAAM,CAACC,UAAU,CAAC,CAAG,EAAE,CACzB,CACAD,MAAM,CAACC,UAAU,CAAC,CAACJ,IAAI,CAACP,MAAM,CAAC,CACjC,CAAC,CAAC,CAEF;AACAS,SAAS,CAACV,OAAO,CAACY,UAAU,EAAI,CAC9B,GAAID,MAAM,CAACC,UAAU,CAAC,CAAE,CACtB,KAAM,CAAAE,WAAW,CAAGH,MAAM,CAACC,UAAU,CAAC,CACtC,KAAM,CAAAG,SAAqB,CAAG,EAAE,CAEhC;AACAD,WAAW,CAACd,OAAO,CAACC,MAAM,EAAI,CAC5B,GAAI,CAAAC,MAAM,CAAG,KAAK,CAElB;AACA,IAAK,GAAI,CAAAC,QAAQ,CAAG,CAAC,CAAEA,QAAQ,CAAGY,SAAS,CAACvE,MAAM,CAAE2D,QAAQ,EAAE,CAAE,CAC9D,KAAM,CAAAC,GAAG,CAAGW,SAAS,CAACZ,QAAQ,CAAC,CAC/B,GAAI,CAAAE,aAAa,CAAG,IAAI,CAExB;AACA,IAAK,KAAM,CAAAC,cAAc,GAAI,CAAAF,GAAG,CAAE,CAChC,KAAM,CAAAG,MAAM,CAAG,EAAE,CAAE;AACnB,GACEN,MAAM,CAACnD,SAAS,CAAGyD,MAAM,EAAID,cAAc,CAACrD,SAAS,EACrDgD,MAAM,CAAChD,SAAS,CAAGsD,MAAM,EAAID,cAAc,CAACxD,SAAS,CACrD,CACAuD,aAAa,CAAG,KAAK,CACrB,MACF,CACF,CAEA;AACA,GAAIA,aAAa,CAAE,CACjBU,SAAS,CAACZ,QAAQ,CAAC,CAACK,IAAI,CAACP,MAAM,CAAC,CAChCC,MAAM,CAAG,IAAI,CACb,MACF,CACF,CAEA;AACA,GAAI,CAACA,MAAM,CAAE,CACXa,SAAS,CAACP,IAAI,CAAC,CAACP,MAAM,CAAC,CAAC,CAC1B,CACF,CAAC,CAAC,CAEF;AACAH,IAAI,CAACU,IAAI,CAAC,GAAGO,SAAS,CAAC,CAEvB;AACA,GAAIH,UAAU,GAAKF,SAAS,CAACA,SAAS,CAAClE,MAAM,CAAG,CAAC,CAAC,CAAE,CAClDsD,IAAI,CAACU,IAAI,CAAC,EAAE,CAAC,CACf,CACF,CACF,CAAC,CAAC,CAEF,MAAO,CAAAV,IAAI,CACb,CAAC,CAAE,CAACtF,YAAY,CAAEQ,aAAa,CAAEC,YAAY,CAAC,CAAC,CAE/C;AACA,KAAM,CAAA+F,YAAY,CAAGzI,OAAO,CAAC,IAC3BqH,qBAAqB,CAACtD,UAAU,CAAC,CACjC,CAACsD,qBAAqB,CAAEtD,UAAU,CACpC,CAAC,CAED;AACA,KAAM,CAAA2E,WAAW,CAAG1I,OAAO,CAAC,IAC1ByI,YAAY,CAACE,MAAM,CAAC,CAACC,MAAM,CAAEf,GAAG,GAAK,CACnC,MAAO,CAAAe,MAAM,EAAIf,GAAG,CAAC5D,MAAM,GAAK,CAAC,CAAG,EAAE,CAAG,EAAE,CAAC,CAAC;AAC/C,CAAC,CAAE,CAAC,CAAC,CACL,CAACwE,YAAY,CACf,CAAC,CAED;AACE;AACF,KAAM,CAAAI,UAAU,CAAG,EAAE,CACrB,KAAM,CAAAC,UAAU,CAAG,EAAE,CAAE;AACvB,KAAM,CAAAC,gBAAgB,CAAG,EAAE,CAE3B;AACA,KAAM,CAAAC,OAAO,CAAGhJ,OAAO,CAAC,IAAM,CAC5B,KAAM,CAAAiJ,IAAc,CAAG,EAAE,CACzB,GAAI,CAAAC,GAAG,CAAG,CAAC,CACXT,YAAY,CAAChB,OAAO,CAACI,GAAG,EAAI,CAC1BoB,IAAI,CAAChB,IAAI,CAACiB,GAAG,CAAC,CACd,GAAIrB,GAAG,CAAC5D,MAAM,GAAK,CAAC,CAAE,CACpBiF,GAAG,EAAIH,gBAAgB,CACzB,CAAC,IAAM,CACLG,GAAG,EAAIL,UAAU,CAAGC,UAAU,CAChC,CACF,CAAC,CAAC,CACF,MAAO,CAAAG,IAAI,CACb,CAAC,CAAE,CAACR,YAAY,CAAC,CAAC,CAElB,KAAM,CAAAU,sBAAsB,CAAGlJ,WAAW,CAAC,IAAM,CAC/C,GAAIgC,YAAY,GAAK,MAAM,CAAE,CAC3B,MAAO,EAAE,CAAE;AACb,CAEA,KAAM,CAAAmH,QAA6C,CAAG,EAAE,CACxD,GAAI,CAAAC,YAAY,CAAG,EAAE,CAErBZ,YAAY,CAAChB,OAAO,CAAC,CAACI,GAAG,CAAED,QAAQ,GAAK,CACtC,GAAIC,GAAG,CAAC5D,MAAM,CAAG,CAAC,CAAE,CAClB,KAAM,CAAAqF,gBAAgB,CAAGzB,GAAG,CAAC,CAAC,CAAC,CAC/B,GAAI,CAAA0B,iBAAyB,CAE7B,GAAItH,YAAY,GAAK,UAAU,CAAE,CAC/BsH,iBAAiB,CAAGD,gBAAgB,CAACE,QAAQ,CAC/C,CAAC,IAAM,IAAIvH,YAAY,GAAK,SAAS,CAAE,CACrC;AACAsH,iBAAiB,CAAG3I,eAAe,CAAC0I,gBAAgB,CAAChB,OAAO,CAAC,CAC/D,CAAC,IAAM,CACLiB,iBAAiB,CAAGD,gBAAgB,CAACE,QAAQ,CAC/C,CAEA,GAAID,iBAAiB,GAAKF,YAAY,CAAE,CACtC,GAAIA,YAAY,GAAK,EAAE,CAAE,CACvB;AACAD,QAAQ,CAACnB,IAAI,CAAC,CAAEuB,QAAQ,CAAEH,YAAY,CAAEI,GAAG,CAAET,OAAO,CAACpB,QAAQ,CAAC,CAAG,CAAE,CAAC,CAAC,CACvE,CACAyB,YAAY,CAAGE,iBAAiB,CAClC,CACF,CACF,CAAC,CAAC,CAEF;AACA,GAAIF,YAAY,GAAK,EAAE,CAAE,CACvBD,QAAQ,CAACnB,IAAI,CAAC,CAAEuB,QAAQ,CAAEH,YAAY,CAAEI,GAAG,CAAET,OAAO,CAACP,YAAY,CAACxE,MAAM,CAAG,CAAC,CAAC,CAAG,CAAE,CAAC,CAAC,CACtF,CAEA,MAAO,CAAAmF,QAAQ,CACjB,CAAC,CAAE,CAACnH,YAAY,CAAEwG,YAAY,CAAEO,OAAO,CAAC,CAAC,CAEzC,KAAM,CAAAU,gBAAgB,CAAG1J,OAAO,CAAC,IAAMmJ,sBAAsB,CAAC,CAAC,CAAE,CAACA,sBAAsB,CAAC,CAAC,CAE1F,mBACE9H,KAAA,QAAKsI,SAAS,CAAC,KAAK,CAACC,EAAE,CAAC,iBAAiB,CAACC,IAAI,CAAC,MAAM,CAAC,aAAW,qTAAqE,CAAAC,QAAA,eACpI3I,IAAA,CAACjB,SAAS,EACRqB,UAAU,CAAEA,UAAW,CACvBM,YAAY,CAAEA,YAAa,CAC3BC,eAAe,CAAEA,eAAgB,CACjCC,OAAO,CAAEA,OAAQ,CACjBC,UAAU,CAAEA,UAAW,CACvBC,YAAY,CAAEA,YAAa,CAC3BC,eAAe,CAAEA,eAAgB,CACjCO,aAAa,CAAEA,aAAc,CAC7BC,YAAY,CAAEA,YAAa,CAC3BP,UAAU,CAAEA,UAAW,CACvBC,aAAa,CAAEA,aAAc,CAC7BC,eAAe,CAAEA,eAAgB,CACjCC,kBAAkB,CAAEA,kBAAmB,CACvCC,eAAe,CAAEA,eAAgB,CACjCwH,gBAAgB,CAAElJ,aAAc,CAChCkD,UAAU,CAAEA,UAAW,CACvBlB,qBAAqB,CAAEA,qBAAsB,CAC7CC,qBAAqB,CAAEA,qBAAsB,CAC7CC,mBAAmB,CAAEA,mBAAoB,CACzCH,gBAAgB,CAAEA,gBAAiB,CACpC,CAAC,cAEFvB,KAAA,QAAKsI,SAAS,CAAC,kBAAkB,CAAAG,QAAA,EAE9BnH,SAAS,eACRtB,KAAA,QAAKsI,SAAS,CAAC,iBAAiB,CAACE,IAAI,CAAC,QAAQ,CAAC,YAAU,QAAQ,CAAAC,QAAA,eAC/D3I,IAAA,QAAKwI,SAAS,CAAC,SAAS,CAAC,cAAY,MAAM,CAAM,CAAC,cAClDxI,IAAA,SAAA2I,QAAA,CAAM,0FAAkB,CAAM,CAAC,EAC5B,CACN,cAED3I,IAAA,SACE6I,GAAG,CAAErD,WAAY,CACjBgD,SAAS,CAAE,sBAAsB/C,UAAU,CAAG,UAAU,CAAG,EAAE,EAAG,CAChEgD,EAAE,CAAC,mBAAmB,CACtBC,IAAI,CAAC,QAAQ,CACb,aAAW,yLAAmC,CAC9CI,WAAW,CAAEnD,eAAgB,CAC7BoD,WAAW,CAAEzG,eAAgB,CAC7B0G,SAAS,CAAExG,aAAc,CACzByG,YAAY,CAAEzG,aAAc,CAC5B0G,YAAY,CAAEtD,gBAAiB,CAC/BuD,WAAW,CAAEtD,eAAgB,CAC7BuD,UAAU,CAAEtD,cAAe,CAAA6C,QAAA,cAE3B3I,IAAA,CAAChB,QAAQ,EACTwC,SAAS,CAAE,KAAM,CACjB+D,aAAa,CAAEA,aAAc,CAC7BgC,WAAW,CAAEA,WAAY,CACzBtB,iBAAiB,CAAEA,iBAAkB,CACrCf,OAAO,CAAEA,OAAQ,CACjBG,aAAa,CAAEA,aAAc,CAC7BC,eAAe,CAAEA,eAAgB,CACjCgC,YAAY,CAAEA,YAAa,CAC3B1G,OAAO,CAAEA,OAAQ,CACjBE,YAAY,CAAEA,YAAa,CAC3ByH,gBAAgB,CAAEA,gBAAiB,CACnC7I,aAAa,CAAEA,aAAc,CAC7BC,iBAAiB,CAAEA,iBAAkB,CACrCC,kBAAkB,CAAEA,kBAAmB,CACvCC,cAAc,CAAG0G,MAAM,EAAK1G,cAAc,CAAC0G,MAAM,CAAEzF,YAAY,CAAE,CACjEe,aAAa,CAAEA,aAAc,CAC7BwH,gBAAgB,CAAG9C,MAAM,EAAK,CAC5B,GAAIA,MAAM,CAAE,CACV;AACAnE,iBAAiB,CAACmE,MAAM,CAAEzE,aAAa,CAACwH,CAAC,CAAExH,aAAa,CAACyH,CAAC,CAAC,CAC7D,CAAC,IAAM,CACLnH,iBAAiB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CAC/B,CACF,CAAE,CACFN,aAAa,CAAEA,aAAc,CAC7B0H,gBAAgB,CAAGC,QAAQ,EAAK,CAC9B;AACA,GAAI5H,aAAa,CAAE,CACjBO,iBAAiB,CAACP,aAAa,CAAE4H,QAAQ,CAACH,CAAC,CAAEG,QAAQ,CAACF,CAAC,CAAC,CAC1D,CACF,CAAE,CACFxH,WAAW,CAAEA,WAAY,CACzB2H,cAAc,CAAGC,IAAI,EAAK,CACxB,GAAI,CAACA,IAAI,EAAI9H,aAAa,CAAE,CAC1BO,iBAAiB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CAC/B,CACF,CAAE,CACF9B,uBAAuB,CAAEA,uBAAwB,CACjDC,0BAA0B,CAAEA,0BAA2B,CACvDyB,kBAAkB,CAAEA,kBAAmB,CACvC4H,qBAAqB,CAAGC,WAAW,EAAK,CACtC,GAAIA,WAAW,CAAE,CACf;AACAxH,sBAAsB,CAACwH,WAAW,CAAE5H,0BAA0B,CAACqH,CAAC,CAAErH,0BAA0B,CAACsH,CAAC,CAAC,CACjG,CAAC,IAAM,CACLlH,sBAAsB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CACpC,CACF,CAAE,CACFJ,0BAA0B,CAAEA,0BAA2B,CACvD6H,6BAA6B,CAAGL,QAAQ,EAAK,CAC3C,GAAIzH,kBAAkB,CAAE,CACtBK,sBAAsB,CAACL,kBAAkB,CAAEyH,QAAQ,CAACH,CAAC,CAAEG,QAAQ,CAACF,CAAC,CAAC,CACpE,CACF,CAAE,CACFrH,sBAAsB,CAAEA,sBAAuB,CACvC6H,yBAAyB,CAAGJ,IAAI,EAAK,CAC7C,GAAI,CAACA,IAAI,EAAI3H,kBAAkB,CAAE,CAC/BK,sBAAsB,CAAC,IAAI,CAAE,CAAC,CAAE,CAAC,CAAC,CACpC,CACF,CAAE,CACFD,iBAAiB,CAAEA,iBAAkB,CACnCD,aAAa,CAAEA,aAAc,CAC7BS,UAAU,CAAEA,UAAW,CACvBpC,cAAc,CAAEA,cAAe,CAC/BC,iBAAiB,CAAEA,iBAAkB,CACtC,CAAC,CACI,CAAC,EACJ,CAAC,cAENT,IAAA,UAAOwI,SAAS,CAAC,oBAAoB,CAACC,EAAE,CAAC,gBAAgB,CAAC,aAAW,6IAA0B,CAAAE,QAAA,cAC7F3I,IAAA,CAACf,QAAQ,EACP4C,aAAa,CAAEA,aAAc,CAC7BE,WAAW,CAAEA,WAAY,CACzBD,aAAa,CAAEA,aAAc,CAC7BE,kBAAkB,CAAEA,kBAAmB,CACvCE,sBAAsB,CAAEA,sBAAuB,CAC/CD,0BAA0B,CAAEA,0BAA2B,CACvDvC,aAAa,CAAEA,aAAc,CAC7BG,cAAc,CAAG0G,MAAM,EAAK1G,cAAc,CAAC0G,MAAM,CAAEzF,YAAY,CAAE,CACjE8H,gBAAgB,CAAElJ,aAAc,CACjC,CAAC,CACG,CAAC,cAGRM,IAAA,CAACd,iBAAiB,EAChBsB,cAAc,CAAEA,cAAe,CAC/BwJ,OAAO,CAAEA,CAAA,GAAMvJ,iBAAiB,CAAC,IAAI,CAAE,CACvCf,aAAa,CAAEA,aAAc,CAC7BG,cAAc,CAAG0G,MAAM,EAAK1G,cAAc,CAAC0G,MAAM,CAAEzF,YAAY,CAAE,CACjE8H,gBAAgB,CAAElJ,aAAc,CACjC,CAAC,EACC,CAAC,CAEV,CAEA,cAAe,CAAAS,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}