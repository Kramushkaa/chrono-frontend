{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Selecty\\\\Documents\\\\PetProjects\\\\chronoline-frontend\\\\src\\\\App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors';\nimport { AppHeader } from './components/AppHeader';\nimport { Timeline } from './components/Timeline';\nimport { Tooltips } from './components/Tooltips';\nimport { useTimelineData } from './hooks/useTimelineData';\nimport { generateCenturyBoundaries, getFirstCountry } from './utils/timelineUtils';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [hoveredPerson, setHoveredPerson] = useState(null);\n  const [mousePosition, setMousePosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [hoveredAchievement, setHoveredAchievement] = useState(null);\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false);\n  const [isScrolled, setIsScrolled] = useState(false);\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState(null);\n  const hoverTimerRef = useRef(null);\n  const [showControls, setShowControls] = useState(true);\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || {\n          start: -800,\n          end: 2000\n        },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true,\n        hideEmptyCenturies: parsed.hideEmptyCenturies !== undefined ? parsed.hideEmptyCenturies : false\n      };\n    }\n    return {\n      categories: [],\n      countries: [],\n      timeRange: {\n        start: -800,\n        end: 2000\n      },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    };\n  });\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping || 'category';\n  });\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      if (hoverTimerRef.current) {\n        clearTimeout(hoverTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const {\n    persons,\n    allCategories,\n    allCountries,\n    isLoading\n  } = useTimelineData(filters);\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  });\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = (field, value) => {\n    const parsed = parseInt(value);\n    const numValue = isNaN(parsed) ? field === 'start' ? -800 : 2000 : parsed;\n    setFilters(prev => ({\n      ...prev,\n      timeRange: {\n        ...prev.timeRange,\n        [field]: numValue\n      }\n    }));\n  };\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field, e) => {\n    if (e.key === 'Enter') {\n      var _e$currentTarget$pare, _e$currentTarget$pare2;\n      applyYearFilter(field, e.currentTarget.value);\n      // Переводим фокус на следующий элемент\n      const inputs = (_e$currentTarget$pare = e.currentTarget.parentElement) === null || _e$currentTarget$pare === void 0 ? void 0 : (_e$currentTarget$pare2 = _e$currentTarget$pare.parentElement) === null || _e$currentTarget$pare2 === void 0 ? void 0 : _e$currentTarget$pare2.querySelectorAll('input');\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget);\n        const nextInput = inputs[currentIndex + 1];\n        if (nextInput) {\n          nextInput.focus();\n        }\n      }\n    }\n  };\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: {\n        start: -800,\n        end: 2000\n      },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    });\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    });\n  };\n\n  // Функция для получения приоритета категории\n  const getCategoryPriority = category => {\n    return allCategories.indexOf(category);\n  };\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad', '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'];\n      const index = allCountries.indexOf(groupName);\n      return countryColors[index % countryColors.length];\n    }\n    return '#95a5a6'; // серый цвет по умолчанию\n  };\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = ['#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad', '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98', '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'];\n      const index = allCountries.indexOf(groupName);\n      return countryColorsDark[index % countryColorsDark.length];\n    }\n    return '#7f8c8d'; // темно-серый цвет по умолчанию\n  };\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad', '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'];\n      const index = allCountries.indexOf(groupName);\n      return countryColorsMuted[index % countryColorsMuted.length];\n    }\n    return '#95a5a6'; // серый цвет по умолчанию\n  };\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = person => {\n    if (groupingType === 'category') {\n      return person.category;\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country);\n    }\n    return person.category; // по умолчанию\n  };\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category);\n      if (categoryDiff !== 0) {\n        return categoryDiff;\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country));\n      if (countryDiff !== 0) {\n        return countryDiff;\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear;\n  });\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      setIsScrolled(scrollTop > 50);\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start);\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end);\n  const totalYears = maxYear - minYear;\n\n  // Настройки масштаба\n  const pixelsPerYear = 3; // 3 пикселя на год\n  const LEFT_PADDING_PX = 30; // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX;\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies ? Math.min(...sortedData.map(p => p.birthYear)) : minYear;\n  const effectiveMaxYear = filters.hideEmptyCenturies ? Math.max(...sortedData.map(p => p.deathYear)) : maxYear;\n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear);\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = people => {\n    const rows = [];\n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows = [];\n      people.forEach(person => {\n        let placed = false;\n\n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex];\n          let canPlaceInRow = true;\n\n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n              canPlaceInRow = false;\n              break;\n            }\n          }\n\n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person);\n            placed = true;\n            break;\n          }\n        }\n\n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person]);\n        }\n      });\n      return allRows;\n    }\n\n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country';\n    const allGroups = groupingType === 'category' ? allCategories : allCountries;\n    const groups = {};\n\n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue;\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country);\n      } else {\n        groupValue = person[groupField];\n      }\n      if (!groups[groupValue]) {\n        groups[groupValue] = [];\n      }\n      groups[groupValue].push(person);\n    });\n\n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue];\n        const groupRows = [];\n\n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false;\n\n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex];\n            let canPlaceInRow = true;\n\n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n                canPlaceInRow = false;\n                break;\n              }\n            }\n\n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person);\n              placed = true;\n              break;\n            }\n          }\n\n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person]);\n          }\n        });\n\n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows);\n\n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([]);\n        }\n      }\n    });\n    return rows;\n  };\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData);\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70); // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0);\n\n  // Функция для создания разделителей категорий\n  // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n    const dividers = [];\n    let currentGroup = '';\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue;\n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({\n              category: currentGroup,\n              top: rowTops[rowIndex] - 5\n            });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({\n        category: currentGroup,\n        top: rowTops[rowPlacement.length - 1] - 5\n      });\n    }\n    return dividers;\n  };\n  const categoryDividers = createCategoryDividers();\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(AppHeader, {\n      isScrolled: isScrolled,\n      showControls: showControls,\n      setShowControls: setShowControls,\n      filters: filters,\n      setFilters: setFilters,\n      groupingType: groupingType,\n      setGroupingType: setGroupingType,\n      allCategories: allCategories,\n      allCountries: allCountries,\n      yearInputs: yearInputs,\n      setYearInputs: setYearInputs,\n      applyYearFilter: applyYearFilter,\n      handleYearKeyPress: handleYearKeyPress,\n      resetAllFilters: resetAllFilters,\n      getCategoryColor: getCategoryColor,\n      sortedData: sortedData\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 430,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Timeline, {\n      isLoading: isLoading,\n      timelineWidth: timelineWidth,\n      totalHeight: totalHeight,\n      centuryBoundaries: centuryBoundaries,\n      minYear: minYear,\n      pixelsPerYear: pixelsPerYear,\n      LEFT_PADDING_PX: LEFT_PADDING_PX,\n      rowPlacement: rowPlacement,\n      filters: filters,\n      groupingType: groupingType,\n      categoryDividers: categoryDividers,\n      getGroupColor: getGroupColor,\n      getGroupColorDark: getGroupColorDark,\n      getGroupColorMuted: getGroupColorMuted,\n      getPersonGroup: getPersonGroup,\n      hoveredPerson: hoveredPerson,\n      setHoveredPerson: setHoveredPerson,\n      mousePosition: mousePosition,\n      setMousePosition: setMousePosition,\n      showTooltip: showTooltip,\n      setShowTooltip: setShowTooltip,\n      activeAchievementMarker: activeAchievementMarker,\n      setActiveAchievementMarker: setActiveAchievementMarker,\n      hoveredAchievement: hoveredAchievement,\n      setHoveredAchievement: setHoveredAchievement,\n      achievementTooltipPosition: achievementTooltipPosition,\n      setAchievementTooltipPosition: setAchievementTooltipPosition,\n      showAchievementTooltip: showAchievementTooltip,\n      setShowAchievementTooltip: setShowAchievementTooltip,\n      hoverTimerRef: hoverTimerRef,\n      sortedData: sortedData\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 449,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Tooltips, {\n      hoveredPerson: hoveredPerson,\n      showTooltip: showTooltip,\n      mousePosition: mousePosition,\n      hoveredAchievement: hoveredAchievement,\n      showAchievementTooltip: showAchievementTooltip,\n      achievementTooltipPosition: achievementTooltipPosition,\n      getGroupColor: getGroupColor,\n      getPersonGroup: getPersonGroup,\n      getCategoryColor: getCategoryColor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 483,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 429,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"GQZed0VJCIlkmsmyXWSG9apjWss=\", false, function () {\n  return [useTimelineData];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","getCategoryColor","getCategoryColorDark","getCategoryColorMuted","AppHeader","Timeline","Tooltips","useTimelineData","generateCenturyBoundaries","getFirstCountry","jsxDEV","_jsxDEV","App","_s","hoveredPerson","setHoveredPerson","mousePosition","setMousePosition","x","y","showTooltip","setShowTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","setShowAchievementTooltip","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","hoverTimerRef","showControls","setShowControls","filters","setFilters","savedFilters","localStorage","getItem","parsed","JSON","parse","categories","countries","timeRange","start","end","showAchievements","undefined","hideEmptyCenturies","groupingType","setGroupingType","savedGrouping","setItem","stringify","current","clearTimeout","persons","allCategories","allCountries","isLoading","yearInputs","setYearInputs","toString","applyYearFilter","field","value","parseInt","numValue","isNaN","prev","handleYearKeyPress","e","key","_e$currentTarget$pare","_e$currentTarget$pare2","currentTarget","inputs","parentElement","querySelectorAll","currentIndex","Array","from","indexOf","nextInput","focus","resetAllFilters","getCategoryPriority","category","getGroupColor","groupName","countryColors","index","length","getGroupColorDark","countryColorsDark","getGroupColorMuted","countryColorsMuted","getPersonGroup","person","country","sortedData","sort","a","b","categoryDiff","countryDiff","birthYear","handleScroll","scrollTop","window","pageYOffset","document","documentElement","addEventListener","removeEventListener","minYear","Math","min","map","p","maxYear","max","deathYear","totalYears","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","effectiveMinYear","effectiveMaxYear","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","top","categoryDividers","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react'\nimport { Person } from './types'\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport './App.css'\n\nfunction App() {\n  const [hoveredPerson, setHoveredPerson] = useState<Person | null>(null)\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n  const [showTooltip, setShowTooltip] = useState(false)\n  const [hoveredAchievement, setHoveredAchievement] = useState<{ person: Person; year: number; index: number } | null>(null)\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({ x: 0, y: 0 })\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false)\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const hoverTimerRef = useRef<NodeJS.Timeout | null>(null)\n  const [showControls, setShowControls] = useState(true)\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || { start: -800, end: 2000 },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true,\n        hideEmptyCenturies: parsed.hideEmptyCenturies !== undefined ? parsed.hideEmptyCenturies : false\n      };\n    }\n    return {\n      categories: [] as string[],\n      countries: [] as string[],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    };\n  })\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState<'category' | 'country' | 'none'>(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping as 'category' | 'country' | 'none' || 'category';\n  })\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      if (hoverTimerRef.current) {\n        clearTimeout(hoverTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  })\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = (field: 'start' | 'end', value: string) => {\n    const parsed = parseInt(value);\n    const numValue = isNaN(parsed) ? (field === 'start' ? -800 : 2000) : parsed;\n    setFilters(prev => ({\n      ...prev,\n      timeRange: { ...prev.timeRange, [field]: numValue }\n    }))\n  }\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field: 'start' | 'end', e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      applyYearFilter(field, e.currentTarget.value)\n      // Переводим фокус на следующий элемент\n      const inputs = e.currentTarget.parentElement?.parentElement?.querySelectorAll('input')\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget)\n        const nextInput = inputs[currentIndex + 1] as HTMLInputElement\n        if (nextInput) {\n          nextInput.focus()\n        }\n      }\n    }\n  }\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    })\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    })\n  }\n\n    // Функция для получения приоритета категории\n  const getCategoryPriority = (category: string) => {\n    return allCategories.indexOf(category)\n  }\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColors[index % countryColors.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = [\n        '#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad',\n        '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98',\n        '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsDark[index % countryColorsDark.length]\n    }\n    return '#7f8c8d' // темно-серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsMuted[index % countryColorsMuted.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = (person: Person) => {\n    if (groupingType === 'category') {\n      return person.category\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country)\n    }\n    return person.category // по умолчанию\n  }\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category)\n      if (categoryDiff !== 0) {\n        return categoryDiff\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country))\n      if (countryDiff !== 0) {\n        return countryDiff\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear\n  })\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n  const totalYears = maxYear - minYear\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies \n    ? Math.min(...sortedData.map(p => p.birthYear))\n    : minYear\n  const effectiveMaxYear = filters.hideEmptyCenturies \n    ? Math.max(...sortedData.map(p => p.deathYear))\n    : maxYear\n  \n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear)\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = (people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData)\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0)\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops: number[] = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  };\n\n  const categoryDividers = createCategoryDividers();\n\n  return (\n    <div className=\"app\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getCategoryColor}\n        sortedData={sortedData}\n      />\n      \n      <Timeline\n        isLoading={isLoading}\n        timelineWidth={timelineWidth}\n        totalHeight={totalHeight}\n        centuryBoundaries={centuryBoundaries}\n        minYear={minYear}\n        pixelsPerYear={pixelsPerYear}\n        LEFT_PADDING_PX={LEFT_PADDING_PX}\n        rowPlacement={rowPlacement}\n        filters={filters}\n        groupingType={groupingType}\n        categoryDividers={categoryDividers}\n        getGroupColor={getGroupColor}\n        getGroupColorDark={getGroupColorDark}\n        getGroupColorMuted={getGroupColorMuted}\n        getPersonGroup={getPersonGroup}\n        hoveredPerson={hoveredPerson}\n        setHoveredPerson={setHoveredPerson}\n        mousePosition={mousePosition}\n        setMousePosition={setMousePosition}\n        showTooltip={showTooltip}\n        setShowTooltip={setShowTooltip}\n        activeAchievementMarker={activeAchievementMarker}\n        setActiveAchievementMarker={setActiveAchievementMarker}\n        hoveredAchievement={hoveredAchievement}\n        setHoveredAchievement={setHoveredAchievement}\n        achievementTooltipPosition={achievementTooltipPosition}\n        setAchievementTooltipPosition={setAchievementTooltipPosition}\n        showAchievementTooltip={showAchievementTooltip}\n        setShowAchievementTooltip={setShowAchievementTooltip}\n        hoverTimerRef={hoverTimerRef}\n        sortedData={sortedData}\n      />\n\n      <Tooltips\n        hoveredPerson={hoveredPerson}\n        showTooltip={showTooltip}\n        mousePosition={mousePosition}\n        hoveredAchievement={hoveredAchievement}\n        showAchievementTooltip={showAchievementTooltip}\n        achievementTooltipPosition={achievementTooltipPosition}\n        getGroupColor={getGroupColor}\n        getPersonGroup={getPersonGroup}\n        getCategoryColor={getCategoryColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}