{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { useMobile } from './useMobile';\nexport const useTimelineDrag = ({\n  timelineWidth,\n  containerWidth\n}) => {\n  _s();\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStartX, setDragStartX] = useState(0);\n  const [dragStartY, setDragStartY] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [scrollTop, setScrollTop] = useState(0);\n  const [isDraggingTimeline, setIsDraggingTimeline] = useState(false);\n  const timelineRef = useRef(null);\n  const dragStartTime = useRef(0);\n  const isMobile = useMobile();\n  const handleMouseDown = useCallback(e => {\n    var _timelineRef$current, _timelineRef$current2;\n    const target = e.target;\n    const isInteractive = target.closest('.life-bar') || target.closest('.achievement-marker') || target.closest('button') || target.closest('[role=\"button\"]');\n    if (isInteractive) return;\n    setIsDragging(true);\n    setDragStartX(e.clientX);\n    setDragStartY(e.clientY);\n    setScrollLeft(((_timelineRef$current = timelineRef.current) === null || _timelineRef$current === void 0 ? void 0 : _timelineRef$current.scrollLeft) || 0);\n    setScrollTop(((_timelineRef$current2 = timelineRef.current) === null || _timelineRef$current2 === void 0 ? void 0 : _timelineRef$current2.scrollTop) || 0);\n    dragStartTime.current = Date.now();\n    e.preventDefault();\n  }, []);\n  const handleMouseMove = useCallback(e => {\n    if (!isDragging) return;\n\n    // Предотвращаем скролл страницы во время перетаскивания\n    e.preventDefault();\n    const deltaX = e.clientX - dragStartX;\n    const deltaY = e.clientY - dragStartY;\n    const newScrollLeft = scrollLeft - deltaX;\n    const newScrollTop = scrollTop - deltaY;\n    if (timelineRef.current) {\n      const maxScrollLeft = timelineRef.current.scrollWidth - timelineRef.current.clientWidth;\n      const maxScrollTop = timelineRef.current.scrollHeight - timelineRef.current.clientHeight;\n      timelineRef.current.scrollLeft = Math.max(0, Math.min(maxScrollLeft, newScrollLeft));\n      timelineRef.current.scrollTop = Math.max(0, Math.min(maxScrollTop, newScrollTop));\n    }\n  }, [isDragging, dragStartX, dragStartY, scrollLeft, scrollTop]);\n  const handleMouseUp = useCallback(() => {\n    if (!isDragging) return;\n    const dragDuration = Date.now() - dragStartTime.current;\n    if (dragDuration < 200) {\n      setIsDraggingTimeline(false);\n    } else {\n      setIsDraggingTimeline(true);\n      setTimeout(() => setIsDraggingTimeline(false), 100);\n    }\n    setIsDragging(false);\n  }, [isDragging]);\n  const handleTouchStart = useCallback(e => {\n    var _timelineRef$current3, _timelineRef$current4;\n    const target = e.target;\n    const isInteractive = target.closest('.life-bar') || target.closest('.achievement-marker') || target.closest('button') || target.closest('[role=\"button\"]');\n    if (isInteractive) return;\n    setIsDragging(true);\n    setDragStartX(e.touches[0].clientX);\n    setDragStartY(e.touches[0].clientY);\n    setScrollLeft(((_timelineRef$current3 = timelineRef.current) === null || _timelineRef$current3 === void 0 ? void 0 : _timelineRef$current3.scrollLeft) || 0);\n    setScrollTop(((_timelineRef$current4 = timelineRef.current) === null || _timelineRef$current4 === void 0 ? void 0 : _timelineRef$current4.scrollTop) || 0);\n    dragStartTime.current = Date.now();\n  }, []);\n  const handleTouchMove = useCallback(e => {\n    if (!isDragging) return;\n\n    // Предотвращаем скролл страницы во время перетаскивания\n    e.preventDefault();\n    const deltaX = e.touches[0].clientX - dragStartX;\n    const deltaY = e.touches[0].clientY - dragStartY;\n    const newScrollLeft = scrollLeft - deltaX;\n    const newScrollTop = scrollTop - deltaY;\n    if (timelineRef.current) {\n      const maxScrollLeft = timelineRef.current.scrollWidth - timelineRef.current.clientWidth;\n      const maxScrollTop = timelineRef.current.scrollHeight - timelineRef.current.clientHeight;\n      timelineRef.current.scrollLeft = Math.max(0, Math.min(maxScrollLeft, newScrollLeft));\n      timelineRef.current.scrollTop = Math.max(0, Math.min(maxScrollTop, newScrollTop));\n    }\n  }, [isDragging, dragStartX, dragStartY, scrollLeft, scrollTop]);\n  const handleTouchEnd = useCallback(() => {\n    if (!isDragging) return;\n    const dragDuration = Date.now() - dragStartTime.current;\n    if (dragDuration < 200) {\n      setIsDraggingTimeline(false);\n    } else {\n      setIsDraggingTimeline(true);\n      setTimeout(() => setIsDraggingTimeline(false), 100);\n    }\n    setIsDragging(false);\n  }, [isDragging]);\n  useEffect(() => {\n    return () => {\n      setIsDragging(false);\n      setIsDraggingTimeline(false);\n    };\n  }, []);\n  return {\n    timelineRef,\n    isDragging,\n    isDraggingTimeline,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  };\n};\n_s(useTimelineDrag, \"wv2ZDEF007I3DUhF3VbZPYmlARI=\", false, function () {\n  return [useMobile];\n});","map":{"version":3,"names":["useState","useRef","useCallback","useEffect","useMobile","useTimelineDrag","timelineWidth","containerWidth","_s","isDragging","setIsDragging","dragStartX","setDragStartX","dragStartY","setDragStartY","scrollLeft","setScrollLeft","scrollTop","setScrollTop","isDraggingTimeline","setIsDraggingTimeline","timelineRef","dragStartTime","isMobile","handleMouseDown","e","_timelineRef$current","_timelineRef$current2","target","isInteractive","closest","clientX","clientY","current","Date","now","preventDefault","handleMouseMove","deltaX","deltaY","newScrollLeft","newScrollTop","maxScrollLeft","scrollWidth","clientWidth","maxScrollTop","scrollHeight","clientHeight","Math","max","min","handleMouseUp","dragDuration","setTimeout","handleTouchStart","_timelineRef$current3","_timelineRef$current4","touches","handleTouchMove","handleTouchEnd"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/hooks/useTimelineDrag.ts"],"sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react'\nimport { useMobile } from './useMobile'\n\ninterface UseTimelineDragProps {\n  timelineWidth: number\n  containerWidth: number\n}\n\nexport const useTimelineDrag = ({ timelineWidth, containerWidth }: UseTimelineDragProps) => {\n  const [isDragging, setIsDragging] = useState(false)\n  const [dragStartX, setDragStartX] = useState(0)\n  const [dragStartY, setDragStartY] = useState(0)\n  const [scrollLeft, setScrollLeft] = useState(0)\n  const [scrollTop, setScrollTop] = useState(0)\n  const [isDraggingTimeline, setIsDraggingTimeline] = useState(false)\n  const timelineRef = useRef<HTMLDivElement>(null)\n  const dragStartTime = useRef<number>(0)\n  const isMobile = useMobile()\n\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    const target = e.target as HTMLElement\n    const isInteractive = target.closest('.life-bar') || \n                         target.closest('.achievement-marker') ||\n                         target.closest('button') ||\n                         target.closest('[role=\"button\"]')\n    \n    if (isInteractive) return\n\n    setIsDragging(true)\n    setDragStartX(e.clientX)\n    setDragStartY(e.clientY)\n    setScrollLeft(timelineRef.current?.scrollLeft || 0)\n    setScrollTop(timelineRef.current?.scrollTop || 0)\n    dragStartTime.current = Date.now()\n    e.preventDefault()\n  }, [])\n\n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    if (!isDragging) return\n\n    // Предотвращаем скролл страницы во время перетаскивания\n    e.preventDefault()\n\n    const deltaX = e.clientX - dragStartX\n    const deltaY = e.clientY - dragStartY\n    const newScrollLeft = scrollLeft - deltaX\n    const newScrollTop = scrollTop - deltaY\n    \n    if (timelineRef.current) {\n      const maxScrollLeft = timelineRef.current.scrollWidth - timelineRef.current.clientWidth\n      const maxScrollTop = timelineRef.current.scrollHeight - timelineRef.current.clientHeight\n      \n      timelineRef.current.scrollLeft = Math.max(0, Math.min(maxScrollLeft, newScrollLeft))\n      timelineRef.current.scrollTop = Math.max(0, Math.min(maxScrollTop, newScrollTop))\n    }\n  }, [isDragging, dragStartX, dragStartY, scrollLeft, scrollTop])\n\n  const handleMouseUp = useCallback(() => {\n    if (!isDragging) return\n\n    const dragDuration = Date.now() - dragStartTime.current\n    \n    if (dragDuration < 200) {\n      setIsDraggingTimeline(false)\n    } else {\n      setIsDraggingTimeline(true)\n      setTimeout(() => setIsDraggingTimeline(false), 100)\n    }\n\n    setIsDragging(false)\n  }, [isDragging])\n\n  const handleTouchStart = useCallback((e: React.TouchEvent) => {\n    const target = e.target as HTMLElement\n    const isInteractive = target.closest('.life-bar') || \n                         target.closest('.achievement-marker') ||\n                         target.closest('button') ||\n                         target.closest('[role=\"button\"]')\n    \n    if (isInteractive) return\n\n    setIsDragging(true)\n    setDragStartX(e.touches[0].clientX)\n    setDragStartY(e.touches[0].clientY)\n    setScrollLeft(timelineRef.current?.scrollLeft || 0)\n    setScrollTop(timelineRef.current?.scrollTop || 0)\n    dragStartTime.current = Date.now()\n  }, [])\n\n  const handleTouchMove = useCallback((e: React.TouchEvent) => {\n    if (!isDragging) return\n\n    // Предотвращаем скролл страницы во время перетаскивания\n    e.preventDefault()\n\n    const deltaX = e.touches[0].clientX - dragStartX\n    const deltaY = e.touches[0].clientY - dragStartY\n    const newScrollLeft = scrollLeft - deltaX\n    const newScrollTop = scrollTop - deltaY\n    \n    if (timelineRef.current) {\n      const maxScrollLeft = timelineRef.current.scrollWidth - timelineRef.current.clientWidth\n      const maxScrollTop = timelineRef.current.scrollHeight - timelineRef.current.clientHeight\n      \n      timelineRef.current.scrollLeft = Math.max(0, Math.min(maxScrollLeft, newScrollLeft))\n      timelineRef.current.scrollTop = Math.max(0, Math.min(maxScrollTop, newScrollTop))\n    }\n  }, [isDragging, dragStartX, dragStartY, scrollLeft, scrollTop])\n\n  const handleTouchEnd = useCallback(() => {\n    if (!isDragging) return\n\n    const dragDuration = Date.now() - dragStartTime.current\n    \n    if (dragDuration < 200) {\n      setIsDraggingTimeline(false)\n    } else {\n      setIsDraggingTimeline(true)\n      setTimeout(() => setIsDraggingTimeline(false), 100)\n    }\n\n    setIsDragging(false)\n  }, [isDragging])\n\n  useEffect(() => {\n    return () => {\n      setIsDragging(false)\n      setIsDraggingTimeline(false)\n    }\n  }, [])\n\n  return {\n    timelineRef,\n    isDragging,\n    isDraggingTimeline,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  }\n} "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AAChE,SAASC,SAAS,QAAQ,aAAa;AAOvC,OAAO,MAAMC,eAAe,GAAGA,CAAC;EAAEC,aAAa;EAAEC;AAAqC,CAAC,KAAK;EAAAC,EAAA;EAC1F,MAAM,CAACC,UAAU,EAAEC,aAAa,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EACnD,MAAM,CAACW,UAAU,EAAEC,aAAa,CAAC,GAAGZ,QAAQ,CAAC,CAAC,CAAC;EAC/C,MAAM,CAACa,UAAU,EAAEC,aAAa,CAAC,GAAGd,QAAQ,CAAC,CAAC,CAAC;EAC/C,MAAM,CAACe,UAAU,EAAEC,aAAa,CAAC,GAAGhB,QAAQ,CAAC,CAAC,CAAC;EAC/C,MAAM,CAACiB,SAAS,EAAEC,YAAY,CAAC,GAAGlB,QAAQ,CAAC,CAAC,CAAC;EAC7C,MAAM,CAACmB,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGpB,QAAQ,CAAC,KAAK,CAAC;EACnE,MAAMqB,WAAW,GAAGpB,MAAM,CAAiB,IAAI,CAAC;EAChD,MAAMqB,aAAa,GAAGrB,MAAM,CAAS,CAAC,CAAC;EACvC,MAAMsB,QAAQ,GAAGnB,SAAS,CAAC,CAAC;EAE5B,MAAMoB,eAAe,GAAGtB,WAAW,CAAEuB,CAAmB,IAAK;IAAA,IAAAC,oBAAA,EAAAC,qBAAA;IAC3D,MAAMC,MAAM,GAAGH,CAAC,CAACG,MAAqB;IACtC,MAAMC,aAAa,GAAGD,MAAM,CAACE,OAAO,CAAC,WAAW,CAAC,IAC5BF,MAAM,CAACE,OAAO,CAAC,qBAAqB,CAAC,IACrCF,MAAM,CAACE,OAAO,CAAC,QAAQ,CAAC,IACxBF,MAAM,CAACE,OAAO,CAAC,iBAAiB,CAAC;IAEtD,IAAID,aAAa,EAAE;IAEnBnB,aAAa,CAAC,IAAI,CAAC;IACnBE,aAAa,CAACa,CAAC,CAACM,OAAO,CAAC;IACxBjB,aAAa,CAACW,CAAC,CAACO,OAAO,CAAC;IACxBhB,aAAa,CAAC,EAAAU,oBAAA,GAAAL,WAAW,CAACY,OAAO,cAAAP,oBAAA,uBAAnBA,oBAAA,CAAqBX,UAAU,KAAI,CAAC,CAAC;IACnDG,YAAY,CAAC,EAAAS,qBAAA,GAAAN,WAAW,CAACY,OAAO,cAAAN,qBAAA,uBAAnBA,qBAAA,CAAqBV,SAAS,KAAI,CAAC,CAAC;IACjDK,aAAa,CAACW,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAClCV,CAAC,CAACW,cAAc,CAAC,CAAC;EACpB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,eAAe,GAAGnC,WAAW,CAAEuB,CAAmB,IAAK;IAC3D,IAAI,CAAChB,UAAU,EAAE;;IAEjB;IACAgB,CAAC,CAACW,cAAc,CAAC,CAAC;IAElB,MAAME,MAAM,GAAGb,CAAC,CAACM,OAAO,GAAGpB,UAAU;IACrC,MAAM4B,MAAM,GAAGd,CAAC,CAACO,OAAO,GAAGnB,UAAU;IACrC,MAAM2B,aAAa,GAAGzB,UAAU,GAAGuB,MAAM;IACzC,MAAMG,YAAY,GAAGxB,SAAS,GAAGsB,MAAM;IAEvC,IAAIlB,WAAW,CAACY,OAAO,EAAE;MACvB,MAAMS,aAAa,GAAGrB,WAAW,CAACY,OAAO,CAACU,WAAW,GAAGtB,WAAW,CAACY,OAAO,CAACW,WAAW;MACvF,MAAMC,YAAY,GAAGxB,WAAW,CAACY,OAAO,CAACa,YAAY,GAAGzB,WAAW,CAACY,OAAO,CAACc,YAAY;MAExF1B,WAAW,CAACY,OAAO,CAAClB,UAAU,GAAGiC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACR,aAAa,EAAEF,aAAa,CAAC,CAAC;MACpFnB,WAAW,CAACY,OAAO,CAAChB,SAAS,GAAG+B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACL,YAAY,EAAEJ,YAAY,CAAC,CAAC;IACnF;EACF,CAAC,EAAE,CAAChC,UAAU,EAAEE,UAAU,EAAEE,UAAU,EAAEE,UAAU,EAAEE,SAAS,CAAC,CAAC;EAE/D,MAAMkC,aAAa,GAAGjD,WAAW,CAAC,MAAM;IACtC,IAAI,CAACO,UAAU,EAAE;IAEjB,MAAM2C,YAAY,GAAGlB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGb,aAAa,CAACW,OAAO;IAEvD,IAAImB,YAAY,GAAG,GAAG,EAAE;MACtBhC,qBAAqB,CAAC,KAAK,CAAC;IAC9B,CAAC,MAAM;MACLA,qBAAqB,CAAC,IAAI,CAAC;MAC3BiC,UAAU,CAAC,MAAMjC,qBAAqB,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC;IACrD;IAEAV,aAAa,CAAC,KAAK,CAAC;EACtB,CAAC,EAAE,CAACD,UAAU,CAAC,CAAC;EAEhB,MAAM6C,gBAAgB,GAAGpD,WAAW,CAAEuB,CAAmB,IAAK;IAAA,IAAA8B,qBAAA,EAAAC,qBAAA;IAC5D,MAAM5B,MAAM,GAAGH,CAAC,CAACG,MAAqB;IACtC,MAAMC,aAAa,GAAGD,MAAM,CAACE,OAAO,CAAC,WAAW,CAAC,IAC5BF,MAAM,CAACE,OAAO,CAAC,qBAAqB,CAAC,IACrCF,MAAM,CAACE,OAAO,CAAC,QAAQ,CAAC,IACxBF,MAAM,CAACE,OAAO,CAAC,iBAAiB,CAAC;IAEtD,IAAID,aAAa,EAAE;IAEnBnB,aAAa,CAAC,IAAI,CAAC;IACnBE,aAAa,CAACa,CAAC,CAACgC,OAAO,CAAC,CAAC,CAAC,CAAC1B,OAAO,CAAC;IACnCjB,aAAa,CAACW,CAAC,CAACgC,OAAO,CAAC,CAAC,CAAC,CAACzB,OAAO,CAAC;IACnChB,aAAa,CAAC,EAAAuC,qBAAA,GAAAlC,WAAW,CAACY,OAAO,cAAAsB,qBAAA,uBAAnBA,qBAAA,CAAqBxC,UAAU,KAAI,CAAC,CAAC;IACnDG,YAAY,CAAC,EAAAsC,qBAAA,GAAAnC,WAAW,CAACY,OAAO,cAAAuB,qBAAA,uBAAnBA,qBAAA,CAAqBvC,SAAS,KAAI,CAAC,CAAC;IACjDK,aAAa,CAACW,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EACpC,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMuB,eAAe,GAAGxD,WAAW,CAAEuB,CAAmB,IAAK;IAC3D,IAAI,CAAChB,UAAU,EAAE;;IAEjB;IACAgB,CAAC,CAACW,cAAc,CAAC,CAAC;IAElB,MAAME,MAAM,GAAGb,CAAC,CAACgC,OAAO,CAAC,CAAC,CAAC,CAAC1B,OAAO,GAAGpB,UAAU;IAChD,MAAM4B,MAAM,GAAGd,CAAC,CAACgC,OAAO,CAAC,CAAC,CAAC,CAACzB,OAAO,GAAGnB,UAAU;IAChD,MAAM2B,aAAa,GAAGzB,UAAU,GAAGuB,MAAM;IACzC,MAAMG,YAAY,GAAGxB,SAAS,GAAGsB,MAAM;IAEvC,IAAIlB,WAAW,CAACY,OAAO,EAAE;MACvB,MAAMS,aAAa,GAAGrB,WAAW,CAACY,OAAO,CAACU,WAAW,GAAGtB,WAAW,CAACY,OAAO,CAACW,WAAW;MACvF,MAAMC,YAAY,GAAGxB,WAAW,CAACY,OAAO,CAACa,YAAY,GAAGzB,WAAW,CAACY,OAAO,CAACc,YAAY;MAExF1B,WAAW,CAACY,OAAO,CAAClB,UAAU,GAAGiC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACR,aAAa,EAAEF,aAAa,CAAC,CAAC;MACpFnB,WAAW,CAACY,OAAO,CAAChB,SAAS,GAAG+B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAACL,YAAY,EAAEJ,YAAY,CAAC,CAAC;IACnF;EACF,CAAC,EAAE,CAAChC,UAAU,EAAEE,UAAU,EAAEE,UAAU,EAAEE,UAAU,EAAEE,SAAS,CAAC,CAAC;EAE/D,MAAM0C,cAAc,GAAGzD,WAAW,CAAC,MAAM;IACvC,IAAI,CAACO,UAAU,EAAE;IAEjB,MAAM2C,YAAY,GAAGlB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGb,aAAa,CAACW,OAAO;IAEvD,IAAImB,YAAY,GAAG,GAAG,EAAE;MACtBhC,qBAAqB,CAAC,KAAK,CAAC;IAC9B,CAAC,MAAM;MACLA,qBAAqB,CAAC,IAAI,CAAC;MAC3BiC,UAAU,CAAC,MAAMjC,qBAAqB,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC;IACrD;IAEAV,aAAa,CAAC,KAAK,CAAC;EACtB,CAAC,EAAE,CAACD,UAAU,CAAC,CAAC;EAEhBN,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACXO,aAAa,CAAC,KAAK,CAAC;MACpBU,qBAAqB,CAAC,KAAK,CAAC;IAC9B,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACLC,WAAW;IACXZ,UAAU;IACVU,kBAAkB;IAClBK,eAAe;IACfa,eAAe;IACfc,aAAa;IACbG,gBAAgB;IAChBI,eAAe;IACfC;EACF,CAAC;AACH,CAAC;AAAAnD,EAAA,CAtIYH,eAAe;EAAA,QASTD,SAAS;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}