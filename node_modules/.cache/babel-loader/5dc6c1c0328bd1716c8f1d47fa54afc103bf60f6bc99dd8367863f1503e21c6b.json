{"ast":null,"code":"import { authStorage } from './auth';\n// API configuration\nconst getApiConfig = () => {\n  // Определяем окружение\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  const isLocalBackend = process.env.REACT_APP_USE_LOCAL_BACKEND === 'true';\n  const forcedApiUrl = process.env.REACT_APP_FORCE_API_URL;\n  const serverEnv = process.env.REACT_APP_ENV === 'server';\n\n  // URL для разных окружений\n  const LOCAL_BACKEND_URL = process.env.REACT_APP_LOCAL_BACKEND_URL || 'http://localhost:3001';\n  const REMOTE_BACKEND_URL = process.env.REACT_APP_REMOTE_BACKEND_URL || 'https://chrono-back-kramushka.amvera.io';\n  const SERVER_DEFAULT_BACKEND_URL = process.env.REACT_APP_SERVER_BACKEND_URL || 'http://amvera-kramushka-run-chrono-back';\n\n  // Выбираем URL в зависимости от настроек\n  let apiUrl;\n  if (forcedApiUrl) {\n    apiUrl = forcedApiUrl;\n    console.log('🚩 Принудительно задан backend:', apiUrl);\n  } else if (serverEnv) {\n    apiUrl = process.env.REACT_APP_API_URL || SERVER_DEFAULT_BACKEND_URL;\n    console.log('🏷️ Режим сервера: backend =', apiUrl);\n  } else if (isDevelopment && isLocalBackend) {\n    apiUrl = LOCAL_BACKEND_URL;\n    console.log('🔧 Используется локальный backend:', apiUrl);\n  } else {\n    apiUrl = process.env.REACT_APP_API_URL || REMOTE_BACKEND_URL;\n    console.log('🌐 Используется удаленный backend:', apiUrl);\n  }\n  return {\n    baseUrl: apiUrl,\n    timeout: 10000,\n    // 10 секунд\n    retries: 2\n  };\n};\nconst API_CONFIG = getApiConfig();\nconst API_BASE_URL = API_CONFIG.baseUrl;\n\n// Safe decode function\nconst safeDecode = str => {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (error) {\n    console.warn('Failed to decode string:', str, error);\n    return str;\n  }\n};\n\n// Helper function for API requests with retry logic\nconst apiRequest = async (url, options = {}) => {\n  let lastError = null;\n  for (let attempt = 0; attempt <= API_CONFIG.retries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      lastError = error;\n      console.warn(`API request attempt ${attempt + 1} failed:`, error);\n      if (attempt < API_CONFIG.retries) {\n        // Ждем перед повторной попыткой (экспоненциальная задержка)\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n      }\n    }\n  }\n  throw lastError || new Error('API request failed after all retries');\n};\n\n// Types for API responses\n\n// Helper function to build query string from filters\nconst buildQueryString = filters => {\n  const params = new URLSearchParams();\n  if (filters.category) {\n    params.append('category', filters.category);\n  }\n  if (filters.country) {\n    params.append('country', filters.country);\n  }\n  if (filters.startYear !== undefined) {\n    params.append('startYear', filters.startYear.toString());\n  }\n  if (filters.endYear !== undefined) {\n    params.append('endYear', filters.endYear.toString());\n  }\n  return params.toString();\n};\n\n// Get persons with optional filters\nexport const getPersons = async (filters = {}) => {\n  try {\n    const queryString = buildQueryString(filters);\n    const url = `${API_BASE_URL}/api/persons${queryString ? `?${queryString}` : ''}`;\n    const response = await apiRequest(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Преобразуем данные в правильный формат с безопасной декодировкой\n    let transformedData = data.map(person => ({\n      id: person.id,\n      name: safeDecode(person.name || ''),\n      birthYear: person.birthYear,\n      deathYear: person.deathYear,\n      category: safeDecode(person.category || ''),\n      country: safeDecode(person.country || ''),\n      description: safeDecode(person.description || ''),\n      imageUrl: person.imageUrl,\n      reignStart: person.reignStart,\n      reignEnd: person.reignEnd,\n      achievementYear1: person.achievementYear1,\n      achievementYear2: person.achievementYear2,\n      achievementYear3: person.achievementYear3,\n      achievements: Array.isArray(person.achievements) ? person.achievements.map(a => safeDecode(a || '')) : []\n    }));\n\n    // Дополнительная фильтрация на клиенте для множественных стран\n    if (filters.country) {\n      const selectedCountries = filters.country.split(',').map(c => c.trim());\n      transformedData = transformedData.filter(person => {\n        const personCountries = person.country.includes('/') ? person.country.split('/').map(c => c.trim()) : [person.country];\n        return selectedCountries.some(selected => personCountries.includes(selected));\n      });\n    }\n    return transformedData;\n  } catch (error) {\n    console.error('Error fetching persons:', error);\n    // Return empty array as fallback\n    return [];\n  }\n};\n\n// Get all categories\nexport const getCategories = async () => {\n  try {\n    const url = `${API_BASE_URL}/api/categories`;\n    const response = await apiRequest(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Безопасная декодировка категорий\n    return data.map(category => safeDecode(category || ''));\n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    // Return default categories as fallback\n    return ['Политик', 'Ученый', 'Художник', 'Писатель', 'Военачальник'];\n  }\n};\n\n// Get all countries\nexport const getCountries = async () => {\n  try {\n    const url = `${API_BASE_URL}/api/countries`;\n    const response = await apiRequest(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Безопасная декодировка стран и разбивка множественных стран\n    const allCountries = new Set();\n    data.forEach(country => {\n      const decodedCountry = safeDecode(country || '');\n      if (decodedCountry.includes('/')) {\n        // Разбиваем множественные страны на отдельные\n        const countries = decodedCountry.split('/').map(c => c.trim());\n        countries.forEach(c => {\n          if (c) allCountries.add(c);\n        });\n      } else {\n        allCountries.add(decodedCountry);\n      }\n    });\n\n    // Сортируем страны по алфавиту\n    return Array.from(allCountries).sort();\n  } catch (error) {\n    console.error('Error fetching countries:', error);\n    // Return default countries as fallback\n    return ['Древний Рим', 'Древняя Греция', 'Древний Египет', 'Китай', 'Индия'];\n  }\n};\n\n// Test connection to backend\nexport const testBackendConnection = async () => {\n  try {\n    const response = await apiRequest(`${API_BASE_URL}/api/health`);\n    return response.ok;\n  } catch (error) {\n    console.error('Backend connection test failed:', error);\n    return false;\n  }\n};\n\n// Get backend info\nexport const getBackendInfo = () => {\n  return {\n    baseUrl: API_BASE_URL,\n    isLocal: API_BASE_URL.includes('localhost'),\n    config: API_CONFIG\n  };\n};\n\n// --- Auth-aware fetch with 401 handling and token refresh ---\n\nlet isRefreshing = false;\nlet pendingRequests = [];\nasync function refreshTokenIfNeeded() {\n  if (isRefreshing) {\n    await new Promise(resolve => pendingRequests.push(resolve));\n    return;\n  }\n  isRefreshing = true;\n  try {\n    var _data$data, _data$data2, _data$data3;\n    const state = authStorage.load();\n    if (!state.refreshToken) throw new Error('No refresh token');\n    const res = await apiRequest(`${API_BASE_URL}/api/auth/refresh`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        refresh_token: state.refreshToken\n      })\n    });\n    if (!res.ok) throw new Error('Refresh failed');\n    const data = await res.json();\n    const newState = {\n      user: (data === null || data === void 0 ? void 0 : (_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.user) || state.user,\n      accessToken: (data === null || data === void 0 ? void 0 : (_data$data2 = data.data) === null || _data$data2 === void 0 ? void 0 : _data$data2.access_token) || null,\n      refreshToken: (data === null || data === void 0 ? void 0 : (_data$data3 = data.data) === null || _data$data3 === void 0 ? void 0 : _data$data3.refresh_token) || state.refreshToken\n    };\n    authStorage.save(newState);\n  } finally {\n    isRefreshing = false;\n    pendingRequests.forEach(resolve => resolve());\n    pendingRequests = [];\n  }\n}\nexport async function apiFetch(path, init = {}) {\n  const url = `${API_BASE_URL}${path}`;\n  const state = authStorage.load();\n  const headers = new Headers(init.headers || {});\n  if (state.accessToken && !headers.has('Authorization')) {\n    headers.set('Authorization', `Bearer ${state.accessToken}`);\n  }\n  try {\n    const res = await apiRequest(url, {\n      ...init,\n      headers\n    });\n    if (res.status !== 401) return res;\n    // Try refresh and retry once\n    await refreshTokenIfNeeded();\n    const refreshed = authStorage.load();\n    const retryHeaders = new Headers(init.headers || {});\n    if (refreshed.accessToken) retryHeaders.set('Authorization', `Bearer ${refreshed.accessToken}`);\n    return apiRequest(url, {\n      ...init,\n      headers: retryHeaders\n    });\n  } catch (e) {\n    throw e;\n  }\n}","map":{"version":3,"names":["authStorage","getApiConfig","isDevelopment","process","env","NODE_ENV","isLocalBackend","REACT_APP_USE_LOCAL_BACKEND","forcedApiUrl","REACT_APP_FORCE_API_URL","serverEnv","REACT_APP_ENV","LOCAL_BACKEND_URL","REACT_APP_LOCAL_BACKEND_URL","REMOTE_BACKEND_URL","REACT_APP_REMOTE_BACKEND_URL","SERVER_DEFAULT_BACKEND_URL","REACT_APP_SERVER_BACKEND_URL","apiUrl","console","log","REACT_APP_API_URL","baseUrl","timeout","retries","API_CONFIG","API_BASE_URL","safeDecode","str","decodeURIComponent","escape","error","warn","apiRequest","url","options","lastError","attempt","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","clearTimeout","Promise","resolve","Math","pow","Error","buildQueryString","filters","params","URLSearchParams","category","append","country","startYear","undefined","toString","endYear","getPersons","queryString","ok","status","data","json","transformedData","map","person","id","name","birthYear","deathYear","description","imageUrl","reignStart","reignEnd","achievementYear1","achievementYear2","achievementYear3","achievements","Array","isArray","a","selectedCountries","split","c","trim","filter","personCountries","includes","some","selected","getCategories","getCountries","allCountries","Set","forEach","decodedCountry","countries","add","from","sort","testBackendConnection","getBackendInfo","isLocal","config","isRefreshing","pendingRequests","refreshTokenIfNeeded","push","_data$data","_data$data2","_data$data3","state","load","refreshToken","res","method","headers","body","JSON","stringify","refresh_token","newState","user","accessToken","access_token","save","apiFetch","path","init","Headers","has","set","refreshed","retryHeaders","e"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/services/api.ts"],"sourcesContent":["import { authStorage } from './auth';\n// API configuration\nconst getApiConfig = () => {\n  // Определяем окружение\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  const isLocalBackend = process.env.REACT_APP_USE_LOCAL_BACKEND === 'true';\n  const forcedApiUrl = process.env.REACT_APP_FORCE_API_URL;\n  const serverEnv = process.env.REACT_APP_ENV === 'server';\n  \n  // URL для разных окружений\n  const LOCAL_BACKEND_URL = process.env.REACT_APP_LOCAL_BACKEND_URL || 'http://localhost:3001';\n  const REMOTE_BACKEND_URL = process.env.REACT_APP_REMOTE_BACKEND_URL || 'https://chrono-back-kramushka.amvera.io';\n  const SERVER_DEFAULT_BACKEND_URL = process.env.REACT_APP_SERVER_BACKEND_URL || 'http://amvera-kramushka-run-chrono-back';\n  \n  // Выбираем URL в зависимости от настроек\n  let apiUrl: string;\n  if (forcedApiUrl) {\n    apiUrl = forcedApiUrl;\n    console.log('🚩 Принудительно задан backend:', apiUrl);\n  } else if (serverEnv) {\n    apiUrl = process.env.REACT_APP_API_URL || SERVER_DEFAULT_BACKEND_URL;\n    console.log('🏷️ Режим сервера: backend =', apiUrl);\n  } else if (isDevelopment && isLocalBackend) {\n    apiUrl = LOCAL_BACKEND_URL;\n    console.log('🔧 Используется локальный backend:', apiUrl);\n  } else {\n    apiUrl = process.env.REACT_APP_API_URL || REMOTE_BACKEND_URL;\n    console.log('🌐 Используется удаленный backend:', apiUrl);\n  }\n  \n  return {\n    baseUrl: apiUrl,\n    timeout: 10000, // 10 секунд\n    retries: 2\n  };\n};\n\nconst API_CONFIG = getApiConfig();\nconst API_BASE_URL = API_CONFIG.baseUrl;\n\n// Safe decode function\nconst safeDecode = (str: string): string => {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (error) {\n    console.warn('Failed to decode string:', str, error);\n    return str;\n  }\n};\n\n// Helper function for API requests with retry logic\nconst apiRequest = async (url: string, options: RequestInit = {}): Promise<Response> => {\n  let lastError: Error | null = null;\n  \n  for (let attempt = 0; attempt <= API_CONFIG.retries; attempt++) {\n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);\n      \n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      lastError = error as Error;\n      console.warn(`API request attempt ${attempt + 1} failed:`, error);\n      \n      if (attempt < API_CONFIG.retries) {\n        // Ждем перед повторной попыткой (экспоненциальная задержка)\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n      }\n    }\n  }\n  \n  throw lastError || new Error('API request failed after all retries');\n};\n\n// Types for API responses\ninterface Person {\n  id: string;\n  name: string;\n  birthYear: number;\n  deathYear: number;\n  category: string;\n  country: string;\n  description: string;\n  imageUrl?: string;\n  reignStart?: number;\n  reignEnd?: number;\n  achievementYear1?: number;\n  achievementYear2?: number;\n  achievementYear3?: number;\n  achievements: string[];\n}\n\ninterface ApiFilters {\n  category?: string;\n  country?: string;\n  startYear?: number;\n  endYear?: number;\n}\n\n// Helper function to build query string from filters\nconst buildQueryString = (filters: ApiFilters): string => {\n  const params = new URLSearchParams();\n  \n  if (filters.category) {\n    params.append('category', filters.category);\n  }\n  if (filters.country) {\n    params.append('country', filters.country);\n  }\n  if (filters.startYear !== undefined) {\n    params.append('startYear', filters.startYear.toString());\n  }\n  if (filters.endYear !== undefined) {\n    params.append('endYear', filters.endYear.toString());\n  }\n  \n  return params.toString();\n};\n\n// Get persons with optional filters\nexport const getPersons = async (filters: ApiFilters = {}): Promise<Person[]> => {\n  try {\n    const queryString = buildQueryString(filters);\n    const url = `${API_BASE_URL}/api/persons${queryString ? `?${queryString}` : ''}`;\n    \n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Преобразуем данные в правильный формат с безопасной декодировкой\n    let transformedData = data.map((person: {\n      id: string;\n      name?: string;\n      birthYear: number;\n      deathYear: number;\n      category?: string;\n      country?: string;\n      description?: string;\n      imageUrl?: string;\n      reignStart?: number;\n      reignEnd?: number;\n      achievementYear1?: number;\n      achievementYear2?: number;\n      achievementYear3?: number;\n      achievements?: string[];\n    }) => ({\n      id: person.id,\n      name: safeDecode(person.name || ''),\n      birthYear: person.birthYear,\n      deathYear: person.deathYear,\n      category: safeDecode(person.category || ''),\n      country: safeDecode(person.country || ''),\n      description: safeDecode(person.description || ''),\n      imageUrl: person.imageUrl,\n      reignStart: person.reignStart,\n      reignEnd: person.reignEnd,\n      achievementYear1: person.achievementYear1,\n      achievementYear2: person.achievementYear2,\n      achievementYear3: person.achievementYear3,\n      achievements: Array.isArray(person.achievements) ? person.achievements.map((a: string) => safeDecode(a || '')) : []\n    }));\n    \n    // Дополнительная фильтрация на клиенте для множественных стран\n    if (filters.country) {\n      const selectedCountries = filters.country.split(',').map((c: string) => c.trim());\n      transformedData = transformedData.filter((person: Person) => {\n        const personCountries = person.country.includes('/') \n          ? person.country.split('/').map((c: string) => c.trim())\n          : [person.country];\n        return selectedCountries.some((selected: string) => personCountries.includes(selected));\n      });\n    }\n    \n    return transformedData;\n  } catch (error) {\n    console.error('Error fetching persons:', error);\n    // Return empty array as fallback\n    return [];\n  }\n};\n\n// Get all categories\nexport const getCategories = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/categories`;\n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка категорий\n    return data.map((category: string) => safeDecode(category || ''));\n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    // Return default categories as fallback\n    return ['Политик', 'Ученый', 'Художник', 'Писатель', 'Военачальник'];\n  }\n};\n\n// Get all countries\nexport const getCountries = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/countries`;\n    const response = await apiRequest(url);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка стран и разбивка множественных стран\n    const allCountries = new Set<string>();\n    \n    data.forEach((country: string | null) => {\n      const decodedCountry = safeDecode(country || '');\n      if (decodedCountry.includes('/')) {\n        // Разбиваем множественные страны на отдельные\n        const countries = decodedCountry.split('/').map(c => c.trim());\n        countries.forEach(c => {\n          if (c) allCountries.add(c);\n        });\n      } else {\n        allCountries.add(decodedCountry);\n      }\n    });\n    \n    // Сортируем страны по алфавиту\n    return Array.from(allCountries).sort();\n  } catch (error) {\n    console.error('Error fetching countries:', error);\n    // Return default countries as fallback\n    return ['Древний Рим', 'Древняя Греция', 'Древний Египет', 'Китай', 'Индия'];\n  }\n};\n\n// Test connection to backend\nexport const testBackendConnection = async (): Promise<boolean> => {\n  try {\n    const response = await apiRequest(`${API_BASE_URL}/api/health`);\n    return response.ok;\n  } catch (error) {\n    console.error('Backend connection test failed:', error);\n    return false;\n  }\n};\n\n// Get backend info\nexport const getBackendInfo = () => {\n  return {\n    baseUrl: API_BASE_URL,\n    isLocal: API_BASE_URL.includes('localhost'),\n    config: API_CONFIG\n  };\n}; \n\n// --- Auth-aware fetch with 401 handling and token refresh ---\n\nlet isRefreshing = false;\nlet pendingRequests: Array<() => void> = [];\n\nasync function refreshTokenIfNeeded(): Promise<void> {\n  if (isRefreshing) {\n    await new Promise<void>((resolve) => pendingRequests.push(resolve));\n    return;\n  }\n  isRefreshing = true;\n  try {\n    const state = authStorage.load();\n    if (!state.refreshToken) throw new Error('No refresh token');\n    const res = await apiRequest(`${API_BASE_URL}/api/auth/refresh`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ refresh_token: state.refreshToken })\n    });\n    if (!res.ok) throw new Error('Refresh failed');\n    const data = await res.json();\n    const newState = {\n      user: data?.data?.user || state.user,\n      accessToken: data?.data?.access_token || null,\n      refreshToken: data?.data?.refresh_token || state.refreshToken\n    };\n    authStorage.save(newState);\n  } finally {\n    isRefreshing = false;\n    pendingRequests.forEach((resolve) => resolve());\n    pendingRequests = [];\n  }\n}\n\nexport async function apiFetch(path: string, init: RequestInit = {}) {\n  const url = `${API_BASE_URL}${path}`;\n  const state = authStorage.load();\n  const headers = new Headers(init.headers || {});\n  if (state.accessToken && !headers.has('Authorization')) {\n    headers.set('Authorization', `Bearer ${state.accessToken}`);\n  }\n  try {\n    const res = await apiRequest(url, { ...init, headers });\n    if (res.status !== 401) return res;\n    // Try refresh and retry once\n    await refreshTokenIfNeeded();\n    const refreshed = authStorage.load();\n    const retryHeaders = new Headers(init.headers || {});\n    if (refreshed.accessToken) retryHeaders.set('Authorization', `Bearer ${refreshed.accessToken}`);\n    return apiRequest(url, { ...init, headers: retryHeaders });\n  } catch (e) {\n    throw e;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}