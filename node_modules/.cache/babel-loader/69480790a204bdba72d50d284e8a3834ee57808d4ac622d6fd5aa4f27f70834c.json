{"ast":null,"code":"import React,{useState,useEffect,useRef}from'react';import{getCategoryColor,getCategoryColorDark,getCategoryColorMuted}from'./utils/categoryColors';import{AppHeader}from'./components/AppHeader';import{Timeline}from'./components/Timeline';import{Tooltips}from'./components/Tooltips';import{useTimelineData}from'./hooks/useTimelineData';import{generateCenturyBoundaries,getFirstCountry}from'./utils/timelineUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const[hoveredPerson,setHoveredPerson]=useState(null);const[mousePosition,setMousePosition]=useState({x:0,y:0});const[showTooltip,setShowTooltip]=useState(false);const[hoveredAchievement,setHoveredAchievement]=useState(null);const[achievementTooltipPosition,setAchievementTooltipPosition]=useState({x:0,y:0});const[showAchievementTooltip,setShowAchievementTooltip]=useState(false);const[isScrolled,setIsScrolled]=useState(false);const[activeAchievementMarker,setActiveAchievementMarker]=useState(null);const hoverTimerRef=useRef(null);const[showControls,setShowControls]=useState(true);const[filters,setFilters]=useState(()=>{const savedFilters=localStorage.getItem('chronoline-filters');if(savedFilters){const parsed=JSON.parse(savedFilters);return{categories:parsed.categories||[],countries:parsed.countries||[],timeRange:parsed.timeRange||{start:-800,end:2000},showAchievements:parsed.showAchievements!==undefined?parsed.showAchievements:true};}return{categories:[],countries:[],timeRange:{start:-800,end:2000},showAchievements:true};});// Состояние для типа группировки\nconst[groupingType,setGroupingType]=useState(()=>{const savedGrouping=localStorage.getItem('chronoline-grouping');return savedGrouping||'category';});// Сохраняем фильтры в localStorage при изменении\nuseEffect(()=>{localStorage.setItem('chronoline-filters',JSON.stringify(filters));},[filters]);// Сохраняем тип группировки в localStorage при изменении\nuseEffect(()=>{localStorage.setItem('chronoline-grouping',groupingType);},[groupingType]);// Очищаем таймер при размонтировании компонента\nuseEffect(()=>{return()=>{if(hoverTimerRef.current){clearTimeout(hoverTimerRef.current);}};},[]);// Используем кастомный хук для загрузки данных\nconst{persons,allCategories,allCountries,isLoading}=useTimelineData(filters);// Состояние для полей ввода годов\nconst[yearInputs,setYearInputs]=useState({start:filters.timeRange.start.toString(),end:filters.timeRange.end.toString()});// Функция для применения фильтра по году\nconst applyYearFilter=(field,value)=>{const numValue=parseInt(value)||(field==='start'?-800:2000);setFilters(prev=>({...prev,timeRange:{...prev.timeRange,[field]:numValue}}));};// Функция для обработки нажатия Enter\nconst handleYearKeyPress=(field,e)=>{if(e.key==='Enter'){var _e$currentTarget$pare,_e$currentTarget$pare2;applyYearFilter(field,e.currentTarget.value);// Переводим фокус на следующий элемент\nconst inputs=(_e$currentTarget$pare=e.currentTarget.parentElement)===null||_e$currentTarget$pare===void 0?void 0:(_e$currentTarget$pare2=_e$currentTarget$pare.parentElement)===null||_e$currentTarget$pare2===void 0?void 0:_e$currentTarget$pare2.querySelectorAll('input');if(inputs){const currentIndex=Array.from(inputs).indexOf(e.currentTarget);const nextInput=inputs[currentIndex+1];if(nextInput){nextInput.focus();}}}};// Функция для сброса всех фильтров\nconst resetAllFilters=()=>{setFilters({categories:[],countries:[],timeRange:{start:-800,end:2000},showAchievements:true});setYearInputs({start:'-800',end:'2000'});};// Функция для получения приоритета категории\nconst getCategoryPriority=category=>{return allCategories.indexOf(category);};// Функция для получения цвета группы в зависимости от типа группировки\nconst getGroupColor=groupName=>{if(groupingType==='category'){return getCategoryColor(groupName);}else if(groupingType==='country'){// Для стран используем другой набор цветов\nconst countryColors=['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#34495e','#16a085','#8e44ad','#27ae60','#2980b9','#f1c40f','#e74c3c','#95a5a6'];const index=allCountries.indexOf(groupName);return countryColors[index%countryColors.length];}return'#95a5a6';// серый цвет по умолчанию\n};// Функция для получения цвета группы (темный вариант)\nconst getGroupColorDark=groupName=>{if(groupingType==='category'){return getCategoryColorDark(groupName);}else if(groupingType==='country'){// Для стран используем темные варианты цветов\nconst countryColorsDark=['#c0392b','#2980b9','#27ae60','#d68910','#8e44ad','#16a085','#d35400','#2c3e50','#138d75','#7d3c98','#229954','#1f618d','#d4ac0f','#c0392b','#7f8c8d'];const index=allCountries.indexOf(groupName);return countryColorsDark[index%countryColorsDark.length];}return'#7f8c8d';// темно-серый цвет по умолчанию\n};// Функция для получения цвета группы (приглушенный вариант)\nconst getGroupColorMuted=groupName=>{if(groupingType==='category'){return getCategoryColorMuted(groupName);}else if(groupingType==='country'){// Для стран используем приглушенные варианты цветов\nconst countryColorsMuted=['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#34495e','#16a085','#8e44ad','#27ae60','#2980b9','#f1c40f','#e74c3c','#95a5a6'];const index=allCountries.indexOf(groupName);return countryColorsMuted[index%countryColorsMuted.length];}return'#95a5a6';// серый цвет по умолчанию\n};// Функция для получения значения группы для персонажа\nconst getPersonGroup=person=>{if(groupingType==='category'){return person.category;}else if(groupingType==='country'){return getFirstCountry(person.country);}return person.category;// по умолчанию\n};// Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\nconst sortedData=[...persons].sort((a,b)=>{if(groupingType==='category'){// Сначала сортируем по категориям\nconst categoryDiff=getCategoryPriority(a.category)-getCategoryPriority(b.category);if(categoryDiff!==0){return categoryDiff;}}else if(groupingType==='country'){// Сначала сортируем по странам (берем первую страну из списка)\nconst countryDiff=allCountries.indexOf(getFirstCountry(a.country))-allCountries.indexOf(getFirstCountry(b.country));if(countryDiff!==0){return countryDiff;}}// Затем по году рождения\nreturn a.birthYear-b.birthYear;});// Отслеживаем скролл\nuseEffect(()=>{const handleScroll=()=>{const scrollTop=window.pageYOffset||document.documentElement.scrollTop;setIsScrolled(scrollTop>50);};window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);// Вычисляем реальный диапазон лет из отфильтрованных данных\nconst minYear=Math.min(...sortedData.map(p=>p.birthYear),filters.timeRange.start);const maxYear=Math.max(...sortedData.map(p=>p.deathYear),filters.timeRange.end);const totalYears=maxYear-minYear;// Настройки масштаба\nconst pixelsPerYear=3;// 3 пикселя на год\nconst LEFT_PADDING_PX=30;// отступ слева, чтобы крайняя левая подпись не упиралась в край\nconst timelineWidth=totalYears*pixelsPerYear+LEFT_PADDING_PX;// Генерируем границы веков\nconst centuryBoundaries=generateCenturyBoundaries(minYear,maxYear);// Алгоритм размещения полосок на строках с полной группировкой по категориям\nconst calculateRowPlacement=people=>{const rows=[];if(groupingType==='none'){// Без группировки - просто размещаем всех в строки\nconst allRows=[];people.forEach(person=>{let placed=false;// Проверяем каждую существующую строку\nfor(let rowIndex=0;rowIndex<allRows.length;rowIndex++){const row=allRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){allRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){allRows.push([person]);}});return allRows;}// Группировка по категориям или странам\nconst groupField=groupingType==='category'?'category':'country';const allGroups=groupingType==='category'?allCategories:allCountries;const groups={};// Группируем людей по выбранному полю\npeople.forEach(person=>{let groupValue;if(groupField==='country'){// Для стран берем первую из списка, если есть несколько через \"/\"\ngroupValue=getFirstCountry(person.country);}else{groupValue=person[groupField];}if(!groups[groupValue]){groups[groupValue]=[];}groups[groupValue].push(person);});// Обрабатываем каждую группу в заданном порядке\nallGroups.forEach(groupValue=>{if(groups[groupValue]){const groupPeople=groups[groupValue];const groupRows=[];// Размещаем людей данной группы в отдельные строки\ngroupPeople.forEach(person=>{let placed=false;// Проверяем каждую существующую строку для этой группы\nfor(let rowIndex=0;rowIndex<groupRows.length;rowIndex++){const row=groupRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){groupRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){groupRows.push([person]);}});// Добавляем строки данной группы к общему списку\nrows.push(...groupRows);// Добавляем пустую строку для визуального разделения (кроме последней группы)\nif(groupValue!==allGroups[allGroups.length-1]){rows.push([]);}}});return rows;};// Получаем размещение по строкам\nconst rowPlacement=calculateRowPlacement(sortedData);// Вычисляем общую высоту с учетом пустых строк\nconst totalHeight=rowPlacement.reduce((height,row)=>{return height+(row.length===0?20:70);// 20px для пустых строк, 70px для обычных (60px + 10px margin)\n},0);// Функция для создания разделителей категорий\n// Высота строки и отступ вниз для непустой строки\nconst ROW_HEIGHT=60;const ROW_MARGIN=10;// margin-bottom, используется только для непустых строк\nconst EMPTY_ROW_HEIGHT=20;// Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\nconst rowTops=[];(()=>{let acc=0;rowPlacement.forEach(row=>{rowTops.push(acc);if(row.length===0){acc+=EMPTY_ROW_HEIGHT;}else{acc+=ROW_HEIGHT+ROW_MARGIN;}});})();const createCategoryDividers=()=>{if(groupingType==='none'){return[];// Без группировки нет разделителей\n}const dividers=[];let currentGroup='';rowPlacement.forEach((row,rowIndex)=>{if(row.length>0){const firstPersonInRow=row[0];let currentGroupValue;if(groupingType==='category'){currentGroupValue=firstPersonInRow.category;}else if(groupingType==='country'){// Для стран берем первую из списка\ncurrentGroupValue=getFirstCountry(firstPersonInRow.country);}else{currentGroupValue=firstPersonInRow.category;}if(currentGroupValue!==currentGroup){if(currentGroup!==''){// закрываем предыдущую группу\ndividers.push({category:currentGroup,top:rowTops[rowIndex]-5});}currentGroup=currentGroupValue;}}});// Добавляем разделитель для последней группы\nif(currentGroup!==''){dividers.push({category:currentGroup,top:rowTops[rowPlacement.length-1]-5});}return dividers;};const categoryDividers=createCategoryDividers();return/*#__PURE__*/_jsxs(\"div\",{className:\"app\",children:[/*#__PURE__*/_jsx(AppHeader,{isScrolled:isScrolled,showControls:showControls,setShowControls:setShowControls,filters:filters,setFilters:setFilters,groupingType:groupingType,setGroupingType:setGroupingType,allCategories:allCategories,allCountries:allCountries,yearInputs:yearInputs,setYearInputs:setYearInputs,applyYearFilter:applyYearFilter,handleYearKeyPress:handleYearKeyPress,resetAllFilters:resetAllFilters,getCategoryColor:getCategoryColor}),/*#__PURE__*/_jsx(Timeline,{isLoading:isLoading,timelineWidth:timelineWidth,totalHeight:totalHeight,centuryBoundaries:centuryBoundaries,minYear:minYear,pixelsPerYear:pixelsPerYear,LEFT_PADDING_PX:LEFT_PADDING_PX,rowPlacement:rowPlacement,filters:filters,groupingType:groupingType,categoryDividers:categoryDividers,getGroupColor:getGroupColor,getGroupColorDark:getGroupColorDark,getGroupColorMuted:getGroupColorMuted,getPersonGroup:getPersonGroup,hoveredPerson:hoveredPerson,setHoveredPerson:setHoveredPerson,mousePosition:mousePosition,setMousePosition:setMousePosition,showTooltip:showTooltip,setShowTooltip:setShowTooltip,activeAchievementMarker:activeAchievementMarker,setActiveAchievementMarker:setActiveAchievementMarker,hoveredAchievement:hoveredAchievement,setHoveredAchievement:setHoveredAchievement,achievementTooltipPosition:achievementTooltipPosition,setAchievementTooltipPosition:setAchievementTooltipPosition,showAchievementTooltip:showAchievementTooltip,setShowAchievementTooltip:setShowAchievementTooltip,hoverTimerRef:hoverTimerRef}),/*#__PURE__*/_jsx(Tooltips,{hoveredPerson:hoveredPerson,showTooltip:showTooltip,mousePosition:mousePosition,hoveredAchievement:hoveredAchievement,showAchievementTooltip:showAchievementTooltip,achievementTooltipPosition:achievementTooltipPosition,getGroupColor:getGroupColor,getPersonGroup:getPersonGroup,getCategoryColor:getCategoryColor})]});}export default App;","map":{"version":3,"names":["React","useState","useEffect","useRef","getCategoryColor","getCategoryColorDark","getCategoryColorMuted","AppHeader","Timeline","Tooltips","useTimelineData","generateCenturyBoundaries","getFirstCountry","jsx","_jsx","jsxs","_jsxs","App","hoveredPerson","setHoveredPerson","mousePosition","setMousePosition","x","y","showTooltip","setShowTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","setShowAchievementTooltip","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","hoverTimerRef","showControls","setShowControls","filters","setFilters","savedFilters","localStorage","getItem","parsed","JSON","parse","categories","countries","timeRange","start","end","showAchievements","undefined","groupingType","setGroupingType","savedGrouping","setItem","stringify","current","clearTimeout","persons","allCategories","allCountries","isLoading","yearInputs","setYearInputs","toString","applyYearFilter","field","value","numValue","parseInt","prev","handleYearKeyPress","e","key","_e$currentTarget$pare","_e$currentTarget$pare2","currentTarget","inputs","parentElement","querySelectorAll","currentIndex","Array","from","indexOf","nextInput","focus","resetAllFilters","getCategoryPriority","category","getGroupColor","groupName","countryColors","index","length","getGroupColorDark","countryColorsDark","getGroupColorMuted","countryColorsMuted","getPersonGroup","person","country","sortedData","sort","a","b","categoryDiff","countryDiff","birthYear","handleScroll","scrollTop","window","pageYOffset","document","documentElement","addEventListener","removeEventListener","minYear","Math","min","map","p","maxYear","max","deathYear","totalYears","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","top","categoryDividers","className","children"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react'\nimport { Person } from './types'\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport './App.css'\n\nfunction App() {\n  const [hoveredPerson, setHoveredPerson] = useState<Person | null>(null)\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n  const [showTooltip, setShowTooltip] = useState(false)\n  const [hoveredAchievement, setHoveredAchievement] = useState<{ person: Person; year: number; index: number } | null>(null)\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({ x: 0, y: 0 })\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false)\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const hoverTimerRef = useRef<NodeJS.Timeout | null>(null)\n  const [showControls, setShowControls] = useState(true)\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || { start: -800, end: 2000 },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true\n      };\n    }\n    return {\n      categories: [] as string[],\n      countries: [] as string[],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true\n    };\n  })\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState<'category' | 'country' | 'none'>(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping as 'category' | 'country' | 'none' || 'category';\n  })\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      if (hoverTimerRef.current) {\n        clearTimeout(hoverTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  })\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = (field: 'start' | 'end', value: string) => {\n    const numValue = parseInt(value) || (field === 'start' ? -800 : 2000)\n    setFilters(prev => ({\n      ...prev,\n      timeRange: { ...prev.timeRange, [field]: numValue }\n    }))\n  }\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field: 'start' | 'end', e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      applyYearFilter(field, e.currentTarget.value)\n      // Переводим фокус на следующий элемент\n      const inputs = e.currentTarget.parentElement?.parentElement?.querySelectorAll('input')\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget)\n        const nextInput = inputs[currentIndex + 1] as HTMLInputElement\n        if (nextInput) {\n          nextInput.focus()\n        }\n      }\n    }\n  }\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true\n    })\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    })\n  }\n\n    // Функция для получения приоритета категории\n  const getCategoryPriority = (category: string) => {\n    return allCategories.indexOf(category)\n  }\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColors[index % countryColors.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = [\n        '#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad',\n        '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98',\n        '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsDark[index % countryColorsDark.length]\n    }\n    return '#7f8c8d' // темно-серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsMuted[index % countryColorsMuted.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = (person: Person) => {\n    if (groupingType === 'category') {\n      return person.category\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country)\n    }\n    return person.category // по умолчанию\n  }\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category)\n      if (categoryDiff !== 0) {\n        return categoryDiff\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country))\n      if (countryDiff !== 0) {\n        return countryDiff\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear\n  })\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n  const totalYears = maxYear - minYear\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Генерируем границы веков\n  const centuryBoundaries = generateCenturyBoundaries(minYear, maxYear)\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = (people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData)\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0)\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops: number[] = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  };\n\n  const categoryDividers = createCategoryDividers();\n\n  return (\n    <div className=\"app\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getCategoryColor}\n      />\n      \n      <Timeline\n        isLoading={isLoading}\n        timelineWidth={timelineWidth}\n        totalHeight={totalHeight}\n        centuryBoundaries={centuryBoundaries}\n        minYear={minYear}\n        pixelsPerYear={pixelsPerYear}\n        LEFT_PADDING_PX={LEFT_PADDING_PX}\n        rowPlacement={rowPlacement}\n        filters={filters}\n              groupingType={groupingType}\n        categoryDividers={categoryDividers}\n        getGroupColor={getGroupColor}\n        getGroupColorDark={getGroupColorDark}\n        getGroupColorMuted={getGroupColorMuted}\n        getPersonGroup={getPersonGroup}\n        hoveredPerson={hoveredPerson}\n        setHoveredPerson={setHoveredPerson}\n        mousePosition={mousePosition}\n        setMousePosition={setMousePosition}\n        showTooltip={showTooltip}\n        setShowTooltip={setShowTooltip}\n        activeAchievementMarker={activeAchievementMarker}\n        setActiveAchievementMarker={setActiveAchievementMarker}\n        hoveredAchievement={hoveredAchievement}\n        setHoveredAchievement={setHoveredAchievement}\n        achievementTooltipPosition={achievementTooltipPosition}\n        setAchievementTooltipPosition={setAchievementTooltipPosition}\n        showAchievementTooltip={showAchievementTooltip}\n        setShowAchievementTooltip={setShowAchievementTooltip}\n        hoverTimerRef={hoverTimerRef}\n      />\n\n      <Tooltips\n        hoveredPerson={hoveredPerson}\n        showTooltip={showTooltip}\n        mousePosition={mousePosition}\n        hoveredAchievement={hoveredAchievement}\n        showAchievementTooltip={showAchievementTooltip}\n        achievementTooltipPosition={achievementTooltipPosition}\n        getGroupColor={getGroupColor}\n        getPersonGroup={getPersonGroup}\n        getCategoryColor={getCategoryColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}