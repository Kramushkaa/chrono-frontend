{"ast":null,"code":"import React,{useState,useEffect,useRef,useCallback}from'react';import{getCategoryColor,getCategoryColorDark,getCategoryColorMuted}from'./utils/categoryColors';import{AppHeader}from'./components/AppHeader';import{Timeline}from'./components/Timeline';import{Tooltips}from'./components/Tooltips';import{MobilePersonPanel}from'./components/MobilePersonPanel';import{useTimelineData}from'./hooks/useTimelineData';import{generateCenturyBoundaries,getFirstCountry}from'./utils/timelineUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const[hoveredPerson,setHoveredPerson]=useState(null);const[mousePosition,setMousePosition]=useState({x:0,y:0});const[showTooltip,setShowTooltip]=useState(false);const[hoveredAchievement,setHoveredAchievement]=useState(null);const[achievementTooltipPosition,setAchievementTooltipPosition]=useState({x:0,y:0});const[showAchievementTooltip,setShowAchievementTooltip]=useState(false);const[isScrolled,setIsScrolled]=useState(false);const[activeAchievementMarker,setActiveAchievementMarker]=useState(null);const[selectedPerson,setSelectedPerson]=useState(null);const hoverTimerRef=useRef(null);const[showControls,setShowControls]=useState(true);const[filters,setFilters]=useState(()=>{const savedFilters=localStorage.getItem('chronoline-filters');if(savedFilters){const parsed=JSON.parse(savedFilters);return{categories:parsed.categories||[],countries:parsed.countries||[],timeRange:parsed.timeRange||{start:-800,end:2000},showAchievements:parsed.showAchievements!==undefined?parsed.showAchievements:true,hideEmptyCenturies:parsed.hideEmptyCenturies!==undefined?parsed.hideEmptyCenturies:false};}return{categories:[],countries:[],timeRange:{start:-800,end:2000},showAchievements:true,hideEmptyCenturies:false};});// Состояние для типа группировки\nconst[groupingType,setGroupingType]=useState(()=>{const savedGrouping=localStorage.getItem('chronoline-grouping');return savedGrouping||'category';});// Сохраняем фильтры в localStorage при изменении\nuseEffect(()=>{localStorage.setItem('chronoline-filters',JSON.stringify(filters));},[filters]);// Сохраняем тип группировки в localStorage при изменении\nuseEffect(()=>{localStorage.setItem('chronoline-grouping',groupingType);},[groupingType]);// Очищаем таймер при размонтировании компонента\nuseEffect(()=>{return()=>{const timer=hoverTimerRef.current;if(timer){clearTimeout(timer);}};},[]);// Используем кастомный хук для загрузки данных\nconst{persons,allCategories,allCountries,isLoading}=useTimelineData(filters);// Состояние для полей ввода годов\nconst[yearInputs,setYearInputs]=useState({start:filters.timeRange.start.toString(),end:filters.timeRange.end.toString()});// Состояния для интерактивной полоски диапазона\nconst[isDraggingSlider,setIsDraggingSlider]=useState(false);const[draggedHandle,setDraggedHandle]=useState(null);const[sliderRect,setSliderRect]=useState(null);// Функция для применения фильтра по году\nconst applyYearFilter=useCallback((field,value)=>{const parsed=parseInt(value);const numValue=isNaN(parsed)?field==='start'?-800:2000:parsed;setFilters(prev=>({...prev,timeRange:{...prev.timeRange,[field]:numValue}}));},[]);// Функция для обработки нажатия Enter\nconst handleYearKeyPress=(field,e)=>{if(e.key==='Enter'){var _e$currentTarget$pare,_e$currentTarget$pare2;applyYearFilter(field,e.currentTarget.value);// Переводим фокус на следующий элемент\nconst inputs=(_e$currentTarget$pare=e.currentTarget.parentElement)===null||_e$currentTarget$pare===void 0?void 0:(_e$currentTarget$pare2=_e$currentTarget$pare.parentElement)===null||_e$currentTarget$pare2===void 0?void 0:_e$currentTarget$pare2.querySelectorAll('input');if(inputs){const currentIndex=Array.from(inputs).indexOf(e.currentTarget);const nextInput=inputs[currentIndex+1];if(nextInput){nextInput.focus();}}}};// Функции для интерактивной полоски диапазона\nconst handleSliderMouseDown=(e,handle)=>{var _e$currentTarget$pare3;e.preventDefault();setIsDraggingSlider(true);setDraggedHandle(handle);const sliderElement=(_e$currentTarget$pare3=e.currentTarget.parentElement)===null||_e$currentTarget$pare3===void 0?void 0:_e$currentTarget$pare3.parentElement;if(sliderElement){setSliderRect(sliderElement.getBoundingClientRect());}};const handleSliderMouseMove=useCallback(e=>{if(!isDraggingSlider||!draggedHandle||!sliderRect)return;const rect=sliderRect;const clientX='touches'in e?e.touches[0].clientX:e.clientX;const x=clientX-rect.left;const percentage=Math.max(0,Math.min(100,x/rect.width*100));// Преобразуем процент в год (от -800 до 2000)\nconst totalRange=2800;// 2000 - (-800)\nconst year=Math.round(-800+percentage/100*totalRange);// Ограничиваем значения\nconst startYear=parseYearValue(yearInputs.start,-800);const endYear=parseYearValue(yearInputs.end,2000);let newYear=year;if(draggedHandle==='start'){newYear=Math.max(-800,Math.min(endYear-100,year));setYearInputs(prev=>({...prev,start:newYear.toString()}));applyYearFilter('start',newYear.toString());}else{newYear=Math.max(startYear+100,Math.min(2000,year));setYearInputs(prev=>({...prev,end:newYear.toString()}));applyYearFilter('end',newYear.toString());}},[isDraggingSlider,draggedHandle,sliderRect,yearInputs,applyYearFilter]);const handleSliderMouseUp=useCallback(()=>{setIsDraggingSlider(false);setDraggedHandle(null);setSliderRect(null);},[]);const parseYearValue=(value,defaultValue)=>{const parsed=parseInt(value);return isNaN(parsed)?defaultValue:parsed;};// Добавляем обработчики событий мыши и touch\nuseEffect(()=>{if(isDraggingSlider){document.addEventListener('mousemove',handleSliderMouseMove);document.addEventListener('mouseup',handleSliderMouseUp);document.addEventListener('touchmove',handleSliderMouseMove);document.addEventListener('touchend',handleSliderMouseUp);return()=>{document.removeEventListener('mousemove',handleSliderMouseMove);document.removeEventListener('mouseup',handleSliderMouseUp);document.removeEventListener('touchmove',handleSliderMouseMove);document.removeEventListener('touchend',handleSliderMouseUp);};}},[isDraggingSlider,handleSliderMouseMove,handleSliderMouseUp]);// Функция для сброса всех фильтров\nconst resetAllFilters=()=>{setFilters({categories:[],countries:[],timeRange:{start:-800,end:2000},showAchievements:true,hideEmptyCenturies:false});setYearInputs({start:'-800',end:'2000'});};// Функция для получения приоритета категории\nconst getCategoryPriority=category=>{return allCategories.indexOf(category);};// Функция для получения цвета группы в зависимости от типа группировки\nconst getGroupColor=groupName=>{if(groupingType==='category'){return getCategoryColor(groupName);}else if(groupingType==='country'){// Для стран используем другой набор цветов\nconst countryColors=['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#34495e','#16a085','#8e44ad','#27ae60','#2980b9','#f1c40f','#e74c3c','#95a5a6'];const index=allCountries.indexOf(groupName);return countryColors[index%countryColors.length];}return'#95a5a6';// серый цвет по умолчанию\n};// Функция для получения цвета группы (темный вариант)\nconst getGroupColorDark=groupName=>{if(groupingType==='category'){return getCategoryColorDark(groupName);}else if(groupingType==='country'){// Для стран используем темные варианты цветов\nconst countryColorsDark=['#c0392b','#2980b9','#27ae60','#d68910','#8e44ad','#16a085','#d35400','#2c3e50','#138d75','#7d3c98','#229954','#1f618d','#d4ac0f','#c0392b','#7f8c8d'];const index=allCountries.indexOf(groupName);return countryColorsDark[index%countryColorsDark.length];}return'#7f8c8d';// темно-серый цвет по умолчанию\n};// Функция для получения цвета группы (приглушенный вариант)\nconst getGroupColorMuted=groupName=>{if(groupingType==='category'){return getCategoryColorMuted(groupName);}else if(groupingType==='country'){// Для стран используем приглушенные варианты цветов\nconst countryColorsMuted=['#e74c3c','#3498db','#2ecc71','#f39c12','#9b59b6','#1abc9c','#e67e22','#34495e','#16a085','#8e44ad','#27ae60','#2980b9','#f1c40f','#e74c3c','#95a5a6'];const index=allCountries.indexOf(groupName);return countryColorsMuted[index%countryColorsMuted.length];}return'#95a5a6';// серый цвет по умолчанию\n};// Функция для получения значения группы для персонажа\nconst getPersonGroup=person=>{if(groupingType==='category'){return person.category;}else if(groupingType==='country'){return getFirstCountry(person.country);}return person.category;// по умолчанию\n};// Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\nconst sortedData=[...persons].sort((a,b)=>{if(groupingType==='category'){// Сначала сортируем по категориям\nconst categoryDiff=getCategoryPriority(a.category)-getCategoryPriority(b.category);if(categoryDiff!==0){return categoryDiff;}}else if(groupingType==='country'){// Сначала сортируем по странам (берем первую страну из списка)\nconst countryDiff=allCountries.indexOf(getFirstCountry(a.country))-allCountries.indexOf(getFirstCountry(b.country));if(countryDiff!==0){return countryDiff;}}// Затем по году рождения\nreturn a.birthYear-b.birthYear;});// Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\nuseEffect(()=>{if(filters.hideEmptyCenturies&&sortedData.length>0){// Вычисляем эффективный диапазон на основе отфильтрованных данных\nconst effectiveMinYear=Math.min(...sortedData.map(p=>p.birthYear));const effectiveMaxYear=Math.max(...sortedData.map(p=>p.deathYear));// Проверяем, есть ли активные фильтры (категории или страны)\nconst hasActiveFilters=filters.categories.length>0||filters.countries.length>0;let newTimeRange={...filters.timeRange};if(hasActiveFilters){// Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\nnewTimeRange={start:Math.max(filters.timeRange.start,effectiveMinYear),end:Math.min(filters.timeRange.end,effectiveMaxYear)};}else{// Если нет активных фильтров, НЕ сужаем диапазон\n// Пользователь может хотеть видеть данные за пределами текущего диапазона\nnewTimeRange=filters.timeRange;}// Обновляем только если диапазон изменился\nif(newTimeRange.start!==filters.timeRange.start||newTimeRange.end!==filters.timeRange.end){setFilters(prev=>({...prev,timeRange:newTimeRange}));// Обновляем поля ввода\nsetYearInputs({start:newTimeRange.start.toString(),end:newTimeRange.end.toString()});}}},[filters.hideEmptyCenturies,sortedData,filters.categories,filters.countries,filters.timeRange]);// Отслеживаем скролл\nuseEffect(()=>{const handleScroll=()=>{const scrollTop=window.pageYOffset||document.documentElement.scrollTop;setIsScrolled(scrollTop>50);};window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);// Вычисляем реальный диапазон лет из отфильтрованных данных\nconst minYear=Math.min(...sortedData.map(p=>p.birthYear),filters.timeRange.start);const maxYear=Math.max(...sortedData.map(p=>p.deathYear),filters.timeRange.end);const totalYears=maxYear-minYear;// Настройки масштаба\nconst pixelsPerYear=3;// 3 пикселя на год\nconst LEFT_PADDING_PX=30;// отступ слева, чтобы крайняя левая подпись не упиралась в край\nconst timelineWidth=totalYears*pixelsPerYear+LEFT_PADDING_PX;// Генерируем границы веков\n// Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\nconst effectiveMinYear=filters.hideEmptyCenturies?Math.min(...sortedData.map(p=>p.birthYear)):minYear;const effectiveMaxYear=filters.hideEmptyCenturies?Math.max(...sortedData.map(p=>p.deathYear)):maxYear;const centuryBoundaries=generateCenturyBoundaries(effectiveMinYear,effectiveMaxYear);// Алгоритм размещения полосок на строках с полной группировкой по категориям\nconst calculateRowPlacement=people=>{const rows=[];if(groupingType==='none'){// Без группировки - просто размещаем всех в строки\nconst allRows=[];people.forEach(person=>{let placed=false;// Проверяем каждую существующую строку\nfor(let rowIndex=0;rowIndex<allRows.length;rowIndex++){const row=allRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){allRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){allRows.push([person]);}});return allRows;}// Группировка по категориям или странам\nconst groupField=groupingType==='category'?'category':'country';const allGroups=groupingType==='category'?allCategories:allCountries;const groups={};// Группируем людей по выбранному полю\npeople.forEach(person=>{let groupValue;if(groupField==='country'){// Для стран берем первую из списка, если есть несколько через \"/\"\ngroupValue=getFirstCountry(person.country);}else{groupValue=person[groupField];}if(!groups[groupValue]){groups[groupValue]=[];}groups[groupValue].push(person);});// Обрабатываем каждую группу в заданном порядке\nallGroups.forEach(groupValue=>{if(groups[groupValue]){const groupPeople=groups[groupValue];const groupRows=[];// Размещаем людей данной группы в отдельные строки\ngroupPeople.forEach(person=>{let placed=false;// Проверяем каждую существующую строку для этой группы\nfor(let rowIndex=0;rowIndex<groupRows.length;rowIndex++){const row=groupRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){groupRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){groupRows.push([person]);}});// Добавляем строки данной группы к общему списку\nrows.push(...groupRows);// Добавляем пустую строку для визуального разделения (кроме последней группы)\nif(groupValue!==allGroups[allGroups.length-1]){rows.push([]);}}});return rows;};// Получаем размещение по строкам\nconst rowPlacement=calculateRowPlacement(sortedData);// Вычисляем общую высоту с учетом пустых строк\nconst totalHeight=rowPlacement.reduce((height,row)=>{return height+(row.length===0?20:70);// 20px для пустых строк, 70px для обычных (60px + 10px margin)\n},0);// Функция для создания разделителей категорий\n// Высота строки и отступ вниз для непустой строки\nconst ROW_HEIGHT=60;const ROW_MARGIN=10;// margin-bottom, используется только для непустых строк\nconst EMPTY_ROW_HEIGHT=20;// Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\nconst rowTops=[];(()=>{let acc=0;rowPlacement.forEach(row=>{rowTops.push(acc);if(row.length===0){acc+=EMPTY_ROW_HEIGHT;}else{acc+=ROW_HEIGHT+ROW_MARGIN;}});})();const createCategoryDividers=()=>{if(groupingType==='none'){return[];// Без группировки нет разделителей\n}const dividers=[];let currentGroup='';rowPlacement.forEach((row,rowIndex)=>{if(row.length>0){const firstPersonInRow=row[0];let currentGroupValue;if(groupingType==='category'){currentGroupValue=firstPersonInRow.category;}else if(groupingType==='country'){// Для стран берем первую из списка\ncurrentGroupValue=getFirstCountry(firstPersonInRow.country);}else{currentGroupValue=firstPersonInRow.category;}if(currentGroupValue!==currentGroup){if(currentGroup!==''){// закрываем предыдущую группу\ndividers.push({category:currentGroup,top:rowTops[rowIndex]-5});}currentGroup=currentGroupValue;}}});// Добавляем разделитель для последней группы\nif(currentGroup!==''){dividers.push({category:currentGroup,top:rowTops[rowPlacement.length-1]-5});}return dividers;};const categoryDividers=createCategoryDividers();return/*#__PURE__*/_jsxs(\"div\",{className:\"app\",id:\"chronoline-app\",role:\"main\",\"aria-label\":\"Chronoline - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",children:[/*#__PURE__*/_jsx(AppHeader,{isScrolled:isScrolled,showControls:showControls,setShowControls:setShowControls,filters:filters,setFilters:setFilters,groupingType:groupingType,setGroupingType:setGroupingType,allCategories:allCategories,allCountries:allCountries,yearInputs:yearInputs,setYearInputs:setYearInputs,applyYearFilter:applyYearFilter,handleYearKeyPress:handleYearKeyPress,resetAllFilters:resetAllFilters,getCategoryColor:getCategoryColor,sortedData:sortedData,handleSliderMouseDown:handleSliderMouseDown,isDraggingSlider:isDraggingSlider}),/*#__PURE__*/_jsx(\"main\",{className:\"timeline-container\",id:\"timeline-main\",role:\"region\",\"aria-label\":\"\\u0412\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",children:/*#__PURE__*/_jsx(Timeline,{isLoading:isLoading,timelineWidth:timelineWidth,totalHeight:totalHeight,centuryBoundaries:centuryBoundaries,minYear:minYear,pixelsPerYear:pixelsPerYear,LEFT_PADDING_PX:LEFT_PADDING_PX,rowPlacement:rowPlacement,filters:filters,groupingType:groupingType,categoryDividers:categoryDividers,getGroupColor:getGroupColor,getGroupColorDark:getGroupColorDark,getGroupColorMuted:getGroupColorMuted,getPersonGroup:getPersonGroup,hoveredPerson:hoveredPerson,setHoveredPerson:setHoveredPerson,mousePosition:mousePosition,setMousePosition:setMousePosition,showTooltip:showTooltip,setShowTooltip:setShowTooltip,activeAchievementMarker:activeAchievementMarker,setActiveAchievementMarker:setActiveAchievementMarker,hoveredAchievement:hoveredAchievement,setHoveredAchievement:setHoveredAchievement,achievementTooltipPosition:achievementTooltipPosition,setAchievementTooltipPosition:setAchievementTooltipPosition,showAchievementTooltip:showAchievementTooltip,setShowAchievementTooltip:setShowAchievementTooltip,hoverTimerRef:hoverTimerRef,sortedData:sortedData,selectedPerson:selectedPerson,setSelectedPerson:setSelectedPerson})}),/*#__PURE__*/_jsx(\"aside\",{className:\"tooltips-container\",id:\"tooltips-aside\",\"aria-label\":\"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",children:/*#__PURE__*/_jsx(Tooltips,{hoveredPerson:hoveredPerson,showTooltip:showTooltip,mousePosition:mousePosition,hoveredAchievement:hoveredAchievement,showAchievementTooltip:showAchievementTooltip,achievementTooltipPosition:achievementTooltipPosition,getGroupColor:getGroupColor,getPersonGroup:getPersonGroup,getCategoryColor:getCategoryColor})}),/*#__PURE__*/_jsx(MobilePersonPanel,{selectedPerson:selectedPerson,onClose:()=>setSelectedPerson(null),getGroupColor:getGroupColor,getPersonGroup:getPersonGroup,getCategoryColor:getCategoryColor})]});}export default App;","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","getCategoryColor","getCategoryColorDark","getCategoryColorMuted","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","generateCenturyBoundaries","getFirstCountry","jsx","_jsx","jsxs","_jsxs","App","hoveredPerson","setHoveredPerson","mousePosition","setMousePosition","x","y","showTooltip","setShowTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","setShowAchievementTooltip","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","hoverTimerRef","showControls","setShowControls","filters","setFilters","savedFilters","localStorage","getItem","parsed","JSON","parse","categories","countries","timeRange","start","end","showAchievements","undefined","hideEmptyCenturies","groupingType","setGroupingType","savedGrouping","setItem","stringify","timer","current","clearTimeout","persons","allCategories","allCountries","isLoading","yearInputs","setYearInputs","toString","isDraggingSlider","setIsDraggingSlider","draggedHandle","setDraggedHandle","sliderRect","setSliderRect","applyYearFilter","field","value","parseInt","numValue","isNaN","prev","handleYearKeyPress","e","key","_e$currentTarget$pare","_e$currentTarget$pare2","currentTarget","inputs","parentElement","querySelectorAll","currentIndex","Array","from","indexOf","nextInput","focus","handleSliderMouseDown","handle","_e$currentTarget$pare3","preventDefault","sliderElement","getBoundingClientRect","handleSliderMouseMove","rect","clientX","touches","left","percentage","Math","max","min","width","totalRange","year","round","startYear","parseYearValue","endYear","newYear","handleSliderMouseUp","defaultValue","document","addEventListener","removeEventListener","resetAllFilters","getCategoryPriority","category","getGroupColor","groupName","countryColors","index","length","getGroupColorDark","countryColorsDark","getGroupColorMuted","countryColorsMuted","getPersonGroup","person","country","sortedData","sort","a","b","categoryDiff","countryDiff","birthYear","effectiveMinYear","map","p","effectiveMaxYear","deathYear","hasActiveFilters","newTimeRange","handleScroll","scrollTop","window","pageYOffset","documentElement","minYear","maxYear","totalYears","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","top","categoryDividers","className","id","role","children","onClose"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react'\nimport { Person } from './types'\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport './App.css'\n\nfunction App() {\n  const [hoveredPerson, setHoveredPerson] = useState<Person | null>(null)\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n  const [showTooltip, setShowTooltip] = useState(false)\n  const [hoveredAchievement, setHoveredAchievement] = useState<{ person: Person; year: number; index: number } | null>(null)\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({ x: 0, y: 0 })\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false)\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const hoverTimerRef = useRef<NodeJS.Timeout | null>(null)\n  const [showControls, setShowControls] = useState(true)\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || { start: -800, end: 2000 },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true,\n        hideEmptyCenturies: parsed.hideEmptyCenturies !== undefined ? parsed.hideEmptyCenturies : false\n      };\n    }\n    return {\n      categories: [] as string[],\n      countries: [] as string[],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    };\n  })\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState<'category' | 'country' | 'none'>(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping as 'category' | 'country' | 'none' || 'category';\n  })\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      const timer = hoverTimerRef.current;\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  })\n\n  // Состояния для интерактивной полоски диапазона\n  const [isDraggingSlider, setIsDraggingSlider] = useState(false)\n  const [draggedHandle, setDraggedHandle] = useState<'start' | 'end' | null>(null)\n  const [sliderRect, setSliderRect] = useState<DOMRect | null>(null)\n\n\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = useCallback((field: 'start' | 'end', value: string) => {\n    const parsed = parseInt(value);\n    const numValue = isNaN(parsed) ? (field === 'start' ? -800 : 2000) : parsed;\n    setFilters(prev => ({\n      ...prev,\n      timeRange: { ...prev.timeRange, [field]: numValue }\n    }))\n  }, [])\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field: 'start' | 'end', e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      applyYearFilter(field, e.currentTarget.value)\n      // Переводим фокус на следующий элемент\n      const inputs = e.currentTarget.parentElement?.parentElement?.querySelectorAll('input')\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget)\n        const nextInput = inputs[currentIndex + 1] as HTMLInputElement\n        if (nextInput) {\n          nextInput.focus()\n        }\n      }\n    }\n  }\n\n  // Функции для интерактивной полоски диапазона\n  const handleSliderMouseDown = (e: React.MouseEvent | React.TouchEvent, handle: 'start' | 'end') => {\n    e.preventDefault()\n    setIsDraggingSlider(true)\n    setDraggedHandle(handle)\n    const sliderElement = e.currentTarget.parentElement?.parentElement\n    if (sliderElement) {\n      setSliderRect(sliderElement.getBoundingClientRect())\n    }\n  }\n\n  const handleSliderMouseMove = useCallback((e: MouseEvent | TouchEvent) => {\n    if (!isDraggingSlider || !draggedHandle || !sliderRect) return\n\n    const rect = sliderRect\n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX\n    const x = clientX - rect.left\n    const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100))\n    \n    // Преобразуем процент в год (от -800 до 2000)\n    const totalRange = 2800 // 2000 - (-800)\n    const year = Math.round(-800 + (percentage / 100) * totalRange)\n    \n    // Ограничиваем значения\n    const startYear = parseYearValue(yearInputs.start, -800)\n    const endYear = parseYearValue(yearInputs.end, 2000)\n    \n    let newYear = year\n    if (draggedHandle === 'start') {\n      newYear = Math.max(-800, Math.min(endYear - 100, year))\n      setYearInputs(prev => ({ ...prev, start: newYear.toString() }))\n      applyYearFilter('start', newYear.toString())\n    } else {\n      newYear = Math.max(startYear + 100, Math.min(2000, year))\n      setYearInputs(prev => ({ ...prev, end: newYear.toString() }))\n      applyYearFilter('end', newYear.toString())\n    }\n  }, [isDraggingSlider, draggedHandle, sliderRect, yearInputs, applyYearFilter])\n\n  const handleSliderMouseUp = useCallback(() => {\n    setIsDraggingSlider(false)\n    setDraggedHandle(null)\n    setSliderRect(null)\n  }, [])\n\n  const parseYearValue = (value: string, defaultValue: number): number => {\n    const parsed = parseInt(value)\n    return isNaN(parsed) ? defaultValue : parsed\n  }\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    if (isDraggingSlider) {\n      document.addEventListener('mousemove', handleSliderMouseMove)\n      document.addEventListener('mouseup', handleSliderMouseUp)\n      document.addEventListener('touchmove', handleSliderMouseMove)\n      document.addEventListener('touchend', handleSliderMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleSliderMouseMove)\n        document.removeEventListener('mouseup', handleSliderMouseUp)\n        document.removeEventListener('touchmove', handleSliderMouseMove)\n        document.removeEventListener('touchend', handleSliderMouseUp)\n      }\n    }\n  }, [isDraggingSlider, handleSliderMouseMove, handleSliderMouseUp])\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    })\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    })\n  }\n\n    // Функция для получения приоритета категории\n  const getCategoryPriority = (category: string) => {\n    return allCategories.indexOf(category)\n  }\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColors[index % countryColors.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = [\n        '#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad',\n        '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98',\n        '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsDark[index % countryColorsDark.length]\n    }\n    return '#7f8c8d' // темно-серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsMuted[index % countryColorsMuted.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = (person: Person) => {\n    if (groupingType === 'category') {\n      return person.category\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country)\n    }\n    return person.category // по умолчанию\n  }\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category)\n      if (categoryDiff !== 0) {\n        return categoryDiff\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country))\n      if (countryDiff !== 0) {\n        return countryDiff\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear\n  })\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n  const totalYears = maxYear - minYear\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies \n    ? Math.min(...sortedData.map(p => p.birthYear))\n    : minYear\n  const effectiveMaxYear = filters.hideEmptyCenturies \n    ? Math.max(...sortedData.map(p => p.deathYear))\n    : maxYear\n  \n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear)\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = (people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData)\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0)\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops: number[] = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  };\n\n  const categoryDividers = createCategoryDividers();\n\n  return (\n    <div className=\"app\" id=\"chronoline-app\" role=\"main\" aria-label=\"Chronoline - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getCategoryColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={handleSliderMouseDown}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <main className=\"timeline-container\" id=\"timeline-main\" role=\"region\" aria-label=\"Временная линия исторических личностей\">\n        <Timeline\n          isLoading={isLoading}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={getPersonGroup}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={setHoveredPerson}\n          mousePosition={mousePosition}\n          setMousePosition={setMousePosition}\n          showTooltip={showTooltip}\n          setShowTooltip={setShowTooltip}\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={setHoveredAchievement}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={setAchievementTooltipPosition}\n          showAchievementTooltip={showAchievementTooltip}\n          setShowAchievementTooltip={setShowAchievementTooltip}\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n      </main>\n\n              <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={getPersonGroup}\n          getCategoryColor={getCategoryColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={getPersonGroup}\n        getCategoryColor={getCategoryColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}