{"ast":null,"code":"import React,{useState,useEffect}from'react';import{AppHeader}from'./components/AppHeader';import{Timeline}from'./components/Timeline';import{Tooltips}from'./components/Tooltips';import{MobilePersonPanel}from'./components/MobilePersonPanel';import{useTimelineData}from'./hooks/useTimelineData';import{useFilters}from'./hooks/useFilters';import{useSlider}from'./hooks/useSlider';import{useTooltip}from'./hooks/useTooltip';import{generateCenturyBoundaries,getFirstCountry}from'./utils/timelineUtils';import{getGroupColor,getGroupColorDark,getGroupColorMuted,getPersonGroup,sortGroupedData}from'./utils/groupingUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const[isScrolled,setIsScrolled]=useState(false);const[activeAchievementMarker,setActiveAchievementMarker]=useState(null);const[selectedPerson,setSelectedPerson]=useState(null);const[showControls,setShowControls]=useState(true);// Используем кастомные хуки\nconst{filters,setFilters,groupingType,setGroupingType,yearInputs,setYearInputs,applyYearFilter,handleYearKeyPress,resetAllFilters,parseYearValue}=useFilters();const{persons,allCategories,allCountries,isLoading}=useTimelineData(filters);const{isDraggingSlider,draggedHandle,sliderRect,handleSliderMouseDown,handleSliderMouseMove,handleSliderMouseUp}=useSlider();const{hoveredPerson,mousePosition,showTooltip,hoveredAchievement,achievementTooltipPosition,showAchievementTooltip,hoverTimerRef,handlePersonHover,handleAchievementHover}=useTooltip();// Добавляем обработчики событий мыши и touch\nuseEffect(()=>{if(isDraggingSlider){const handleMouseMove=e=>handleSliderMouseMove(e,yearInputs,applyYearFilter,setYearInputs);const handleMouseUp=()=>handleSliderMouseUp();document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',handleMouseUp);document.addEventListener('touchmove',handleMouseMove);document.addEventListener('touchend',handleMouseUp);return()=>{document.removeEventListener('mousemove',handleMouseMove);document.removeEventListener('mouseup',handleMouseUp);document.removeEventListener('touchmove',handleMouseMove);document.removeEventListener('touchend',handleMouseUp);};}},[isDraggingSlider,handleSliderMouseMove,handleSliderMouseUp,yearInputs,applyYearFilter,setYearInputs]);// Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\nconst sortedData=sortGroupedData(persons,groupingType);// Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\nuseEffect(()=>{if(filters.hideEmptyCenturies&&sortedData.length>0){// Вычисляем эффективный диапазон на основе отфильтрованных данных\nconst effectiveMinYear=Math.min(...sortedData.map(p=>p.birthYear));const effectiveMaxYear=Math.max(...sortedData.map(p=>p.deathYear));// Проверяем, есть ли активные фильтры (категории или страны)\nconst hasActiveFilters=filters.categories.length>0||filters.countries.length>0;let newTimeRange={...filters.timeRange};if(hasActiveFilters){// Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\nnewTimeRange={start:Math.max(filters.timeRange.start,effectiveMinYear),end:Math.min(filters.timeRange.end,effectiveMaxYear)};}else{// Если нет активных фильтров, НЕ сужаем диапазон\n// Пользователь может хотеть видеть данные за пределами текущего диапазона\nnewTimeRange=filters.timeRange;}// Обновляем только если диапазон изменился\nif(newTimeRange.start!==filters.timeRange.start||newTimeRange.end!==filters.timeRange.end){setFilters(prev=>({...prev,timeRange:newTimeRange}));// Обновляем поля ввода\nsetYearInputs({start:newTimeRange.start.toString(),end:newTimeRange.end.toString()});}}},[filters.hideEmptyCenturies,sortedData,filters.categories,filters.countries,filters.timeRange]);// Отслеживаем скролл\nuseEffect(()=>{const handleScroll=()=>{const scrollTop=window.pageYOffset||document.documentElement.scrollTop;setIsScrolled(scrollTop>50);};window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);// Вычисляем реальный диапазон лет из отфильтрованных данных\nconst minYear=Math.min(...sortedData.map(p=>p.birthYear),filters.timeRange.start);const maxYear=Math.max(...sortedData.map(p=>p.deathYear),filters.timeRange.end);const totalYears=maxYear-minYear;// Настройки масштаба\nconst pixelsPerYear=3;// 3 пикселя на год\nconst LEFT_PADDING_PX=30;// отступ слева, чтобы крайняя левая подпись не упиралась в край\nconst timelineWidth=totalYears*pixelsPerYear+LEFT_PADDING_PX;// Генерируем границы веков\n// Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\nconst effectiveMinYear=filters.hideEmptyCenturies?Math.min(...sortedData.map(p=>p.birthYear)):minYear;const effectiveMaxYear=filters.hideEmptyCenturies?Math.max(...sortedData.map(p=>p.deathYear)):maxYear;const centuryBoundaries=generateCenturyBoundaries(effectiveMinYear,effectiveMaxYear);// Алгоритм размещения полосок на строках с полной группировкой по категориям\nconst calculateRowPlacement=people=>{const rows=[];if(groupingType==='none'){// Без группировки - просто размещаем всех в строки\nconst allRows=[];people.forEach(person=>{let placed=false;// Проверяем каждую существующую строку\nfor(let rowIndex=0;rowIndex<allRows.length;rowIndex++){const row=allRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){allRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){allRows.push([person]);}});return allRows;}// Группировка по категориям или странам\nconst groupField=groupingType==='category'?'category':'country';const allGroups=groupingType==='category'?allCategories:allCountries;const groups={};// Группируем людей по выбранному полю\npeople.forEach(person=>{let groupValue;if(groupField==='country'){// Для стран берем первую из списка, если есть несколько через \"/\"\ngroupValue=getFirstCountry(person.country);}else{groupValue=person[groupField];}if(!groups[groupValue]){groups[groupValue]=[];}groups[groupValue].push(person);});// Обрабатываем каждую группу в заданном порядке\nallGroups.forEach(groupValue=>{if(groups[groupValue]){const groupPeople=groups[groupValue];const groupRows=[];// Размещаем людей данной группы в отдельные строки\ngroupPeople.forEach(person=>{let placed=false;// Проверяем каждую существующую строку для этой группы\nfor(let rowIndex=0;rowIndex<groupRows.length;rowIndex++){const row=groupRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){groupRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){groupRows.push([person]);}});// Добавляем строки данной группы к общему списку\nrows.push(...groupRows);// Добавляем пустую строку для визуального разделения (кроме последней группы)\nif(groupValue!==allGroups[allGroups.length-1]){rows.push([]);}}});return rows;};// Получаем размещение по строкам\nconst rowPlacement=calculateRowPlacement(sortedData);// Вычисляем общую высоту с учетом пустых строк\nconst totalHeight=rowPlacement.reduce((height,row)=>{return height+(row.length===0?20:70);// 20px для пустых строк, 70px для обычных (60px + 10px margin)\n},0);// Функция для создания разделителей категорий\n// Высота строки и отступ вниз для непустой строки\nconst ROW_HEIGHT=60;const ROW_MARGIN=10;// margin-bottom, используется только для непустых строк\nconst EMPTY_ROW_HEIGHT=20;// Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\nconst rowTops=[];(()=>{let acc=0;rowPlacement.forEach(row=>{rowTops.push(acc);if(row.length===0){acc+=EMPTY_ROW_HEIGHT;}else{acc+=ROW_HEIGHT+ROW_MARGIN;}});})();const createCategoryDividers=()=>{if(groupingType==='none'){return[];// Без группировки нет разделителей\n}const dividers=[];let currentGroup='';rowPlacement.forEach((row,rowIndex)=>{if(row.length>0){const firstPersonInRow=row[0];let currentGroupValue;if(groupingType==='category'){currentGroupValue=firstPersonInRow.category;}else if(groupingType==='country'){// Для стран берем первую из списка\ncurrentGroupValue=getFirstCountry(firstPersonInRow.country);}else{currentGroupValue=firstPersonInRow.category;}if(currentGroupValue!==currentGroup){if(currentGroup!==''){// закрываем предыдущую группу\ndividers.push({category:currentGroup,top:rowTops[rowIndex]-5});}currentGroup=currentGroupValue;}}});// Добавляем разделитель для последней группы\nif(currentGroup!==''){dividers.push({category:currentGroup,top:rowTops[rowPlacement.length-1]-5});}return dividers;};const categoryDividers=createCategoryDividers();return/*#__PURE__*/_jsxs(\"div\",{className:\"app\",id:\"chrononinja-app\",role:\"main\",\"aria-label\":\"Chrono Ninja - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",children:[/*#__PURE__*/_jsx(AppHeader,{isScrolled:isScrolled,showControls:showControls,setShowControls:setShowControls,filters:filters,setFilters:setFilters,groupingType:groupingType,setGroupingType:setGroupingType,allCategories:allCategories,allCountries:allCountries,yearInputs:yearInputs,setYearInputs:setYearInputs,applyYearFilter:applyYearFilter,handleYearKeyPress:handleYearKeyPress,resetAllFilters:resetAllFilters,getCategoryColor:getGroupColor,sortedData:sortedData,handleSliderMouseDown:handleSliderMouseDown,isDraggingSlider:isDraggingSlider}),/*#__PURE__*/_jsx(\"div\",{className:\"timeline-wrapper\",children:/*#__PURE__*/_jsx(\"main\",{className:\"timeline-container\",id:\"timeline-viewport\",role:\"region\",\"aria-label\":\"\\u041E\\u0431\\u043B\\u0430\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0430 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 \\u043B\\u0438\\u043D\\u0438\\u0438\",children:/*#__PURE__*/_jsx(Timeline,{isLoading:isLoading,timelineWidth:timelineWidth,totalHeight:totalHeight,centuryBoundaries:centuryBoundaries,minYear:minYear,pixelsPerYear:pixelsPerYear,LEFT_PADDING_PX:LEFT_PADDING_PX,rowPlacement:rowPlacement,filters:filters,groupingType:groupingType,categoryDividers:categoryDividers,getGroupColor:getGroupColor,getGroupColorDark:getGroupColorDark,getGroupColorMuted:getGroupColorMuted,getPersonGroup:person=>getPersonGroup(person,groupingType),hoveredPerson:hoveredPerson,setHoveredPerson:person=>handlePersonHover(person,mousePosition.x,mousePosition.y),mousePosition:mousePosition,setMousePosition:()=>{}// Пустая функция, так как позиция обновляется в handlePersonHover\n,showTooltip:showTooltip,setShowTooltip:()=>{}// Пустая функция, так как состояние обновляется в handlePersonHover\n,activeAchievementMarker:activeAchievementMarker,setActiveAchievementMarker:setActiveAchievementMarker,hoveredAchievement:hoveredAchievement,setHoveredAchievement:achievement=>handleAchievementHover(achievement,achievementTooltipPosition.x,achievementTooltipPosition.y),achievementTooltipPosition:achievementTooltipPosition,setAchievementTooltipPosition:()=>{}// Пустая функция, так как позиция обновляется в handleAchievementHover\n,showAchievementTooltip:showAchievementTooltip,setShowAchievementTooltip:()=>{}// Пустая функция, так как состояние обновляется в handleAchievementHover\n,hoverTimerRef:hoverTimerRef,sortedData:sortedData,selectedPerson:selectedPerson,setSelectedPerson:setSelectedPerson})})}),/*#__PURE__*/_jsx(\"aside\",{className:\"tooltips-container\",id:\"tooltips-aside\",\"aria-label\":\"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",children:/*#__PURE__*/_jsx(Tooltips,{hoveredPerson:hoveredPerson,showTooltip:showTooltip,mousePosition:mousePosition,hoveredAchievement:hoveredAchievement,showAchievementTooltip:showAchievementTooltip,achievementTooltipPosition:achievementTooltipPosition,getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})}),/*#__PURE__*/_jsx(MobilePersonPanel,{selectedPerson:selectedPerson,onClose:()=>setSelectedPerson(null),getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})]});}export default App;","map":{"version":3,"names":["React","useState","useEffect","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","useFilters","useSlider","useTooltip","generateCenturyBoundaries","getFirstCountry","getGroupColor","getGroupColorDark","getGroupColorMuted","getPersonGroup","sortGroupedData","jsx","_jsx","jsxs","_jsxs","App","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","showControls","setShowControls","filters","setFilters","groupingType","setGroupingType","yearInputs","setYearInputs","applyYearFilter","handleYearKeyPress","resetAllFilters","parseYearValue","persons","allCategories","allCountries","isLoading","isDraggingSlider","draggedHandle","sliderRect","handleSliderMouseDown","handleSliderMouseMove","handleSliderMouseUp","hoveredPerson","mousePosition","showTooltip","hoveredAchievement","achievementTooltipPosition","showAchievementTooltip","hoverTimerRef","handlePersonHover","handleAchievementHover","handleMouseMove","e","handleMouseUp","document","addEventListener","removeEventListener","sortedData","hideEmptyCenturies","length","effectiveMinYear","Math","min","map","p","birthYear","effectiveMaxYear","max","deathYear","hasActiveFilters","categories","countries","newTimeRange","timeRange","start","end","prev","toString","handleScroll","scrollTop","window","pageYOffset","documentElement","minYear","maxYear","totalYears","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","person","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","country","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","category","top","categoryDividers","className","id","role","children","getCategoryColor","setHoveredPerson","x","y","setMousePosition","setShowTooltip","setHoveredAchievement","achievement","setAchievementTooltipPosition","setShowAchievementTooltip","onClose"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react'\nimport { Person } from './types'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { useFilters } from './hooks/useFilters'\nimport { useSlider } from './hooks/useSlider'\nimport { useTooltip } from './hooks/useTooltip'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport { \n  getGroupColor, \n  getGroupColorDark, \n  getGroupColorMuted, \n  getPersonGroup,\n  sortGroupedData\n} from './utils/groupingUtils'\nimport './App.css'\n\nfunction App() {\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const [showControls, setShowControls] = useState(true)\n\n  // Используем кастомные хуки\n  const { \n    filters, \n    setFilters, \n    groupingType, \n    setGroupingType, \n    yearInputs, \n    setYearInputs, \n    applyYearFilter, \n    handleYearKeyPress, \n    resetAllFilters, \n    parseYearValue \n  } = useFilters()\n  \n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n  \n  const { \n    isDraggingSlider, \n    draggedHandle, \n    sliderRect, \n    handleSliderMouseDown, \n    handleSliderMouseMove, \n    handleSliderMouseUp \n  } = useSlider()\n  \n  const { \n    hoveredPerson, \n    mousePosition, \n    showTooltip, \n    hoveredAchievement, \n    achievementTooltipPosition, \n    showAchievementTooltip, \n    hoverTimerRef, \n    handlePersonHover, \n    handleAchievementHover \n  } = useTooltip()\n\n\n\n\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    if (isDraggingSlider) {\n      const handleMouseMove = (e: MouseEvent | TouchEvent) => \n        handleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs)\n      \n      const handleMouseUp = () => handleSliderMouseUp()\n      \n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.addEventListener('touchmove', handleMouseMove)\n      document.addEventListener('touchend', handleMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleMouseMove)\n        document.removeEventListener('touchend', handleMouseUp)\n      }\n    }\n  }, [isDraggingSlider, handleSliderMouseMove, handleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs])\n\n\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType)\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n  const totalYears = maxYear - minYear\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies \n    ? Math.min(...sortedData.map(p => p.birthYear))\n    : minYear\n  const effectiveMaxYear = filters.hideEmptyCenturies \n    ? Math.max(...sortedData.map(p => p.deathYear))\n    : maxYear\n  \n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear)\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = (people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData)\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0)\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops: number[] = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  };\n\n  const categoryDividers = createCategoryDividers();\n\n  return (\n    <div className=\"app\" id=\"chrononinja-app\" role=\"main\" aria-label=\"Chrono Ninja - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getGroupColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={handleSliderMouseDown}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <div className=\"timeline-wrapper\">\n        <main className=\"timeline-container\" id=\"timeline-viewport\" role=\"region\" aria-label=\"Область просмотра временной линии\">\n          <Timeline\n          isLoading={isLoading}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={(person) => handlePersonHover(person, mousePosition.x, mousePosition.y)}\n          mousePosition={mousePosition}\n          setMousePosition={() => {}} // Пустая функция, так как позиция обновляется в handlePersonHover\n          showTooltip={showTooltip}\n          setShowTooltip={() => {}} // Пустая функция, так как состояние обновляется в handlePersonHover\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={(achievement) => handleAchievementHover(achievement, achievementTooltipPosition.x, achievementTooltipPosition.y)}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={() => {}} // Пустая функция, так как позиция обновляется в handleAchievementHover\n          showAchievementTooltip={showAchievementTooltip}\n          setShowAchievementTooltip={() => {}} // Пустая функция, так как состояние обновляется в handleAchievementHover\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n        </main>\n      </div>\n\n      <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          getCategoryColor={getGroupColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n        getCategoryColor={getGroupColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}