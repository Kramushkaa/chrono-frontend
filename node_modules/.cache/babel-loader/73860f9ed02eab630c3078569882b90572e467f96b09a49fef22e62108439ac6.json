{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Selecty\\\\Documents\\\\PetProjects\\\\chronoline-frontend\\\\src\\\\App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors';\nimport { AppHeader } from './components/AppHeader';\nimport { Timeline } from './components/Timeline';\nimport { Tooltips } from './components/Tooltips';\nimport { MobilePersonPanel } from './components/MobilePersonPanel';\nimport { useTimelineData } from './hooks/useTimelineData';\nimport { generateCenturyBoundaries, getFirstCountry } from './utils/timelineUtils';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [hoveredPerson, setHoveredPerson] = useState(null);\n  const [mousePosition, setMousePosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [hoveredAchievement, setHoveredAchievement] = useState(null);\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false);\n  const [isScrolled, setIsScrolled] = useState(false);\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState(null);\n  const [selectedPerson, setSelectedPerson] = useState(null);\n  const hoverTimerRef = useRef(null);\n  const [showControls, setShowControls] = useState(true);\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || {\n          start: -800,\n          end: 2000\n        },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true,\n        hideEmptyCenturies: parsed.hideEmptyCenturies !== undefined ? parsed.hideEmptyCenturies : false\n      };\n    }\n    return {\n      categories: [],\n      countries: [],\n      timeRange: {\n        start: -800,\n        end: 2000\n      },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    };\n  });\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping || 'category';\n  });\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      const timer = hoverTimerRef.current;\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const {\n    persons,\n    allCategories,\n    allCountries,\n    isLoading\n  } = useTimelineData(filters);\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  });\n\n  // Состояния для интерактивной полоски диапазона\n  const [isDraggingSlider, setIsDraggingSlider] = useState(false);\n  const [draggedHandle, setDraggedHandle] = useState(null);\n  const [sliderRect, setSliderRect] = useState(null);\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = (field, value) => {\n    const parsed = parseInt(value);\n    const numValue = isNaN(parsed) ? field === 'start' ? -800 : 2000 : parsed;\n    setFilters(prev => ({\n      ...prev,\n      timeRange: {\n        ...prev.timeRange,\n        [field]: numValue\n      }\n    }));\n  };\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field, e) => {\n    if (e.key === 'Enter') {\n      var _e$currentTarget$pare, _e$currentTarget$pare2;\n      applyYearFilter(field, e.currentTarget.value);\n      // Переводим фокус на следующий элемент\n      const inputs = (_e$currentTarget$pare = e.currentTarget.parentElement) === null || _e$currentTarget$pare === void 0 ? void 0 : (_e$currentTarget$pare2 = _e$currentTarget$pare.parentElement) === null || _e$currentTarget$pare2 === void 0 ? void 0 : _e$currentTarget$pare2.querySelectorAll('input');\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget);\n        const nextInput = inputs[currentIndex + 1];\n        if (nextInput) {\n          nextInput.focus();\n        }\n      }\n    }\n  };\n\n  // Функции для интерактивной полоски диапазона\n  const handleSliderMouseDown = (e, handle) => {\n    var _e$currentTarget$pare3;\n    e.preventDefault();\n    setIsDraggingSlider(true);\n    setDraggedHandle(handle);\n    const sliderElement = (_e$currentTarget$pare3 = e.currentTarget.parentElement) === null || _e$currentTarget$pare3 === void 0 ? void 0 : _e$currentTarget$pare3.parentElement;\n    if (sliderElement) {\n      setSliderRect(sliderElement.getBoundingClientRect());\n    }\n  };\n  const handleSliderMouseMove = useCallback(e => {\n    if (!isDraggingSlider || !draggedHandle || !sliderRect) return;\n    const rect = sliderRect;\n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const x = clientX - rect.left;\n    const percentage = Math.max(0, Math.min(100, x / rect.width * 100));\n\n    // Преобразуем процент в год (от -800 до 2000)\n    const totalRange = 2800; // 2000 - (-800)\n    const year = Math.round(-800 + percentage / 100 * totalRange);\n\n    // Ограничиваем значения\n    const startYear = parseYearValue(yearInputs.start, -800);\n    const endYear = parseYearValue(yearInputs.end, 2000);\n    let newYear = year;\n    if (draggedHandle === 'start') {\n      newYear = Math.max(-800, Math.min(endYear - 100, year));\n      setYearInputs(prev => ({\n        ...prev,\n        start: newYear.toString()\n      }));\n      applyYearFilter('start', newYear.toString());\n    } else {\n      newYear = Math.max(startYear + 100, Math.min(2000, year));\n      setYearInputs(prev => ({\n        ...prev,\n        end: newYear.toString()\n      }));\n      applyYearFilter('end', newYear.toString());\n    }\n  }, [isDraggingSlider, draggedHandle, sliderRect, yearInputs, applyYearFilter]);\n  const handleSliderMouseUp = () => {\n    setIsDraggingSlider(false);\n    setDraggedHandle(null);\n    setSliderRect(null);\n  };\n  const parseYearValue = (value, defaultValue) => {\n    const parsed = parseInt(value);\n    return isNaN(parsed) ? defaultValue : parsed;\n  };\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    if (isDraggingSlider) {\n      document.addEventListener('mousemove', handleSliderMouseMove);\n      document.addEventListener('mouseup', handleSliderMouseUp);\n      document.addEventListener('touchmove', handleSliderMouseMove);\n      document.addEventListener('touchend', handleSliderMouseUp);\n      return () => {\n        document.removeEventListener('mousemove', handleSliderMouseMove);\n        document.removeEventListener('mouseup', handleSliderMouseUp);\n        document.removeEventListener('touchmove', handleSliderMouseMove);\n        document.removeEventListener('touchend', handleSliderMouseUp);\n      };\n    }\n  }, [isDraggingSlider, draggedHandle, sliderRect, yearInputs]);\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: {\n        start: -800,\n        end: 2000\n      },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    });\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    });\n  };\n\n  // Функция для получения приоритета категории\n  const getCategoryPriority = category => {\n    return allCategories.indexOf(category);\n  };\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad', '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'];\n      const index = allCountries.indexOf(groupName);\n      return countryColors[index % countryColors.length];\n    }\n    return '#95a5a6'; // серый цвет по умолчанию\n  };\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = ['#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad', '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98', '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'];\n      const index = allCountries.indexOf(groupName);\n      return countryColorsDark[index % countryColorsDark.length];\n    }\n    return '#7f8c8d'; // темно-серый цвет по умолчанию\n  };\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = groupName => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName);\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad', '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'];\n      const index = allCountries.indexOf(groupName);\n      return countryColorsMuted[index % countryColorsMuted.length];\n    }\n    return '#95a5a6'; // серый цвет по умолчанию\n  };\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = person => {\n    if (groupingType === 'category') {\n      return person.category;\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country);\n    }\n    return person.category; // по умолчанию\n  };\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category);\n      if (categoryDiff !== 0) {\n        return categoryDiff;\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country));\n      if (countryDiff !== 0) {\n        return countryDiff;\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear;\n  });\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n\n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      let newTimeRange = {\n        ...filters.timeRange\n      };\n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n\n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n\n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      setIsScrolled(scrollTop > 50);\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start);\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end);\n  const totalYears = maxYear - minYear;\n\n  // Настройки масштаба\n  const pixelsPerYear = 3; // 3 пикселя на год\n  const LEFT_PADDING_PX = 30; // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX;\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies ? Math.min(...sortedData.map(p => p.birthYear)) : minYear;\n  const effectiveMaxYear = filters.hideEmptyCenturies ? Math.max(...sortedData.map(p => p.deathYear)) : maxYear;\n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear);\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = people => {\n    const rows = [];\n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows = [];\n      people.forEach(person => {\n        let placed = false;\n\n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex];\n          let canPlaceInRow = true;\n\n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n              canPlaceInRow = false;\n              break;\n            }\n          }\n\n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person);\n            placed = true;\n            break;\n          }\n        }\n\n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person]);\n        }\n      });\n      return allRows;\n    }\n\n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country';\n    const allGroups = groupingType === 'category' ? allCategories : allCountries;\n    const groups = {};\n\n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue;\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country);\n      } else {\n        groupValue = person[groupField];\n      }\n      if (!groups[groupValue]) {\n        groups[groupValue] = [];\n      }\n      groups[groupValue].push(person);\n    });\n\n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue];\n        const groupRows = [];\n\n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false;\n\n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex];\n            let canPlaceInRow = true;\n\n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n                canPlaceInRow = false;\n                break;\n              }\n            }\n\n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person);\n              placed = true;\n              break;\n            }\n          }\n\n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person]);\n          }\n        });\n\n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows);\n\n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([]);\n        }\n      }\n    });\n    return rows;\n  };\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData);\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70); // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0);\n\n  // Функция для создания разделителей категорий\n  // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n    const dividers = [];\n    let currentGroup = '';\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue;\n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({\n              category: currentGroup,\n              top: rowTops[rowIndex] - 5\n            });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({\n        category: currentGroup,\n        top: rowTops[rowPlacement.length - 1] - 5\n      });\n    }\n    return dividers;\n  };\n  const categoryDividers = createCategoryDividers();\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    id: \"chronoline-app\",\n    role: \"main\",\n    \"aria-label\": \"Chronoline - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",\n    children: [/*#__PURE__*/_jsxDEV(AppHeader, {\n      isScrolled: isScrolled,\n      showControls: showControls,\n      setShowControls: setShowControls,\n      filters: filters,\n      setFilters: setFilters,\n      groupingType: groupingType,\n      setGroupingType: setGroupingType,\n      allCategories: allCategories,\n      allCountries: allCountries,\n      yearInputs: yearInputs,\n      setYearInputs: setYearInputs,\n      applyYearFilter: applyYearFilter,\n      handleYearKeyPress: handleYearKeyPress,\n      resetAllFilters: resetAllFilters,\n      getCategoryColor: getCategoryColor,\n      sortedData: sortedData,\n      handleSliderMouseDown: handleSliderMouseDown,\n      isDraggingSlider: isDraggingSlider\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 547,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      className: \"timeline-container\",\n      id: \"timeline-main\",\n      role: \"region\",\n      \"aria-label\": \"\\u0412\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",\n      children: /*#__PURE__*/_jsxDEV(Timeline, {\n        isLoading: isLoading,\n        timelineWidth: timelineWidth,\n        totalHeight: totalHeight,\n        centuryBoundaries: centuryBoundaries,\n        minYear: minYear,\n        pixelsPerYear: pixelsPerYear,\n        LEFT_PADDING_PX: LEFT_PADDING_PX,\n        rowPlacement: rowPlacement,\n        filters: filters,\n        groupingType: groupingType,\n        categoryDividers: categoryDividers,\n        getGroupColor: getGroupColor,\n        getGroupColorDark: getGroupColorDark,\n        getGroupColorMuted: getGroupColorMuted,\n        getPersonGroup: getPersonGroup,\n        hoveredPerson: hoveredPerson,\n        setHoveredPerson: setHoveredPerson,\n        mousePosition: mousePosition,\n        setMousePosition: setMousePosition,\n        showTooltip: showTooltip,\n        setShowTooltip: setShowTooltip,\n        activeAchievementMarker: activeAchievementMarker,\n        setActiveAchievementMarker: setActiveAchievementMarker,\n        hoveredAchievement: hoveredAchievement,\n        setHoveredAchievement: setHoveredAchievement,\n        achievementTooltipPosition: achievementTooltipPosition,\n        setAchievementTooltipPosition: setAchievementTooltipPosition,\n        showAchievementTooltip: showAchievementTooltip,\n        setShowAchievementTooltip: setShowAchievementTooltip,\n        hoverTimerRef: hoverTimerRef,\n        sortedData: sortedData,\n        selectedPerson: selectedPerson,\n        setSelectedPerson: setSelectedPerson\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 569,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 568,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"aside\", {\n      className: \"tooltips-container\",\n      id: \"tooltips-aside\",\n      \"aria-label\": \"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",\n      children: /*#__PURE__*/_jsxDEV(Tooltips, {\n        hoveredPerson: hoveredPerson,\n        showTooltip: showTooltip,\n        mousePosition: mousePosition,\n        hoveredAchievement: hoveredAchievement,\n        showAchievementTooltip: showAchievementTooltip,\n        achievementTooltipPosition: achievementTooltipPosition,\n        getGroupColor: getGroupColor,\n        getPersonGroup: getPersonGroup,\n        getCategoryColor: getCategoryColor\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 607,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 606,\n      columnNumber: 15\n    }, this), /*#__PURE__*/_jsxDEV(MobilePersonPanel, {\n      selectedPerson: selectedPerson,\n      onClose: () => setSelectedPerson(null),\n      getGroupColor: getGroupColor,\n      getPersonGroup: getPersonGroup,\n      getCategoryColor: getCategoryColor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 621,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 546,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"1yLwD2lO9lVa0vsihspNc2+ynP0=\", false, function () {\n  return [useTimelineData];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","getCategoryColor","getCategoryColorDark","getCategoryColorMuted","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","generateCenturyBoundaries","getFirstCountry","jsxDEV","_jsxDEV","App","_s","hoveredPerson","setHoveredPerson","mousePosition","setMousePosition","x","y","showTooltip","setShowTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","setShowAchievementTooltip","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","hoverTimerRef","showControls","setShowControls","filters","setFilters","savedFilters","localStorage","getItem","parsed","JSON","parse","categories","countries","timeRange","start","end","showAchievements","undefined","hideEmptyCenturies","groupingType","setGroupingType","savedGrouping","setItem","stringify","timer","current","clearTimeout","persons","allCategories","allCountries","isLoading","yearInputs","setYearInputs","toString","isDraggingSlider","setIsDraggingSlider","draggedHandle","setDraggedHandle","sliderRect","setSliderRect","applyYearFilter","field","value","parseInt","numValue","isNaN","prev","handleYearKeyPress","e","key","_e$currentTarget$pare","_e$currentTarget$pare2","currentTarget","inputs","parentElement","querySelectorAll","currentIndex","Array","from","indexOf","nextInput","focus","handleSliderMouseDown","handle","_e$currentTarget$pare3","preventDefault","sliderElement","getBoundingClientRect","handleSliderMouseMove","rect","clientX","touches","left","percentage","Math","max","min","width","totalRange","year","round","startYear","parseYearValue","endYear","newYear","handleSliderMouseUp","defaultValue","document","addEventListener","removeEventListener","resetAllFilters","getCategoryPriority","category","getGroupColor","groupName","countryColors","index","length","getGroupColorDark","countryColorsDark","getGroupColorMuted","countryColorsMuted","getPersonGroup","person","country","sortedData","sort","a","b","categoryDiff","countryDiff","birthYear","effectiveMinYear","map","p","effectiveMaxYear","deathYear","hasActiveFilters","newTimeRange","handleScroll","scrollTop","window","pageYOffset","documentElement","minYear","maxYear","totalYears","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","top","categoryDividers","className","id","role","children","fileName","_jsxFileName","lineNumber","columnNumber","onClose","_c","$RefreshReg$"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react'\nimport { Person } from './types'\nimport { getCategoryColor, getCategoryColorDark, getCategoryColorMuted } from './utils/categoryColors'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport './App.css'\n\nfunction App() {\n  const [hoveredPerson, setHoveredPerson] = useState<Person | null>(null)\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n  const [showTooltip, setShowTooltip] = useState(false)\n  const [hoveredAchievement, setHoveredAchievement] = useState<{ person: Person; year: number; index: number } | null>(null)\n  const [achievementTooltipPosition, setAchievementTooltipPosition] = useState({ x: 0, y: 0 })\n  const [showAchievementTooltip, setShowAchievementTooltip] = useState(false)\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const hoverTimerRef = useRef<NodeJS.Timeout | null>(null)\n  const [showControls, setShowControls] = useState(true)\n  const [filters, setFilters] = useState(() => {\n    const savedFilters = localStorage.getItem('chronoline-filters');\n    if (savedFilters) {\n      const parsed = JSON.parse(savedFilters);\n      return {\n        categories: parsed.categories || [],\n        countries: parsed.countries || [],\n        timeRange: parsed.timeRange || { start: -800, end: 2000 },\n        showAchievements: parsed.showAchievements !== undefined ? parsed.showAchievements : true,\n        hideEmptyCenturies: parsed.hideEmptyCenturies !== undefined ? parsed.hideEmptyCenturies : false\n      };\n    }\n    return {\n      categories: [] as string[],\n      countries: [] as string[],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    };\n  })\n\n  // Состояние для типа группировки\n  const [groupingType, setGroupingType] = useState<'category' | 'country' | 'none'>(() => {\n    const savedGrouping = localStorage.getItem('chronoline-grouping');\n    return savedGrouping as 'category' | 'country' | 'none' || 'category';\n  })\n\n  // Сохраняем фильтры в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-filters', JSON.stringify(filters));\n  }, [filters]);\n\n  // Сохраняем тип группировки в localStorage при изменении\n  useEffect(() => {\n    localStorage.setItem('chronoline-grouping', groupingType);\n  }, [groupingType]);\n\n  // Очищаем таймер при размонтировании компонента\n  useEffect(() => {\n    return () => {\n      const timer = hoverTimerRef.current;\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n  }, []);\n\n  // Используем кастомный хук для загрузки данных\n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Состояние для полей ввода годов\n  const [yearInputs, setYearInputs] = useState({\n    start: filters.timeRange.start.toString(),\n    end: filters.timeRange.end.toString()\n  })\n\n  // Состояния для интерактивной полоски диапазона\n  const [isDraggingSlider, setIsDraggingSlider] = useState(false)\n  const [draggedHandle, setDraggedHandle] = useState<'start' | 'end' | null>(null)\n  const [sliderRect, setSliderRect] = useState<DOMRect | null>(null)\n\n\n\n  // Функция для применения фильтра по году\n  const applyYearFilter = (field: 'start' | 'end', value: string) => {\n    const parsed = parseInt(value);\n    const numValue = isNaN(parsed) ? (field === 'start' ? -800 : 2000) : parsed;\n    setFilters(prev => ({\n      ...prev,\n      timeRange: { ...prev.timeRange, [field]: numValue }\n    }))\n  }\n\n  // Функция для обработки нажатия Enter\n  const handleYearKeyPress = (field: 'start' | 'end', e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === 'Enter') {\n      applyYearFilter(field, e.currentTarget.value)\n      // Переводим фокус на следующий элемент\n      const inputs = e.currentTarget.parentElement?.parentElement?.querySelectorAll('input')\n      if (inputs) {\n        const currentIndex = Array.from(inputs).indexOf(e.currentTarget)\n        const nextInput = inputs[currentIndex + 1] as HTMLInputElement\n        if (nextInput) {\n          nextInput.focus()\n        }\n      }\n    }\n  }\n\n  // Функции для интерактивной полоски диапазона\n  const handleSliderMouseDown = (e: React.MouseEvent | React.TouchEvent, handle: 'start' | 'end') => {\n    e.preventDefault()\n    setIsDraggingSlider(true)\n    setDraggedHandle(handle)\n    const sliderElement = e.currentTarget.parentElement?.parentElement\n    if (sliderElement) {\n      setSliderRect(sliderElement.getBoundingClientRect())\n    }\n  }\n\n  const handleSliderMouseMove = useCallback((e: MouseEvent | TouchEvent) => {\n    if (!isDraggingSlider || !draggedHandle || !sliderRect) return\n\n    const rect = sliderRect\n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX\n    const x = clientX - rect.left\n    const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100))\n    \n    // Преобразуем процент в год (от -800 до 2000)\n    const totalRange = 2800 // 2000 - (-800)\n    const year = Math.round(-800 + (percentage / 100) * totalRange)\n    \n    // Ограничиваем значения\n    const startYear = parseYearValue(yearInputs.start, -800)\n    const endYear = parseYearValue(yearInputs.end, 2000)\n    \n    let newYear = year\n    if (draggedHandle === 'start') {\n      newYear = Math.max(-800, Math.min(endYear - 100, year))\n      setYearInputs(prev => ({ ...prev, start: newYear.toString() }))\n      applyYearFilter('start', newYear.toString())\n    } else {\n      newYear = Math.max(startYear + 100, Math.min(2000, year))\n      setYearInputs(prev => ({ ...prev, end: newYear.toString() }))\n      applyYearFilter('end', newYear.toString())\n    }\n  }, [isDraggingSlider, draggedHandle, sliderRect, yearInputs, applyYearFilter])\n\n  const handleSliderMouseUp = () => {\n    setIsDraggingSlider(false)\n    setDraggedHandle(null)\n    setSliderRect(null)\n  }\n\n  const parseYearValue = (value: string, defaultValue: number): number => {\n    const parsed = parseInt(value)\n    return isNaN(parsed) ? defaultValue : parsed\n  }\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    if (isDraggingSlider) {\n      document.addEventListener('mousemove', handleSliderMouseMove)\n      document.addEventListener('mouseup', handleSliderMouseUp)\n      document.addEventListener('touchmove', handleSliderMouseMove)\n      document.addEventListener('touchend', handleSliderMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleSliderMouseMove)\n        document.removeEventListener('mouseup', handleSliderMouseUp)\n        document.removeEventListener('touchmove', handleSliderMouseMove)\n        document.removeEventListener('touchend', handleSliderMouseUp)\n      }\n    }\n  }, [isDraggingSlider, draggedHandle, sliderRect, yearInputs])\n\n  // Функция для сброса всех фильтров\n  const resetAllFilters = () => {\n    setFilters({\n      categories: [],\n      countries: [],\n      timeRange: { start: -800, end: 2000 },\n      showAchievements: true,\n      hideEmptyCenturies: false\n    })\n    setYearInputs({\n      start: '-800',\n      end: '2000'\n    })\n  }\n\n    // Функция для получения приоритета категории\n  const getCategoryPriority = (category: string) => {\n    return allCategories.indexOf(category)\n  }\n\n  // Функция для получения цвета группы в зависимости от типа группировки\n  const getGroupColor = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColor(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем другой набор цветов\n      const countryColors = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColors[index % countryColors.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (темный вариант)\n  const getGroupColorDark = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorDark(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем темные варианты цветов\n      const countryColorsDark = [\n        '#c0392b', '#2980b9', '#27ae60', '#d68910', '#8e44ad',\n        '#16a085', '#d35400', '#2c3e50', '#138d75', '#7d3c98',\n        '#229954', '#1f618d', '#d4ac0f', '#c0392b', '#7f8c8d'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsDark[index % countryColorsDark.length]\n    }\n    return '#7f8c8d' // темно-серый цвет по умолчанию\n  }\n\n  // Функция для получения цвета группы (приглушенный вариант)\n  const getGroupColorMuted = (groupName: string) => {\n    if (groupingType === 'category') {\n      return getCategoryColorMuted(groupName)\n    } else if (groupingType === 'country') {\n      // Для стран используем приглушенные варианты цветов\n      const countryColorsMuted = [\n        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',\n        '#1abc9c', '#e67e22', '#34495e', '#16a085', '#8e44ad',\n        '#27ae60', '#2980b9', '#f1c40f', '#e74c3c', '#95a5a6'\n      ]\n      const index = allCountries.indexOf(groupName)\n      return countryColorsMuted[index % countryColorsMuted.length]\n    }\n    return '#95a5a6' // серый цвет по умолчанию\n  }\n\n  // Функция для получения значения группы для персонажа\n  const getPersonGroup = (person: Person) => {\n    if (groupingType === 'category') {\n      return person.category\n    } else if (groupingType === 'country') {\n      return getFirstCountry(person.country)\n    }\n    return person.category // по умолчанию\n  }\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = [...persons].sort((a, b) => {\n    if (groupingType === 'category') {\n      // Сначала сортируем по категориям\n      const categoryDiff = getCategoryPriority(a.category) - getCategoryPriority(b.category)\n      if (categoryDiff !== 0) {\n        return categoryDiff\n      }\n    } else if (groupingType === 'country') {\n      // Сначала сортируем по странам (берем первую страну из списка)\n      const countryDiff = allCountries.indexOf(getFirstCountry(a.country)) - allCountries.indexOf(getFirstCountry(b.country))\n      if (countryDiff !== 0) {\n        return countryDiff\n      }\n    }\n    // Затем по году рождения\n    return a.birthYear - b.birthYear\n  })\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Вычисляем реальный диапазон лет из отфильтрованных данных\n  const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n  const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n  const totalYears = maxYear - minYear\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Генерируем границы веков\n  // Если включена настройка скрытия пустых веков, используем только отфильтрованные данные\n  const effectiveMinYear = filters.hideEmptyCenturies \n    ? Math.min(...sortedData.map(p => p.birthYear))\n    : minYear\n  const effectiveMaxYear = filters.hideEmptyCenturies \n    ? Math.max(...sortedData.map(p => p.deathYear))\n    : maxYear\n  \n  const centuryBoundaries = generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear)\n\n  // Алгоритм размещения полосок на строках с полной группировкой по категориям\n  const calculateRowPlacement = (people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }\n\n  // Получаем размещение по строкам\n  const rowPlacement = calculateRowPlacement(sortedData)\n\n  // Вычисляем общую высоту с учетом пустых строк\n  const totalHeight = rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0)\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Подсчитываем абсолютный top каждой строки, чтобы точно позиционировать разделители\n  const rowTops: number[] = [];\n  (() => {\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      rowTops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n  })();\n\n  const createCategoryDividers = () => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  };\n\n  const categoryDividers = createCategoryDividers();\n\n  return (\n    <div className=\"app\" id=\"chronoline-app\" role=\"main\" aria-label=\"Chronoline - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getCategoryColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={handleSliderMouseDown}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <main className=\"timeline-container\" id=\"timeline-main\" role=\"region\" aria-label=\"Временная линия исторических личностей\">\n        <Timeline\n          isLoading={isLoading}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={getPersonGroup}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={setHoveredPerson}\n          mousePosition={mousePosition}\n          setMousePosition={setMousePosition}\n          showTooltip={showTooltip}\n          setShowTooltip={setShowTooltip}\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={setHoveredAchievement}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={setAchievementTooltipPosition}\n          showAchievementTooltip={showAchievementTooltip}\n          setShowAchievementTooltip={setShowAchievementTooltip}\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n      </main>\n\n              <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={getPersonGroup}\n          getCategoryColor={getCategoryColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={getPersonGroup}\n        getCategoryColor={getCategoryColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAEvE,SAASC,gBAAgB,EAAEC,oBAAoB,EAAEC,qBAAqB,QAAQ,wBAAwB;AACtG,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,eAAe,QAAQ,yBAAyB;AACzD,SACEC,yBAAyB,EACzBC,eAAe,QACV,uBAAuB;AAC9B,OAAO,WAAW;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAElB,SAASC,GAAGA,CAAA,EAAG;EAAAC,EAAA;EACb,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGnB,QAAQ,CAAgB,IAAI,CAAC;EACvE,MAAM,CAACoB,aAAa,EAAEC,gBAAgB,CAAC,GAAGrB,QAAQ,CAAC;IAAEsB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAAC;EAClE,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGzB,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAAC0B,kBAAkB,EAAEC,qBAAqB,CAAC,GAAG3B,QAAQ,CAAyD,IAAI,CAAC;EAC1H,MAAM,CAAC4B,0BAA0B,EAAEC,6BAA6B,CAAC,GAAG7B,QAAQ,CAAC;IAAEsB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAAC;EAC5F,MAAM,CAACO,sBAAsB,EAAEC,yBAAyB,CAAC,GAAG/B,QAAQ,CAAC,KAAK,CAAC;EAC3E,MAAM,CAACgC,UAAU,EAAEC,aAAa,CAAC,GAAGjC,QAAQ,CAAC,KAAK,CAAC;EACnD,MAAM,CAACkC,uBAAuB,EAAEC,0BAA0B,CAAC,GAAGnC,QAAQ,CAA6C,IAAI,CAAC;EACxH,MAAM,CAACoC,cAAc,EAAEC,iBAAiB,CAAC,GAAGrC,QAAQ,CAAgB,IAAI,CAAC;EACzE,MAAMsC,aAAa,GAAGpC,MAAM,CAAwB,IAAI,CAAC;EACzD,MAAM,CAACqC,YAAY,EAAEC,eAAe,CAAC,GAAGxC,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAACyC,OAAO,EAAEC,UAAU,CAAC,GAAG1C,QAAQ,CAAC,MAAM;IAC3C,MAAM2C,YAAY,GAAGC,YAAY,CAACC,OAAO,CAAC,oBAAoB,CAAC;IAC/D,IAAIF,YAAY,EAAE;MAChB,MAAMG,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,CAAC;MACvC,OAAO;QACLM,UAAU,EAAEH,MAAM,CAACG,UAAU,IAAI,EAAE;QACnCC,SAAS,EAAEJ,MAAM,CAACI,SAAS,IAAI,EAAE;QACjCC,SAAS,EAAEL,MAAM,CAACK,SAAS,IAAI;UAAEC,KAAK,EAAE,CAAC,GAAG;UAAEC,GAAG,EAAE;QAAK,CAAC;QACzDC,gBAAgB,EAAER,MAAM,CAACQ,gBAAgB,KAAKC,SAAS,GAAGT,MAAM,CAACQ,gBAAgB,GAAG,IAAI;QACxFE,kBAAkB,EAAEV,MAAM,CAACU,kBAAkB,KAAKD,SAAS,GAAGT,MAAM,CAACU,kBAAkB,GAAG;MAC5F,CAAC;IACH;IACA,OAAO;MACLP,UAAU,EAAE,EAAc;MAC1BC,SAAS,EAAE,EAAc;MACzBC,SAAS,EAAE;QAAEC,KAAK,EAAE,CAAC,GAAG;QAAEC,GAAG,EAAE;MAAK,CAAC;MACrCC,gBAAgB,EAAE,IAAI;MACtBE,kBAAkB,EAAE;IACtB,CAAC;EACH,CAAC,CAAC;;EAEF;EACA,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAG1D,QAAQ,CAAkC,MAAM;IACtF,MAAM2D,aAAa,GAAGf,YAAY,CAACC,OAAO,CAAC,qBAAqB,CAAC;IACjE,OAAOc,aAAa,IAAuC,UAAU;EACvE,CAAC,CAAC;;EAEF;EACA1D,SAAS,CAAC,MAAM;IACd2C,YAAY,CAACgB,OAAO,CAAC,oBAAoB,EAAEb,IAAI,CAACc,SAAS,CAACpB,OAAO,CAAC,CAAC;EACrE,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;;EAEb;EACAxC,SAAS,CAAC,MAAM;IACd2C,YAAY,CAACgB,OAAO,CAAC,qBAAqB,EAAEH,YAAY,CAAC;EAC3D,CAAC,EAAE,CAACA,YAAY,CAAC,CAAC;;EAElB;EACAxD,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,MAAM6D,KAAK,GAAGxB,aAAa,CAACyB,OAAO;MACnC,IAAID,KAAK,EAAE;QACTE,YAAY,CAACF,KAAK,CAAC;MACrB;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAM;IAAEG,OAAO;IAAEC,aAAa;IAAEC,YAAY;IAAEC;EAAU,CAAC,GAAGzD,eAAe,CAAC8B,OAAO,CAAC;;EAEpF;EACA,MAAM,CAAC4B,UAAU,EAAEC,aAAa,CAAC,GAAGtE,QAAQ,CAAC;IAC3CoD,KAAK,EAAEX,OAAO,CAACU,SAAS,CAACC,KAAK,CAACmB,QAAQ,CAAC,CAAC;IACzClB,GAAG,EAAEZ,OAAO,CAACU,SAAS,CAACE,GAAG,CAACkB,QAAQ,CAAC;EACtC,CAAC,CAAC;;EAEF;EACA,MAAM,CAACC,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGzE,QAAQ,CAAC,KAAK,CAAC;EAC/D,MAAM,CAAC0E,aAAa,EAAEC,gBAAgB,CAAC,GAAG3E,QAAQ,CAAyB,IAAI,CAAC;EAChF,MAAM,CAAC4E,UAAU,EAAEC,aAAa,CAAC,GAAG7E,QAAQ,CAAiB,IAAI,CAAC;;EAIlE;EACA,MAAM8E,eAAe,GAAGA,CAACC,KAAsB,EAAEC,KAAa,KAAK;IACjE,MAAMlC,MAAM,GAAGmC,QAAQ,CAACD,KAAK,CAAC;IAC9B,MAAME,QAAQ,GAAGC,KAAK,CAACrC,MAAM,CAAC,GAAIiC,KAAK,KAAK,OAAO,GAAG,CAAC,GAAG,GAAG,IAAI,GAAIjC,MAAM;IAC3EJ,UAAU,CAAC0C,IAAI,KAAK;MAClB,GAAGA,IAAI;MACPjC,SAAS,EAAE;QAAE,GAAGiC,IAAI,CAACjC,SAAS;QAAE,CAAC4B,KAAK,GAAGG;MAAS;IACpD,CAAC,CAAC,CAAC;EACL,CAAC;;EAED;EACA,MAAMG,kBAAkB,GAAGA,CAACN,KAAsB,EAAEO,CAAwC,KAAK;IAC/F,IAAIA,CAAC,CAACC,GAAG,KAAK,OAAO,EAAE;MAAA,IAAAC,qBAAA,EAAAC,sBAAA;MACrBX,eAAe,CAACC,KAAK,EAAEO,CAAC,CAACI,aAAa,CAACV,KAAK,CAAC;MAC7C;MACA,MAAMW,MAAM,IAAAH,qBAAA,GAAGF,CAAC,CAACI,aAAa,CAACE,aAAa,cAAAJ,qBAAA,wBAAAC,sBAAA,GAA7BD,qBAAA,CAA+BI,aAAa,cAAAH,sBAAA,uBAA5CA,sBAAA,CAA8CI,gBAAgB,CAAC,OAAO,CAAC;MACtF,IAAIF,MAAM,EAAE;QACV,MAAMG,YAAY,GAAGC,KAAK,CAACC,IAAI,CAACL,MAAM,CAAC,CAACM,OAAO,CAACX,CAAC,CAACI,aAAa,CAAC;QAChE,MAAMQ,SAAS,GAAGP,MAAM,CAACG,YAAY,GAAG,CAAC,CAAqB;QAC9D,IAAII,SAAS,EAAE;UACbA,SAAS,CAACC,KAAK,CAAC,CAAC;QACnB;MACF;IACF;EACF,CAAC;;EAED;EACA,MAAMC,qBAAqB,GAAGA,CAACd,CAAsC,EAAEe,MAAuB,KAAK;IAAA,IAAAC,sBAAA;IACjGhB,CAAC,CAACiB,cAAc,CAAC,CAAC;IAClB9B,mBAAmB,CAAC,IAAI,CAAC;IACzBE,gBAAgB,CAAC0B,MAAM,CAAC;IACxB,MAAMG,aAAa,IAAAF,sBAAA,GAAGhB,CAAC,CAACI,aAAa,CAACE,aAAa,cAAAU,sBAAA,uBAA7BA,sBAAA,CAA+BV,aAAa;IAClE,IAAIY,aAAa,EAAE;MACjB3B,aAAa,CAAC2B,aAAa,CAACC,qBAAqB,CAAC,CAAC,CAAC;IACtD;EACF,CAAC;EAED,MAAMC,qBAAqB,GAAGvG,WAAW,CAAEmF,CAA0B,IAAK;IACxE,IAAI,CAACd,gBAAgB,IAAI,CAACE,aAAa,IAAI,CAACE,UAAU,EAAE;IAExD,MAAM+B,IAAI,GAAG/B,UAAU;IACvB,MAAMgC,OAAO,GAAG,SAAS,IAAItB,CAAC,GAAGA,CAAC,CAACuB,OAAO,CAAC,CAAC,CAAC,CAACD,OAAO,GAAGtB,CAAC,CAACsB,OAAO;IACjE,MAAMtF,CAAC,GAAGsF,OAAO,GAAGD,IAAI,CAACG,IAAI;IAC7B,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,GAAG,EAAG5F,CAAC,GAAGqF,IAAI,CAACQ,KAAK,GAAI,GAAG,CAAC,CAAC;;IAErE;IACA,MAAMC,UAAU,GAAG,IAAI,EAAC;IACxB,MAAMC,IAAI,GAAGL,IAAI,CAACM,KAAK,CAAC,CAAC,GAAG,GAAIP,UAAU,GAAG,GAAG,GAAIK,UAAU,CAAC;;IAE/D;IACA,MAAMG,SAAS,GAAGC,cAAc,CAACnD,UAAU,CAACjB,KAAK,EAAE,CAAC,GAAG,CAAC;IACxD,MAAMqE,OAAO,GAAGD,cAAc,CAACnD,UAAU,CAAChB,GAAG,EAAE,IAAI,CAAC;IAEpD,IAAIqE,OAAO,GAAGL,IAAI;IAClB,IAAI3C,aAAa,KAAK,OAAO,EAAE;MAC7BgD,OAAO,GAAGV,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,EAAED,IAAI,CAACE,GAAG,CAACO,OAAO,GAAG,GAAG,EAAEJ,IAAI,CAAC,CAAC;MACvD/C,aAAa,CAACc,IAAI,KAAK;QAAE,GAAGA,IAAI;QAAEhC,KAAK,EAAEsE,OAAO,CAACnD,QAAQ,CAAC;MAAE,CAAC,CAAC,CAAC;MAC/DO,eAAe,CAAC,OAAO,EAAE4C,OAAO,CAACnD,QAAQ,CAAC,CAAC,CAAC;IAC9C,CAAC,MAAM;MACLmD,OAAO,GAAGV,IAAI,CAACC,GAAG,CAACM,SAAS,GAAG,GAAG,EAAEP,IAAI,CAACE,GAAG,CAAC,IAAI,EAAEG,IAAI,CAAC,CAAC;MACzD/C,aAAa,CAACc,IAAI,KAAK;QAAE,GAAGA,IAAI;QAAE/B,GAAG,EAAEqE,OAAO,CAACnD,QAAQ,CAAC;MAAE,CAAC,CAAC,CAAC;MAC7DO,eAAe,CAAC,KAAK,EAAE4C,OAAO,CAACnD,QAAQ,CAAC,CAAC,CAAC;IAC5C;EACF,CAAC,EAAE,CAACC,gBAAgB,EAAEE,aAAa,EAAEE,UAAU,EAAEP,UAAU,EAAES,eAAe,CAAC,CAAC;EAE9E,MAAM6C,mBAAmB,GAAGA,CAAA,KAAM;IAChClD,mBAAmB,CAAC,KAAK,CAAC;IAC1BE,gBAAgB,CAAC,IAAI,CAAC;IACtBE,aAAa,CAAC,IAAI,CAAC;EACrB,CAAC;EAED,MAAM2C,cAAc,GAAGA,CAACxC,KAAa,EAAE4C,YAAoB,KAAa;IACtE,MAAM9E,MAAM,GAAGmC,QAAQ,CAACD,KAAK,CAAC;IAC9B,OAAOG,KAAK,CAACrC,MAAM,CAAC,GAAG8E,YAAY,GAAG9E,MAAM;EAC9C,CAAC;;EAED;EACA7C,SAAS,CAAC,MAAM;IACd,IAAIuE,gBAAgB,EAAE;MACpBqD,QAAQ,CAACC,gBAAgB,CAAC,WAAW,EAAEpB,qBAAqB,CAAC;MAC7DmB,QAAQ,CAACC,gBAAgB,CAAC,SAAS,EAAEH,mBAAmB,CAAC;MACzDE,QAAQ,CAACC,gBAAgB,CAAC,WAAW,EAAEpB,qBAAqB,CAAC;MAC7DmB,QAAQ,CAACC,gBAAgB,CAAC,UAAU,EAAEH,mBAAmB,CAAC;MAE1D,OAAO,MAAM;QACXE,QAAQ,CAACE,mBAAmB,CAAC,WAAW,EAAErB,qBAAqB,CAAC;QAChEmB,QAAQ,CAACE,mBAAmB,CAAC,SAAS,EAAEJ,mBAAmB,CAAC;QAC5DE,QAAQ,CAACE,mBAAmB,CAAC,WAAW,EAAErB,qBAAqB,CAAC;QAChEmB,QAAQ,CAACE,mBAAmB,CAAC,UAAU,EAAEJ,mBAAmB,CAAC;MAC/D,CAAC;IACH;EACF,CAAC,EAAE,CAACnD,gBAAgB,EAAEE,aAAa,EAAEE,UAAU,EAAEP,UAAU,CAAC,CAAC;;EAE7D;EACA,MAAM2D,eAAe,GAAGA,CAAA,KAAM;IAC5BtF,UAAU,CAAC;MACTO,UAAU,EAAE,EAAE;MACdC,SAAS,EAAE,EAAE;MACbC,SAAS,EAAE;QAAEC,KAAK,EAAE,CAAC,GAAG;QAAEC,GAAG,EAAE;MAAK,CAAC;MACrCC,gBAAgB,EAAE,IAAI;MACtBE,kBAAkB,EAAE;IACtB,CAAC,CAAC;IACFc,aAAa,CAAC;MACZlB,KAAK,EAAE,MAAM;MACbC,GAAG,EAAE;IACP,CAAC,CAAC;EACJ,CAAC;;EAEC;EACF,MAAM4E,mBAAmB,GAAIC,QAAgB,IAAK;IAChD,OAAOhE,aAAa,CAAC+B,OAAO,CAACiC,QAAQ,CAAC;EACxC,CAAC;;EAED;EACA,MAAMC,aAAa,GAAIC,SAAiB,IAAK;IAC3C,IAAI3E,YAAY,KAAK,UAAU,EAAE;MAC/B,OAAOrD,gBAAgB,CAACgI,SAAS,CAAC;IACpC,CAAC,MAAM,IAAI3E,YAAY,KAAK,SAAS,EAAE;MACrC;MACA,MAAM4E,aAAa,GAAG,CACpB,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CACtD;MACD,MAAMC,KAAK,GAAGnE,YAAY,CAAC8B,OAAO,CAACmC,SAAS,CAAC;MAC7C,OAAOC,aAAa,CAACC,KAAK,GAAGD,aAAa,CAACE,MAAM,CAAC;IACpD;IACA,OAAO,SAAS,EAAC;EACnB,CAAC;;EAED;EACA,MAAMC,iBAAiB,GAAIJ,SAAiB,IAAK;IAC/C,IAAI3E,YAAY,KAAK,UAAU,EAAE;MAC/B,OAAOpD,oBAAoB,CAAC+H,SAAS,CAAC;IACxC,CAAC,MAAM,IAAI3E,YAAY,KAAK,SAAS,EAAE;MACrC;MACA,MAAMgF,iBAAiB,GAAG,CACxB,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CACtD;MACD,MAAMH,KAAK,GAAGnE,YAAY,CAAC8B,OAAO,CAACmC,SAAS,CAAC;MAC7C,OAAOK,iBAAiB,CAACH,KAAK,GAAGG,iBAAiB,CAACF,MAAM,CAAC;IAC5D;IACA,OAAO,SAAS,EAAC;EACnB,CAAC;;EAED;EACA,MAAMG,kBAAkB,GAAIN,SAAiB,IAAK;IAChD,IAAI3E,YAAY,KAAK,UAAU,EAAE;MAC/B,OAAOnD,qBAAqB,CAAC8H,SAAS,CAAC;IACzC,CAAC,MAAM,IAAI3E,YAAY,KAAK,SAAS,EAAE;MACrC;MACA,MAAMkF,kBAAkB,GAAG,CACzB,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EACrD,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CACtD;MACD,MAAML,KAAK,GAAGnE,YAAY,CAAC8B,OAAO,CAACmC,SAAS,CAAC;MAC7C,OAAOO,kBAAkB,CAACL,KAAK,GAAGK,kBAAkB,CAACJ,MAAM,CAAC;IAC9D;IACA,OAAO,SAAS,EAAC;EACnB,CAAC;;EAED;EACA,MAAMK,cAAc,GAAIC,MAAc,IAAK;IACzC,IAAIpF,YAAY,KAAK,UAAU,EAAE;MAC/B,OAAOoF,MAAM,CAACX,QAAQ;IACxB,CAAC,MAAM,IAAIzE,YAAY,KAAK,SAAS,EAAE;MACrC,OAAO5C,eAAe,CAACgI,MAAM,CAACC,OAAO,CAAC;IACxC;IACA,OAAOD,MAAM,CAACX,QAAQ,EAAC;EACzB,CAAC;;EAED;EACA,MAAMa,UAAU,GAAG,CAAC,GAAG9E,OAAO,CAAC,CAAC+E,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IAC7C,IAAIzF,YAAY,KAAK,UAAU,EAAE;MAC/B;MACA,MAAM0F,YAAY,GAAGlB,mBAAmB,CAACgB,CAAC,CAACf,QAAQ,CAAC,GAAGD,mBAAmB,CAACiB,CAAC,CAAChB,QAAQ,CAAC;MACtF,IAAIiB,YAAY,KAAK,CAAC,EAAE;QACtB,OAAOA,YAAY;MACrB;IACF,CAAC,MAAM,IAAI1F,YAAY,KAAK,SAAS,EAAE;MACrC;MACA,MAAM2F,WAAW,GAAGjF,YAAY,CAAC8B,OAAO,CAACpF,eAAe,CAACoI,CAAC,CAACH,OAAO,CAAC,CAAC,GAAG3E,YAAY,CAAC8B,OAAO,CAACpF,eAAe,CAACqI,CAAC,CAACJ,OAAO,CAAC,CAAC;MACvH,IAAIM,WAAW,KAAK,CAAC,EAAE;QACrB,OAAOA,WAAW;MACpB;IACF;IACA;IACA,OAAOH,CAAC,CAACI,SAAS,GAAGH,CAAC,CAACG,SAAS;EAClC,CAAC,CAAC;;EAEF;EACApJ,SAAS,CAAC,MAAM;IACd,IAAIwC,OAAO,CAACe,kBAAkB,IAAIuF,UAAU,CAACR,MAAM,GAAG,CAAC,EAAE;MACvD;MACA,MAAMe,gBAAgB,GAAGtC,IAAI,CAACE,GAAG,CAAC,GAAG6B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACH,SAAS,CAAC,CAAC;MACtE,MAAMI,gBAAgB,GAAGzC,IAAI,CAACC,GAAG,CAAC,GAAG8B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACE,SAAS,CAAC,CAAC;;MAEtE;MACA,MAAMC,gBAAgB,GAAGlH,OAAO,CAACQ,UAAU,CAACsF,MAAM,GAAG,CAAC,IAAI9F,OAAO,CAACS,SAAS,CAACqF,MAAM,GAAG,CAAC;MAEtF,IAAIqB,YAAY,GAAG;QAAE,GAAGnH,OAAO,CAACU;MAAU,CAAC;MAE3C,IAAIwG,gBAAgB,EAAE;QACpB;QACAC,YAAY,GAAG;UACbxG,KAAK,EAAE4D,IAAI,CAACC,GAAG,CAACxE,OAAO,CAACU,SAAS,CAACC,KAAK,EAAEkG,gBAAgB,CAAC;UAC1DjG,GAAG,EAAE2D,IAAI,CAACE,GAAG,CAACzE,OAAO,CAACU,SAAS,CAACE,GAAG,EAAEoG,gBAAgB;QACvD,CAAC;MACH,CAAC,MAAM;QACL;QACA;QACAG,YAAY,GAAGnH,OAAO,CAACU,SAAS;MAClC;;MAEA;MACA,IAAIyG,YAAY,CAACxG,KAAK,KAAKX,OAAO,CAACU,SAAS,CAACC,KAAK,IAAIwG,YAAY,CAACvG,GAAG,KAAKZ,OAAO,CAACU,SAAS,CAACE,GAAG,EAAE;QAChGX,UAAU,CAAC0C,IAAI,KAAK;UAClB,GAAGA,IAAI;UACPjC,SAAS,EAAEyG;QACb,CAAC,CAAC,CAAC;;QAEH;QACAtF,aAAa,CAAC;UACZlB,KAAK,EAAEwG,YAAY,CAACxG,KAAK,CAACmB,QAAQ,CAAC,CAAC;UACpClB,GAAG,EAAEuG,YAAY,CAACvG,GAAG,CAACkB,QAAQ,CAAC;QACjC,CAAC,CAAC;MACJ;IACF;EACF,CAAC,EAAE,CAAC9B,OAAO,CAACe,kBAAkB,EAAEuF,UAAU,EAAEtG,OAAO,CAACQ,UAAU,EAAER,OAAO,CAACS,SAAS,CAAC,CAAC;;EAEnF;EACAjD,SAAS,CAAC,MAAM;IACd,MAAM4J,YAAY,GAAGA,CAAA,KAAM;MACzB,MAAMC,SAAS,GAAGC,MAAM,CAACC,WAAW,IAAInC,QAAQ,CAACoC,eAAe,CAACH,SAAS;MAC1E7H,aAAa,CAAC6H,SAAS,GAAG,EAAE,CAAC;IAC/B,CAAC;IAEDC,MAAM,CAACjC,gBAAgB,CAAC,QAAQ,EAAE+B,YAAY,CAAC;IAC/C,OAAO,MAAME,MAAM,CAAChC,mBAAmB,CAAC,QAAQ,EAAE8B,YAAY,CAAC;EACjE,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMK,OAAO,GAAGlD,IAAI,CAACE,GAAG,CAAC,GAAG6B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACH,SAAS,CAAC,EAAE5G,OAAO,CAACU,SAAS,CAACC,KAAK,CAAC;EACtF,MAAM+G,OAAO,GAAGnD,IAAI,CAACC,GAAG,CAAC,GAAG8B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACE,SAAS,CAAC,EAAEjH,OAAO,CAACU,SAAS,CAACE,GAAG,CAAC;EACpF,MAAM+G,UAAU,GAAGD,OAAO,GAAGD,OAAO;;EAEpC;EACA,MAAMG,aAAa,GAAG,CAAC,EAAC;EACxB,MAAMC,eAAe,GAAG,EAAE,EAAC;EAC3B,MAAMC,aAAa,GAAGH,UAAU,GAAGC,aAAa,GAAGC,eAAe;;EAElE;EACA;EACA,MAAMhB,gBAAgB,GAAG7G,OAAO,CAACe,kBAAkB,GAC/CwD,IAAI,CAACE,GAAG,CAAC,GAAG6B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACH,SAAS,CAAC,CAAC,GAC7Ca,OAAO;EACX,MAAMT,gBAAgB,GAAGhH,OAAO,CAACe,kBAAkB,GAC/CwD,IAAI,CAACC,GAAG,CAAC,GAAG8B,UAAU,CAACQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACE,SAAS,CAAC,CAAC,GAC7CS,OAAO;EAEX,MAAMK,iBAAiB,GAAG5J,yBAAyB,CAAC0I,gBAAgB,EAAEG,gBAAgB,CAAC;;EAEvF;EACA,MAAMgB,qBAAqB,GAAIC,MAAgB,IAAK;IAClD,MAAMC,IAAgB,GAAG,EAAE;IAE3B,IAAIlH,YAAY,KAAK,MAAM,EAAE;MAC3B;MACA,MAAMmH,OAAmB,GAAG,EAAE;MAE9BF,MAAM,CAACG,OAAO,CAAChC,MAAM,IAAI;QACvB,IAAIiC,MAAM,GAAG,KAAK;;QAElB;QACA,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGH,OAAO,CAACrC,MAAM,EAAEwC,QAAQ,EAAE,EAAE;UAC5D,MAAMC,GAAG,GAAGJ,OAAO,CAACG,QAAQ,CAAC;UAC7B,IAAIE,aAAa,GAAG,IAAI;;UAExB;UACA,KAAK,MAAMC,cAAc,IAAIF,GAAG,EAAE;YAChC,MAAMG,MAAM,GAAG,EAAE,CAAC,CAAC;YACnB,IACEtC,MAAM,CAACQ,SAAS,GAAG8B,MAAM,IAAID,cAAc,CAACxB,SAAS,IACrDb,MAAM,CAACa,SAAS,GAAGyB,MAAM,IAAID,cAAc,CAAC7B,SAAS,EACrD;cACA4B,aAAa,GAAG,KAAK;cACrB;YACF;UACF;;UAEA;UACA,IAAIA,aAAa,EAAE;YACjBL,OAAO,CAACG,QAAQ,CAAC,CAACK,IAAI,CAACvC,MAAM,CAAC;YAC9BiC,MAAM,GAAG,IAAI;YACb;UACF;QACF;;QAEA;QACA,IAAI,CAACA,MAAM,EAAE;UACXF,OAAO,CAACQ,IAAI,CAAC,CAACvC,MAAM,CAAC,CAAC;QACxB;MACF,CAAC,CAAC;MAEF,OAAO+B,OAAO;IAChB;;IAEA;IACA,MAAMS,UAAU,GAAG5H,YAAY,KAAK,UAAU,GAAG,UAAU,GAAG,SAAS;IACvE,MAAM6H,SAAS,GAAG7H,YAAY,KAAK,UAAU,GAAGS,aAAa,GAAGC,YAAY;IAC5E,MAAMoH,MAAmC,GAAG,CAAC,CAAC;;IAE9C;IACAb,MAAM,CAACG,OAAO,CAAChC,MAAM,IAAI;MACvB,IAAI2C,UAAkB;MACtB,IAAIH,UAAU,KAAK,SAAS,EAAE;QAC5B;QACAG,UAAU,GAAG3K,eAAe,CAACgI,MAAM,CAACC,OAAO,CAAC;MAC9C,CAAC,MAAM;QACL0C,UAAU,GAAG3C,MAAM,CAACwC,UAAU,CAAC;MACjC;MAEA,IAAI,CAACE,MAAM,CAACC,UAAU,CAAC,EAAE;QACvBD,MAAM,CAACC,UAAU,CAAC,GAAG,EAAE;MACzB;MACAD,MAAM,CAACC,UAAU,CAAC,CAACJ,IAAI,CAACvC,MAAM,CAAC;IACjC,CAAC,CAAC;;IAEF;IACAyC,SAAS,CAACT,OAAO,CAACW,UAAU,IAAI;MAC9B,IAAID,MAAM,CAACC,UAAU,CAAC,EAAE;QACtB,MAAMC,WAAW,GAAGF,MAAM,CAACC,UAAU,CAAC;QACtC,MAAME,SAAqB,GAAG,EAAE;;QAEhC;QACAD,WAAW,CAACZ,OAAO,CAAChC,MAAM,IAAI;UAC5B,IAAIiC,MAAM,GAAG,KAAK;;UAElB;UACA,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGW,SAAS,CAACnD,MAAM,EAAEwC,QAAQ,EAAE,EAAE;YAC9D,MAAMC,GAAG,GAAGU,SAAS,CAACX,QAAQ,CAAC;YAC/B,IAAIE,aAAa,GAAG,IAAI;;YAExB;YACA,KAAK,MAAMC,cAAc,IAAIF,GAAG,EAAE;cAChC,MAAMG,MAAM,GAAG,EAAE,CAAC,CAAC;cACnB,IACEtC,MAAM,CAACQ,SAAS,GAAG8B,MAAM,IAAID,cAAc,CAACxB,SAAS,IACrDb,MAAM,CAACa,SAAS,GAAGyB,MAAM,IAAID,cAAc,CAAC7B,SAAS,EACrD;gBACA4B,aAAa,GAAG,KAAK;gBACrB;cACF;YACF;;YAEA;YACA,IAAIA,aAAa,EAAE;cACjBS,SAAS,CAACX,QAAQ,CAAC,CAACK,IAAI,CAACvC,MAAM,CAAC;cAChCiC,MAAM,GAAG,IAAI;cACb;YACF;UACF;;UAEA;UACA,IAAI,CAACA,MAAM,EAAE;YACXY,SAAS,CAACN,IAAI,CAAC,CAACvC,MAAM,CAAC,CAAC;UAC1B;QACF,CAAC,CAAC;;QAEF;QACA8B,IAAI,CAACS,IAAI,CAAC,GAAGM,SAAS,CAAC;;QAEvB;QACA,IAAIF,UAAU,KAAKF,SAAS,CAACA,SAAS,CAAC/C,MAAM,GAAG,CAAC,CAAC,EAAE;UAClDoC,IAAI,CAACS,IAAI,CAAC,EAAE,CAAC;QACf;MACF;IACF,CAAC,CAAC;IAEF,OAAOT,IAAI;EACb,CAAC;;EAED;EACA,MAAMgB,YAAY,GAAGlB,qBAAqB,CAAC1B,UAAU,CAAC;;EAEtD;EACA,MAAM6C,WAAW,GAAGD,YAAY,CAACE,MAAM,CAAC,CAACC,MAAM,EAAEd,GAAG,KAAK;IACvD,OAAOc,MAAM,IAAId,GAAG,CAACzC,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,EAAC;EAC/C,CAAC,EAAE,CAAC,CAAC;;EAEL;EACE;EACF,MAAMwD,UAAU,GAAG,EAAE;EACrB,MAAMC,UAAU,GAAG,EAAE,CAAC,CAAC;EACvB,MAAMC,gBAAgB,GAAG,EAAE;;EAE3B;EACA,MAAMC,OAAiB,GAAG,EAAE;EAC5B,CAAC,MAAM;IACL,IAAIC,GAAG,GAAG,CAAC;IACXR,YAAY,CAACd,OAAO,CAACG,GAAG,IAAI;MAC1BkB,OAAO,CAACd,IAAI,CAACe,GAAG,CAAC;MACjB,IAAInB,GAAG,CAACzC,MAAM,KAAK,CAAC,EAAE;QACpB4D,GAAG,IAAIF,gBAAgB;MACzB,CAAC,MAAM;QACLE,GAAG,IAAIJ,UAAU,GAAGC,UAAU;MAChC;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC;EAEJ,MAAMI,sBAAsB,GAAGA,CAAA,KAAM;IACnC,IAAI3I,YAAY,KAAK,MAAM,EAAE;MAC3B,OAAO,EAAE,CAAC,CAAC;IACb;IAEA,MAAM4I,QAA6C,GAAG,EAAE;IACxD,IAAIC,YAAY,GAAG,EAAE;IAErBX,YAAY,CAACd,OAAO,CAAC,CAACG,GAAG,EAAED,QAAQ,KAAK;MACtC,IAAIC,GAAG,CAACzC,MAAM,GAAG,CAAC,EAAE;QAClB,MAAMgE,gBAAgB,GAAGvB,GAAG,CAAC,CAAC,CAAC;QAC/B,IAAIwB,iBAAyB;QAE7B,IAAI/I,YAAY,KAAK,UAAU,EAAE;UAC/B+I,iBAAiB,GAAGD,gBAAgB,CAACrE,QAAQ;QAC/C,CAAC,MAAM,IAAIzE,YAAY,KAAK,SAAS,EAAE;UACrC;UACA+I,iBAAiB,GAAG3L,eAAe,CAAC0L,gBAAgB,CAACzD,OAAO,CAAC;QAC/D,CAAC,MAAM;UACL0D,iBAAiB,GAAGD,gBAAgB,CAACrE,QAAQ;QAC/C;QAEA,IAAIsE,iBAAiB,KAAKF,YAAY,EAAE;UACtC,IAAIA,YAAY,KAAK,EAAE,EAAE;YACvB;YACAD,QAAQ,CAACjB,IAAI,CAAC;cAAElD,QAAQ,EAAEoE,YAAY;cAAEG,GAAG,EAAEP,OAAO,CAACnB,QAAQ,CAAC,GAAG;YAAE,CAAC,CAAC;UACvE;UACAuB,YAAY,GAAGE,iBAAiB;QAClC;MACF;IACF,CAAC,CAAC;;IAEF;IACA,IAAIF,YAAY,KAAK,EAAE,EAAE;MACvBD,QAAQ,CAACjB,IAAI,CAAC;QAAElD,QAAQ,EAAEoE,YAAY;QAAEG,GAAG,EAAEP,OAAO,CAACP,YAAY,CAACpD,MAAM,GAAG,CAAC,CAAC,GAAG;MAAE,CAAC,CAAC;IACtF;IAEA,OAAO8D,QAAQ;EACjB,CAAC;EAED,MAAMK,gBAAgB,GAAGN,sBAAsB,CAAC,CAAC;EAEjD,oBACErL,OAAA;IAAK4L,SAAS,EAAC,KAAK;IAACC,EAAE,EAAC,gBAAgB;IAACC,IAAI,EAAC,MAAM;IAAC,cAAW,mTAAmE;IAAAC,QAAA,gBACjI/L,OAAA,CAACR,SAAS;MACRyB,UAAU,EAAEA,UAAW;MACvBO,YAAY,EAAEA,YAAa;MAC3BC,eAAe,EAAEA,eAAgB;MACjCC,OAAO,EAAEA,OAAQ;MACjBC,UAAU,EAAEA,UAAW;MACvBe,YAAY,EAAEA,YAAa;MAC3BC,eAAe,EAAEA,eAAgB;MACjCQ,aAAa,EAAEA,aAAc;MAC7BC,YAAY,EAAEA,YAAa;MAC3BE,UAAU,EAAEA,UAAW;MACvBC,aAAa,EAAEA,aAAc;MAC7BQ,eAAe,EAAEA,eAAgB;MACjCO,kBAAkB,EAAEA,kBAAmB;MACvC2C,eAAe,EAAEA,eAAgB;MACjC5H,gBAAgB,EAAEA,gBAAiB;MACnC2I,UAAU,EAAEA,UAAW;MACvB3C,qBAAqB,EAAEA,qBAAsB;MAC7C5B,gBAAgB,EAAEA;IAAiB;MAAAuI,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACpC,CAAC,eAEFnM,OAAA;MAAM4L,SAAS,EAAC,oBAAoB;MAACC,EAAE,EAAC,eAAe;MAACC,IAAI,EAAC,QAAQ;MAAC,cAAW,uNAAwC;MAAAC,QAAA,eACvH/L,OAAA,CAACP,QAAQ;QACP4D,SAAS,EAAEA,SAAU;QACrBmG,aAAa,EAAEA,aAAc;QAC7BqB,WAAW,EAAEA,WAAY;QACzBpB,iBAAiB,EAAEA,iBAAkB;QACrCN,OAAO,EAAEA,OAAQ;QACjBG,aAAa,EAAEA,aAAc;QAC7BC,eAAe,EAAEA,eAAgB;QACjCqB,YAAY,EAAEA,YAAa;QAC3BlJ,OAAO,EAAEA,OAAQ;QACjBgB,YAAY,EAAEA,YAAa;QAC3BiJ,gBAAgB,EAAEA,gBAAiB;QACnCvE,aAAa,EAAEA,aAAc;QAC7BK,iBAAiB,EAAEA,iBAAkB;QACrCE,kBAAkB,EAAEA,kBAAmB;QACvCE,cAAc,EAAEA,cAAe;QAC/B1H,aAAa,EAAEA,aAAc;QAC7BC,gBAAgB,EAAEA,gBAAiB;QACnCC,aAAa,EAAEA,aAAc;QAC7BC,gBAAgB,EAAEA,gBAAiB;QACnCG,WAAW,EAAEA,WAAY;QACzBC,cAAc,EAAEA,cAAe;QAC/BS,uBAAuB,EAAEA,uBAAwB;QACjDC,0BAA0B,EAAEA,0BAA2B;QACvDT,kBAAkB,EAAEA,kBAAmB;QACvCC,qBAAqB,EAAEA,qBAAsB;QAC7CC,0BAA0B,EAAEA,0BAA2B;QACvDC,6BAA6B,EAAEA,6BAA8B;QAC7DC,sBAAsB,EAAEA,sBAAuB;QAC/CC,yBAAyB,EAAEA,yBAA0B;QACrDO,aAAa,EAAEA,aAAc;QAC7ByG,UAAU,EAAEA,UAAW;QACvB3G,cAAc,EAAEA,cAAe;QAC/BC,iBAAiB,EAAEA;MAAkB;QAAA0K,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACtC;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC,eAECnM,OAAA;MAAO4L,SAAS,EAAC,oBAAoB;MAACC,EAAE,EAAC,gBAAgB;MAAC,cAAW,6IAA0B;MAAAE,QAAA,eACrG/L,OAAA,CAACN,QAAQ;QACPS,aAAa,EAAEA,aAAc;QAC7BM,WAAW,EAAEA,WAAY;QACzBJ,aAAa,EAAEA,aAAc;QAC7BM,kBAAkB,EAAEA,kBAAmB;QACvCI,sBAAsB,EAAEA,sBAAuB;QAC/CF,0BAA0B,EAAEA,0BAA2B;QACvDuG,aAAa,EAAEA,aAAc;QAC7BS,cAAc,EAAEA,cAAe;QAC/BxI,gBAAgB,EAAEA;MAAiB;QAAA2M,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACpC;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACG,CAAC,eAGRnM,OAAA,CAACL,iBAAiB;MAChB0B,cAAc,EAAEA,cAAe;MAC/B+K,OAAO,EAAEA,CAAA,KAAM9K,iBAAiB,CAAC,IAAI,CAAE;MACvC8F,aAAa,EAAEA,aAAc;MAC7BS,cAAc,EAAEA,cAAe;MAC/BxI,gBAAgB,EAAEA;IAAiB;MAAA2M,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACpC,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV;AAACjM,EAAA,CAvmBQD,GAAG;EAAA,QA4DkDL,eAAe;AAAA;AAAAyM,EAAA,GA5DpEpM,GAAG;AAymBZ,eAAeA,GAAG;AAAA,IAAAoM,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}