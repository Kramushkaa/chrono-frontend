{"ast":null,"code":"// API functions for connecting to backend\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'https://chrono-back-kramushka.amvera.io';\n\n// Safe decode function\nconst safeDecode = str => {\n  if (!str) return '';\n\n  // Если строка не содержит символов кодировки, возвращаем как есть\n  if (!str.includes('%')) {\n    return str;\n  }\n  try {\n    const decoded = decodeURIComponent(str);\n    // Проверяем, что декодирование не создало некорректные символы\n    if (decoded.includes('') || decoded.includes('\\\\u')) {\n      console.warn('Decoding created invalid characters, returning original:', str);\n      return str;\n    }\n    return decoded;\n  } catch (error) {\n    console.warn('Failed to decode string:', str, error);\n    return str;\n  }\n};\n\n// Types for API responses\n\n// Helper function to build query string from filters\nconst buildQueryString = filters => {\n  const params = new URLSearchParams();\n  if (filters.category) {\n    params.append('category', filters.category);\n  }\n  if (filters.country) {\n    params.append('country', filters.country);\n  }\n  if (filters.startYear !== undefined) {\n    params.append('startYear', filters.startYear.toString());\n  }\n  if (filters.endYear !== undefined) {\n    params.append('endYear', filters.endYear.toString());\n  }\n  return params.toString();\n};\n\n// Get persons with optional filters\nexport const getPersons = async (filters = {}) => {\n  try {\n    const queryString = buildQueryString(filters);\n    const url = `${API_BASE_URL}/api/persons${queryString ? `?${queryString}` : ''}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 секунд таймаут\n\n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Преобразуем данные в правильный формат с безопасной декодировкой\n    let transformedData = data.map(person => ({\n      id: person.id,\n      name: safeDecode(person.name || ''),\n      birthYear: person.birthYear,\n      deathYear: person.deathYear,\n      category: safeDecode(person.category || ''),\n      country: safeDecode(person.country || ''),\n      description: safeDecode(person.description || ''),\n      imageUrl: person.imageUrl,\n      reignStart: person.reignStart,\n      reignEnd: person.reignEnd,\n      achievementYear1: person.achievementYear1,\n      achievementYear2: person.achievementYear2,\n      achievementYear3: person.achievementYear3,\n      achievements: Array.isArray(person.achievements) ? person.achievements.map(a => safeDecode(a || '')) : []\n    }));\n\n    // Дополнительная фильтрация на клиенте для множественных стран\n    if (filters.country) {\n      const selectedCountries = filters.country.split(',').map(c => c.trim());\n      transformedData = transformedData.filter(person => {\n        const personCountries = person.country.includes('/') ? person.country.split('/').map(c => c.trim()) : [person.country];\n        return selectedCountries.some(selected => personCountries.includes(selected));\n      });\n    }\n    return transformedData;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Request timeout:', error);\n    } else {\n      console.error('Error fetching persons:', error);\n    }\n    // Return empty array as fallback\n    return [];\n  }\n};\n\n// Get all categories\nexport const getCategories = async () => {\n  try {\n    const url = `${API_BASE_URL}/api/categories`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Безопасная декодировка категорий\n    return data.map(category => safeDecode(category || ''));\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Categories request timeout:', error);\n    } else {\n      console.error('Error fetching categories:', error);\n    }\n    // Return default categories as fallback\n    return ['Политик', 'Ученый', 'Художник', 'Писатель', 'Военачальник'];\n  }\n};\n\n// Get all countries\nexport const getCountries = async () => {\n  try {\n    const url = `${API_BASE_URL}/api/countries`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n\n    // Безопасная декодировка стран и разбивка множественных стран\n    const allCountries = new Set();\n    data.forEach(country => {\n      const decodedCountry = safeDecode(country || '');\n      if (decodedCountry.includes('/')) {\n        // Разбиваем множественные страны на отдельные\n        const countries = decodedCountry.split('/').map(c => c.trim());\n        countries.forEach(c => {\n          if (c) allCountries.add(c);\n        });\n      } else {\n        allCountries.add(decodedCountry);\n      }\n    });\n\n    // Сортируем страны по алфавиту\n    return Array.from(allCountries).sort();\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Countries request timeout:', error);\n    } else {\n      console.error('Error fetching countries:', error);\n    }\n    // Return default countries as fallback\n    return ['Древний Рим', 'Древняя Греция', 'Древний Египет', 'Китай', 'Индия'];\n  }\n};\n\n// Test connection to backend\nexport const testBackendConnection = async () => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/api/health`);\n    return response.ok;\n  } catch (error) {\n    console.error('Backend connection test failed:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["API_BASE_URL","process","env","REACT_APP_API_URL","safeDecode","str","includes","decoded","decodeURIComponent","console","warn","error","buildQueryString","filters","params","URLSearchParams","category","append","country","startYear","undefined","toString","endYear","getPersons","queryString","url","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","clearTimeout","ok","Error","status","data","json","transformedData","map","person","id","name","birthYear","deathYear","description","imageUrl","reignStart","reignEnd","achievementYear1","achievementYear2","achievementYear3","achievements","Array","isArray","a","selectedCountries","split","c","trim","filter","personCountries","some","selected","getCategories","getCountries","allCountries","Set","forEach","decodedCountry","countries","add","from","sort","testBackendConnection"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/services/api.ts"],"sourcesContent":["// API functions for connecting to backend\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'https://chrono-back-kramushka.amvera.io';\n\n// Safe decode function\nconst safeDecode = (str: string): string => {\n  if (!str) return '';\n  \n  // Если строка не содержит символов кодировки, возвращаем как есть\n  if (!str.includes('%')) {\n    return str;\n  }\n  \n  try {\n    const decoded = decodeURIComponent(str);\n    // Проверяем, что декодирование не создало некорректные символы\n    if (decoded.includes('') || decoded.includes('\\\\u')) {\n      console.warn('Decoding created invalid characters, returning original:', str);\n      return str;\n    }\n    return decoded;\n  } catch (error) {\n    console.warn('Failed to decode string:', str, error);\n    return str;\n  }\n};\n\n\n// Types for API responses\ninterface Person {\n  id: string;\n  name: string;\n  birthYear: number;\n  deathYear: number;\n  category: string;\n  country: string;\n  description: string;\n  imageUrl?: string;\n  reignStart?: number;\n  reignEnd?: number;\n  achievementYear1?: number;\n  achievementYear2?: number;\n  achievementYear3?: number;\n  achievements: string[];\n}\n\ninterface ApiFilters {\n  category?: string;\n  country?: string;\n  startYear?: number;\n  endYear?: number;\n}\n\n// Helper function to build query string from filters\nconst buildQueryString = (filters: ApiFilters): string => {\n  const params = new URLSearchParams();\n  \n  if (filters.category) {\n    params.append('category', filters.category);\n  }\n  if (filters.country) {\n    params.append('country', filters.country);\n  }\n  if (filters.startYear !== undefined) {\n    params.append('startYear', filters.startYear.toString());\n  }\n  if (filters.endYear !== undefined) {\n    params.append('endYear', filters.endYear.toString());\n  }\n  \n  return params.toString();\n};\n\n// Get persons with optional filters\nexport const getPersons = async (filters: ApiFilters = {}): Promise<Person[]> => {\n  try {\n    const queryString = buildQueryString(filters);\n    const url = `${API_BASE_URL}/api/persons${queryString ? `?${queryString}` : ''}`;\n    \n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 секунд таймаут\n    \n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Преобразуем данные в правильный формат с безопасной декодировкой\n    let transformedData = data.map((person: {\n      id: string;\n      name?: string;\n      birthYear: number;\n      deathYear: number;\n      category?: string;\n      country?: string;\n      description?: string;\n      imageUrl?: string;\n      reignStart?: number;\n      reignEnd?: number;\n      achievementYear1?: number;\n      achievementYear2?: number;\n      achievementYear3?: number;\n      achievements?: string[];\n    }) => ({\n      id: person.id,\n      name: safeDecode(person.name || ''),\n      birthYear: person.birthYear,\n      deathYear: person.deathYear,\n      category: safeDecode(person.category || ''),\n      country: safeDecode(person.country || ''),\n      description: safeDecode(person.description || ''),\n      imageUrl: person.imageUrl,\n      reignStart: person.reignStart,\n      reignEnd: person.reignEnd,\n      achievementYear1: person.achievementYear1,\n      achievementYear2: person.achievementYear2,\n      achievementYear3: person.achievementYear3,\n      achievements: Array.isArray(person.achievements) ? person.achievements.map((a: string) => safeDecode(a || '')) : []\n    }));\n    \n    // Дополнительная фильтрация на клиенте для множественных стран\n    if (filters.country) {\n      const selectedCountries = filters.country.split(',').map((c: string) => c.trim());\n      transformedData = transformedData.filter((person: Person) => {\n        const personCountries = person.country.includes('/') \n          ? person.country.split('/').map((c: string) => c.trim())\n          : [person.country];\n        return selectedCountries.some((selected: string) => personCountries.includes(selected));\n      });\n    }\n    \n    return transformedData;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Request timeout:', error);\n    } else {\n      console.error('Error fetching persons:', error);\n    }\n    // Return empty array as fallback\n    return [];\n  }\n};\n\n// Get all categories\nexport const getCategories = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/categories`;\n    \n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n    \n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка категорий\n    return data.map((category: string) => safeDecode(category || ''));\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Categories request timeout:', error);\n    } else {\n      console.error('Error fetching categories:', error);\n    }\n    // Return default categories as fallback\n    return ['Политик', 'Ученый', 'Художник', 'Писатель', 'Военачальник'];\n  }\n};\n\n// Get all countries\nexport const getCountries = async (): Promise<string[]> => {\n  try {\n    const url = `${API_BASE_URL}/api/countries`;\n    \n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000);\n    \n    const response = await fetch(url, {\n      signal: controller.signal\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Безопасная декодировка стран и разбивка множественных стран\n    const allCountries = new Set<string>();\n    \n    data.forEach((country: string | null) => {\n      const decodedCountry = safeDecode(country || '');\n      if (decodedCountry.includes('/')) {\n        // Разбиваем множественные страны на отдельные\n        const countries = decodedCountry.split('/').map(c => c.trim());\n        countries.forEach(c => {\n          if (c) allCountries.add(c);\n        });\n      } else {\n        allCountries.add(decodedCountry);\n      }\n    });\n    \n    // Сортируем страны по алфавиту\n    return Array.from(allCountries).sort();\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.error('Countries request timeout:', error);\n    } else {\n      console.error('Error fetching countries:', error);\n    }\n    // Return default countries as fallback\n    return ['Древний Рим', 'Древняя Греция', 'Древний Египет', 'Китай', 'Индия'];\n  }\n};\n\n// Test connection to backend\nexport const testBackendConnection = async (): Promise<boolean> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/api/health`);\n    return response.ok;\n  } catch (error) {\n    console.error('Backend connection test failed:', error);\n    return false;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}