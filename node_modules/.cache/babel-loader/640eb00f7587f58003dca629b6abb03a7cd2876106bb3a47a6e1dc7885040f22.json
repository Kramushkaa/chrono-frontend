{"ast":null,"code":"import React,{useState,useEffect,useMemo,useCallback}from'react';import{AppHeader}from'./components/AppHeader';import{Timeline}from'./components/Timeline';import{Tooltips}from'./components/Tooltips';import{MobilePersonPanel}from'./components/MobilePersonPanel';import{useTimelineData}from'./hooks/useTimelineData';import{useFilters}from'./hooks/useFilters';import{useSlider}from'./hooks/useSlider';import{useTooltip}from'./hooks/useTooltip';import{useTimelineDrag}from'./hooks/useTimelineDrag';import{generateCenturyBoundaries,getFirstCountry}from'./utils/timelineUtils';import{getGroupColor,getGroupColorDark,getGroupColorMuted,getPersonGroup,sortGroupedData}from'./utils/groupingUtils';import'./App.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function App(){const[isScrolled,setIsScrolled]=useState(false);const[activeAchievementMarker,setActiveAchievementMarker]=useState(null);const[selectedPerson,setSelectedPerson]=useState(null);const[showControls,setShowControls]=useState(true);// Используем кастомные хуки\nconst{filters,setFilters,groupingType,setGroupingType,yearInputs,setYearInputs,applyYearFilter,handleYearKeyPress,resetAllFilters}=useFilters();const{persons,allCategories,allCountries,isLoading}=useTimelineData(filters);// Безопасная версия хука useSlider\nconst sliderHook=useSlider();// Проверяем, что все функции slider определены\nconsole.log('Slider functions check:',{handleSliderMouseDown:typeof(sliderHook===null||sliderHook===void 0?void 0:sliderHook.handleSliderMouseDown),handleSliderMouseMove:typeof(sliderHook===null||sliderHook===void 0?void 0:sliderHook.handleSliderMouseMove),handleSliderMouseUp:typeof(sliderHook===null||sliderHook===void 0?void 0:sliderHook.handleSliderMouseUp)});// Создаем безопасные функции-обертки с дополнительными проверками\nconst safeHandleSliderMouseDown=useMemo(()=>{if(!sliderHook||typeof sliderHook.handleSliderMouseDown!=='function'){return()=>{console.warn('handleSliderMouseDown is not defined');};}return sliderHook.handleSliderMouseDown;},[sliderHook]);const safeHandleSliderMouseMove=useMemo(()=>{if(!sliderHook||typeof sliderHook.handleSliderMouseMove!=='function'){return()=>{console.warn('handleSliderMouseMove is not defined');};}return sliderHook.handleSliderMouseMove;},[sliderHook]);const safeHandleSliderMouseUp=useMemo(()=>{if(!sliderHook||typeof sliderHook.handleSliderMouseUp!=='function'){return()=>{console.warn('handleSliderMouseUp is not defined');};}return sliderHook.handleSliderMouseUp;},[sliderHook]);const{isDraggingSlider}=sliderHook||{};const{hoveredPerson,mousePosition,showTooltip,hoveredAchievement,setHoveredAchievement,achievementTooltipPosition,setAchievementTooltipPosition,showAchievementTooltip,// eslint-disable-next-line @typescript-eslint/no-unused-vars\nsetShowAchievementTooltip,hoverTimerRef,handlePersonHover,handleAchievementHover}=useTooltip();// Добавляем обработчики событий мыши и touch\nuseEffect(()=>{// Проверяем, что все функции определены и sliderHook существует\nif(!sliderHook||!safeHandleSliderMouseMove||!safeHandleSliderMouseDown||!safeHandleSliderMouseUp){console.error('Safe slider functions are not defined:',{sliderHook:!!sliderHook,safeHandleSliderMouseMove:typeof safeHandleSliderMouseMove,safeHandleSliderMouseDown:typeof safeHandleSliderMouseDown,safeHandleSliderMouseUp:typeof safeHandleSliderMouseUp});return;}if(isDraggingSlider){const handleMouseMove=e=>{try{safeHandleSliderMouseMove(e,yearInputs,applyYearFilter,setYearInputs);}catch(error){console.error('Error in handleMouseMove:',error);}};const handleMouseUp=()=>{try{safeHandleSliderMouseUp();}catch(error){console.error('Error in handleMouseUp:',error);}};document.addEventListener('mousemove',handleMouseMove);document.addEventListener('mouseup',handleMouseUp);document.addEventListener('touchmove',handleMouseMove);document.addEventListener('touchend',handleMouseUp);return()=>{document.removeEventListener('mousemove',handleMouseMove);document.removeEventListener('mouseup',handleMouseUp);document.removeEventListener('touchmove',handleMouseMove);document.removeEventListener('touchend',handleMouseUp);};}},[sliderHook,isDraggingSlider,safeHandleSliderMouseDown,safeHandleSliderMouseMove,safeHandleSliderMouseUp,yearInputs,applyYearFilter,setYearInputs]);// Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\nconst sortedData=sortGroupedData(persons,groupingType);// Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\nuseEffect(()=>{if(filters.hideEmptyCenturies&&sortedData.length>0){// Вычисляем эффективный диапазон на основе отфильтрованных данных\nconst effectiveMinYear=Math.min(...sortedData.map(p=>p.birthYear));const effectiveMaxYear=Math.max(...sortedData.map(p=>p.deathYear));// Проверяем, есть ли активные фильтры (категории или страны)\nconst hasActiveFilters=filters.categories.length>0||filters.countries.length>0;let newTimeRange={...filters.timeRange};if(hasActiveFilters){// Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\nnewTimeRange={start:Math.max(filters.timeRange.start,effectiveMinYear),end:Math.min(filters.timeRange.end,effectiveMaxYear)};}else{// Если нет активных фильтров, НЕ сужаем диапазон\n// Пользователь может хотеть видеть данные за пределами текущего диапазона\nnewTimeRange=filters.timeRange;}// Обновляем только если диапазон изменился\nif(newTimeRange.start!==filters.timeRange.start||newTimeRange.end!==filters.timeRange.end){setFilters(prev=>({...prev,timeRange:newTimeRange}));// Обновляем поля ввода\nsetYearInputs({start:newTimeRange.start.toString(),end:newTimeRange.end.toString()});}}},[filters.hideEmptyCenturies,sortedData,filters.categories,filters.countries,filters.timeRange,setFilters,setYearInputs]);// Отслеживаем скролл\nuseEffect(()=>{const handleScroll=()=>{const scrollTop=window.pageYOffset||document.documentElement.scrollTop;setIsScrolled(scrollTop>50);};window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);// Обработчик для закрытия achievement tooltip на мобильных\nuseEffect(()=>{const handleCloseAchievementTooltip=()=>{handleAchievementHover(null,0,0);};const handleClickOutside=event=>{// Проверяем, что клик был вне tooltip'а и вне маркеров достижений\nconst target=event.target;const tooltip=document.getElementById('achievement-tooltip');const isClickInsideTooltip=tooltip===null||tooltip===void 0?void 0:tooltip.contains(target);const isClickOnMarker=target.closest('.achievement-marker');// Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\nif(!isClickInsideTooltip&&!isClickOnMarker&&showAchievementTooltip){if(event.type==='touchstart'){setTimeout(()=>{handleAchievementHover(null,0,0);},100);}else{handleAchievementHover(null,0,0);}}};window.addEventListener('closeAchievementTooltip',handleCloseAchievementTooltip);document.addEventListener('mousedown',handleClickOutside);document.addEventListener('touchstart',handleClickOutside);return()=>{window.removeEventListener('closeAchievementTooltip',handleCloseAchievementTooltip);document.removeEventListener('mousedown',handleClickOutside);document.removeEventListener('touchstart',handleClickOutside);};},[handleAchievementHover,showAchievementTooltip]);// Мемоизируем вычисления диапазона лет\nconst{minYear,totalYears,effectiveMinYear,effectiveMaxYear}=useMemo(()=>{const minYear=Math.min(...sortedData.map(p=>p.birthYear),filters.timeRange.start);const maxYear=Math.max(...sortedData.map(p=>p.deathYear),filters.timeRange.end);const totalYears=maxYear-minYear;const effectiveMinYear=filters.hideEmptyCenturies?Math.min(...sortedData.map(p=>p.birthYear)):minYear;const effectiveMaxYear=filters.hideEmptyCenturies?Math.max(...sortedData.map(p=>p.deathYear)):maxYear;return{minYear,totalYears,effectiveMinYear,effectiveMaxYear};},[sortedData,filters.timeRange.start,filters.timeRange.end,filters.hideEmptyCenturies]);// Настройки масштаба\nconst pixelsPerYear=3;// 3 пикселя на год\nconst LEFT_PADDING_PX=30;// отступ слева, чтобы крайняя левая подпись не упиралась в край\nconst timelineWidth=totalYears*pixelsPerYear+LEFT_PADDING_PX;// Хук для перетаскивания timeline\nconst{timelineRef,isDragging,handleMouseDown,handleMouseMove,handleMouseUp,handleTouchStart,handleTouchMove,handleTouchEnd}=useTimelineDrag({timelineWidth,containerWidth:window.innerWidth});// Мемоизируем границы веков\nconst centuryBoundaries=useMemo(()=>generateCenturyBoundaries(effectiveMinYear,effectiveMaxYear),[effectiveMinYear,effectiveMaxYear]);// Мемоизируем алгоритм размещения полосок на строках\nconst calculateRowPlacement=useCallback(people=>{const rows=[];if(groupingType==='none'){// Без группировки - просто размещаем всех в строки\nconst allRows=[];people.forEach(person=>{let placed=false;// Проверяем каждую существующую строку\nfor(let rowIndex=0;rowIndex<allRows.length;rowIndex++){const row=allRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){allRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){allRows.push([person]);}});return allRows;}// Группировка по категориям или странам\nconst groupField=groupingType==='category'?'category':'country';const allGroups=groupingType==='category'?allCategories:allCountries;const groups={};// Группируем людей по выбранному полю\npeople.forEach(person=>{let groupValue;if(groupField==='country'){// Для стран берем первую из списка, если есть несколько через \"/\"\ngroupValue=getFirstCountry(person.country);}else{groupValue=person[groupField];}if(!groups[groupValue]){groups[groupValue]=[];}groups[groupValue].push(person);});// Обрабатываем каждую группу в заданном порядке\nallGroups.forEach(groupValue=>{if(groups[groupValue]){const groupPeople=groups[groupValue];const groupRows=[];// Размещаем людей данной группы в отдельные строки\ngroupPeople.forEach(person=>{let placed=false;// Проверяем каждую существующую строку для этой группы\nfor(let rowIndex=0;rowIndex<groupRows.length;rowIndex++){const row=groupRows[rowIndex];let canPlaceInRow=true;// Проверяем, не пересекается ли с кем-то в этой строке\nfor(const existingPerson of row){const BUFFER=20;// минимальный зазор между персонами\nif(person.birthYear-BUFFER<=existingPerson.deathYear&&person.deathYear+BUFFER>=existingPerson.birthYear){canPlaceInRow=false;break;}}// Если можно разместить в этой строке\nif(canPlaceInRow){groupRows[rowIndex].push(person);placed=true;break;}}// Если не удалось разместить в существующих строках, создаем новую\nif(!placed){groupRows.push([person]);}});// Добавляем строки данной группы к общему списку\nrows.push(...groupRows);// Добавляем пустую строку для визуального разделения (кроме последней группы)\nif(groupValue!==allGroups[allGroups.length-1]){rows.push([]);}}});return rows;},[groupingType,allCategories,allCountries]);// Мемоизируем размещение по строкам\nconst rowPlacement=useMemo(()=>calculateRowPlacement(sortedData),[calculateRowPlacement,sortedData]);// Мемоизируем общую высоту\nconst totalHeight=useMemo(()=>rowPlacement.reduce((height,row)=>{return height+(row.length===0?20:70);// 20px для пустых строк, 70px для обычных (60px + 10px margin)\n},0),[rowPlacement]);// Функция для создания разделителей категорий\n// Высота строки и отступ вниз для непустой строки\nconst ROW_HEIGHT=60;const ROW_MARGIN=10;// margin-bottom, используется только для непустых строк\nconst EMPTY_ROW_HEIGHT=20;// Мемоизируем вычисление позиций строк\nconst rowTops=useMemo(()=>{const tops=[];let acc=0;rowPlacement.forEach(row=>{tops.push(acc);if(row.length===0){acc+=EMPTY_ROW_HEIGHT;}else{acc+=ROW_HEIGHT+ROW_MARGIN;}});return tops;},[rowPlacement]);const createCategoryDividers=useCallback(()=>{if(groupingType==='none'){return[];// Без группировки нет разделителей\n}const dividers=[];let currentGroup='';rowPlacement.forEach((row,rowIndex)=>{if(row.length>0){const firstPersonInRow=row[0];let currentGroupValue;if(groupingType==='category'){currentGroupValue=firstPersonInRow.category;}else if(groupingType==='country'){// Для стран берем первую из списка\ncurrentGroupValue=getFirstCountry(firstPersonInRow.country);}else{currentGroupValue=firstPersonInRow.category;}if(currentGroupValue!==currentGroup){if(currentGroup!==''){// закрываем предыдущую группу\ndividers.push({category:currentGroup,top:rowTops[rowIndex]-5});}currentGroup=currentGroupValue;}}});// Добавляем разделитель для последней группы\nif(currentGroup!==''){dividers.push({category:currentGroup,top:rowTops[rowPlacement.length-1]-5});}return dividers;},[groupingType,rowPlacement,rowTops]);const categoryDividers=useMemo(()=>createCategoryDividers(),[createCategoryDividers]);return/*#__PURE__*/_jsxs(\"div\",{className:\"app\",id:\"chrononinja-app\",role:\"main\",\"aria-label\":\"Chrono Ninja - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",children:[/*#__PURE__*/_jsx(AppHeader,{isScrolled:isScrolled,showControls:showControls,setShowControls:setShowControls,filters:filters,setFilters:setFilters,groupingType:groupingType,setGroupingType:setGroupingType,allCategories:allCategories,allCountries:allCountries,yearInputs:yearInputs,setYearInputs:setYearInputs,applyYearFilter:applyYearFilter,handleYearKeyPress:handleYearKeyPress,resetAllFilters:resetAllFilters,getCategoryColor:getGroupColor,sortedData:sortedData,handleSliderMouseDown:safeHandleSliderMouseDown,handleSliderMouseMove:safeHandleSliderMouseMove,handleSliderMouseUp:safeHandleSliderMouseUp,isDraggingSlider:isDraggingSlider}),/*#__PURE__*/_jsxs(\"div\",{className:\"timeline-wrapper\",children:[isLoading&&/*#__PURE__*/_jsxs(\"div\",{className:\"loading-overlay\",role:\"status\",\"aria-live\":\"polite\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"spinner\",\"aria-hidden\":\"true\"}),/*#__PURE__*/_jsx(\"span\",{children:\"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445...\"})]}),/*#__PURE__*/_jsx(\"main\",{ref:timelineRef,className:`timeline-container ${isDragging?'dragging':''}`,id:\"timeline-viewport\",role:\"region\",\"aria-label\":\"\\u041E\\u0431\\u043B\\u0430\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0430 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 \\u043B\\u0438\\u043D\\u0438\\u0438\",onMouseDown:handleMouseDown,onMouseMove:handleMouseMove,onMouseUp:handleMouseUp,onMouseLeave:handleMouseUp,onTouchStart:handleTouchStart,onTouchMove:handleTouchMove,onTouchEnd:handleTouchEnd,children:/*#__PURE__*/_jsx(Timeline,{isLoading:false,timelineWidth:timelineWidth,totalHeight:totalHeight,centuryBoundaries:centuryBoundaries,minYear:minYear,pixelsPerYear:pixelsPerYear,LEFT_PADDING_PX:LEFT_PADDING_PX,rowPlacement:rowPlacement,filters:filters,groupingType:groupingType,categoryDividers:categoryDividers,getGroupColor:getGroupColor,getGroupColorDark:getGroupColorDark,getGroupColorMuted:getGroupColorMuted,getPersonGroup:person=>getPersonGroup(person,groupingType),hoveredPerson:hoveredPerson,setHoveredPerson:person=>{if(person){// Используем текущую позицию мыши из состояния\nhandlePersonHover(person,mousePosition.x,mousePosition.y);}else{handlePersonHover(null,0,0);}},mousePosition:mousePosition,setMousePosition:position=>{// Обновляем позицию мыши\nif(hoveredPerson){handlePersonHover(hoveredPerson,position.x,position.y);}},showTooltip:showTooltip,setShowTooltip:show=>{if(!show&&hoveredPerson){handlePersonHover(null,0,0);}},activeAchievementMarker:activeAchievementMarker,setActiveAchievementMarker:setActiveAchievementMarker,hoveredAchievement:hoveredAchievement,setHoveredAchievement:setHoveredAchievement,achievementTooltipPosition:achievementTooltipPosition,setAchievementTooltipPosition:setAchievementTooltipPosition,showAchievementTooltip:showAchievementTooltip,setShowAchievementTooltip:show=>{if(!show&&hoveredAchievement){handleAchievementHover(null,0,0);}},handlePersonHover:handlePersonHover,handleAchievementHover:handleAchievementHover,hoverTimerRef:hoverTimerRef,sortedData:sortedData,selectedPerson:selectedPerson,setSelectedPerson:setSelectedPerson})})]}),/*#__PURE__*/_jsx(\"aside\",{className:\"tooltips-container\",id:\"tooltips-aside\",\"aria-label\":\"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",children:/*#__PURE__*/_jsx(Tooltips,{hoveredPerson:hoveredPerson,showTooltip:showTooltip,mousePosition:mousePosition,hoveredAchievement:hoveredAchievement,showAchievementTooltip:showAchievementTooltip,achievementTooltipPosition:achievementTooltipPosition,getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})}),/*#__PURE__*/_jsx(MobilePersonPanel,{selectedPerson:selectedPerson,onClose:()=>setSelectedPerson(null),getGroupColor:getGroupColor,getPersonGroup:person=>getPersonGroup(person,groupingType),getCategoryColor:getGroupColor})]});}export default App;","map":{"version":3,"names":["React","useState","useEffect","useMemo","useCallback","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","useFilters","useSlider","useTooltip","useTimelineDrag","generateCenturyBoundaries","getFirstCountry","getGroupColor","getGroupColorDark","getGroupColorMuted","getPersonGroup","sortGroupedData","jsx","_jsx","jsxs","_jsxs","App","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","showControls","setShowControls","filters","setFilters","groupingType","setGroupingType","yearInputs","setYearInputs","applyYearFilter","handleYearKeyPress","resetAllFilters","persons","allCategories","allCountries","isLoading","sliderHook","console","log","handleSliderMouseDown","handleSliderMouseMove","handleSliderMouseUp","safeHandleSliderMouseDown","warn","safeHandleSliderMouseMove","safeHandleSliderMouseUp","isDraggingSlider","hoveredPerson","mousePosition","showTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","setShowAchievementTooltip","hoverTimerRef","handlePersonHover","handleAchievementHover","error","handleMouseMove","e","handleMouseUp","document","addEventListener","removeEventListener","sortedData","hideEmptyCenturies","length","effectiveMinYear","Math","min","map","p","birthYear","effectiveMaxYear","max","deathYear","hasActiveFilters","categories","countries","newTimeRange","timeRange","start","end","prev","toString","handleScroll","scrollTop","window","pageYOffset","documentElement","handleCloseAchievementTooltip","handleClickOutside","event","target","tooltip","getElementById","isClickInsideTooltip","contains","isClickOnMarker","closest","type","setTimeout","minYear","totalYears","maxYear","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","timelineRef","isDragging","handleMouseDown","handleTouchStart","handleTouchMove","handleTouchEnd","containerWidth","innerWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","person","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","country","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","tops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","category","top","categoryDividers","className","id","role","children","getCategoryColor","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","setHoveredPerson","x","y","setMousePosition","position","setShowTooltip","show","onClose"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react'\nimport { Person } from './types'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { useFilters } from './hooks/useFilters'\nimport { useSlider } from './hooks/useSlider'\nimport { useTooltip } from './hooks/useTooltip'\nimport { useTimelineDrag } from './hooks/useTimelineDrag'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport { \n  getGroupColor, \n  getGroupColorDark, \n  getGroupColorMuted, \n  getPersonGroup,\n  sortGroupedData\n} from './utils/groupingUtils'\nimport './App.css'\n\nfunction App() {\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const [showControls, setShowControls] = useState(true)\n\n  // Используем кастомные хуки\n  const { \n    filters, \n    setFilters, \n    groupingType, \n    setGroupingType, \n    yearInputs, \n    setYearInputs, \n    applyYearFilter, \n    handleYearKeyPress, \n    resetAllFilters \n  } = useFilters()\n  \n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Безопасная версия хука useSlider\n  const sliderHook = useSlider();\n  \n  // Проверяем, что все функции slider определены\n  console.log('Slider functions check:', {\n    handleSliderMouseDown: typeof sliderHook?.handleSliderMouseDown,\n    handleSliderMouseMove: typeof sliderHook?.handleSliderMouseMove,\n    handleSliderMouseUp: typeof sliderHook?.handleSliderMouseUp\n  });\n\n  // Создаем безопасные функции-обертки с дополнительными проверками\n  const safeHandleSliderMouseDown = useMemo(() => {\n    if (!sliderHook || typeof sliderHook.handleSliderMouseDown !== 'function') {\n      return () => {\n        console.warn('handleSliderMouseDown is not defined');\n      };\n    }\n    return sliderHook.handleSliderMouseDown;\n  }, [sliderHook]);\n  \n  const safeHandleSliderMouseMove = useMemo(() => {\n    if (!sliderHook || typeof sliderHook.handleSliderMouseMove !== 'function') {\n      return () => {\n        console.warn('handleSliderMouseMove is not defined');\n      };\n    }\n    return sliderHook.handleSliderMouseMove;\n  }, [sliderHook]);\n  \n  const safeHandleSliderMouseUp = useMemo(() => {\n    if (!sliderHook || typeof sliderHook.handleSliderMouseUp !== 'function') {\n      return () => {\n        console.warn('handleSliderMouseUp is not defined');\n      };\n    }\n    return sliderHook.handleSliderMouseUp;\n  }, [sliderHook]);\n\n  const { isDraggingSlider } = sliderHook || {};\n\n\n  \n  const { \n    hoveredPerson, \n    mousePosition, \n    showTooltip, \n    hoveredAchievement, \n    setHoveredAchievement,\n    achievementTooltipPosition, \n    setAchievementTooltipPosition,\n    showAchievementTooltip, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setShowAchievementTooltip,\n    hoverTimerRef, \n    handlePersonHover, \n    handleAchievementHover \n  } = useTooltip()\n\n\n\n\n\n\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    // Проверяем, что все функции определены и sliderHook существует\n    if (!sliderHook || !safeHandleSliderMouseMove || !safeHandleSliderMouseDown || !safeHandleSliderMouseUp) {\n      console.error('Safe slider functions are not defined:', { \n        sliderHook: !!sliderHook,\n        safeHandleSliderMouseMove: typeof safeHandleSliderMouseMove, \n        safeHandleSliderMouseDown: typeof safeHandleSliderMouseDown, \n        safeHandleSliderMouseUp: typeof safeHandleSliderMouseUp \n      });\n      return;\n    }\n\n    if (isDraggingSlider) {\n      const handleMouseMove = (e: MouseEvent | TouchEvent) => {\n        try {\n          safeHandleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs);\n        } catch (error) {\n          console.error('Error in handleMouseMove:', error);\n        }\n      };\n      \n      const handleMouseUp = () => {\n        try {\n          safeHandleSliderMouseUp();\n        } catch (error) {\n          console.error('Error in handleMouseUp:', error);\n        }\n      };\n      \n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.addEventListener('touchmove', handleMouseMove)\n      document.addEventListener('touchend', handleMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleMouseMove)\n        document.removeEventListener('touchend', handleMouseUp)\n      }\n    }\n  }, [sliderHook, isDraggingSlider, safeHandleSliderMouseDown, safeHandleSliderMouseMove, safeHandleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs])\n\n\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType)\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Обработчик для закрытия achievement tooltip на мобильных\n  useEffect(() => {\n    const handleCloseAchievementTooltip = () => {\n      handleAchievementHover(null, 0, 0);\n    };\n\n    const handleClickOutside = (event: Event) => {\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\n      const target = event.target as Element;\n      const tooltip = document.getElementById('achievement-tooltip');\n      const isClickInsideTooltip = tooltip?.contains(target);\n      const isClickOnMarker = target.closest('.achievement-marker');\n      \n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\n        if (event.type === 'touchstart') {\n          setTimeout(() => {\n            handleAchievementHover(null, 0, 0);\n          }, 100);\n        } else {\n          handleAchievementHover(null, 0, 0);\n        }\n      }\n    };\n\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('touchstart', handleClickOutside);\n    \n    return () => {\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('touchstart', handleClickOutside);\n    };\n  }, [handleAchievementHover, showAchievementTooltip]);\n\n  // Мемоизируем вычисления диапазона лет\n  const { minYear, totalYears, effectiveMinYear, effectiveMaxYear } = useMemo(() => {\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n    const totalYears = maxYear - minYear\n    \n    const effectiveMinYear = filters.hideEmptyCenturies \n      ? Math.min(...sortedData.map(p => p.birthYear))\n      : minYear\n    const effectiveMaxYear = filters.hideEmptyCenturies \n      ? Math.max(...sortedData.map(p => p.deathYear))\n      : maxYear\n    \n    return { minYear, totalYears, effectiveMinYear, effectiveMaxYear }\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies])\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Хук для перетаскивания timeline\n  const {\n    timelineRef,\n    isDragging,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  } = useTimelineDrag({\n    timelineWidth,\n    containerWidth: window.innerWidth\n  })\n\n  // Мемоизируем границы веков\n  const centuryBoundaries = useMemo(() => \n    generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear),\n    [effectiveMinYear, effectiveMaxYear]\n  )\n\n  // Мемоизируем алгоритм размещения полосок на строках\n  const calculateRowPlacement = useCallback((people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }, [groupingType, allCategories, allCountries])\n\n  // Мемоизируем размещение по строкам\n  const rowPlacement = useMemo(() => \n    calculateRowPlacement(sortedData),\n    [calculateRowPlacement, sortedData]\n  )\n\n  // Мемоизируем общую высоту\n  const totalHeight = useMemo(() => \n    rowPlacement.reduce((height, row) => {\n      return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n    }, 0),\n    [rowPlacement]\n  )\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Мемоизируем вычисление позиций строк\n  const rowTops = useMemo(() => {\n    const tops: number[] = [];\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      tops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n    return tops;\n  }, [rowPlacement]);\n\n  const createCategoryDividers = useCallback(() => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  }, [groupingType, rowPlacement, rowTops]);\n\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\n\n  return (\n    <div className=\"app\" id=\"chrononinja-app\" role=\"main\" aria-label=\"Chrono Ninja - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getGroupColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={safeHandleSliderMouseDown}\n        handleSliderMouseMove={safeHandleSliderMouseMove}\n        handleSliderMouseUp={safeHandleSliderMouseUp}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <div className=\"timeline-wrapper\">\n        {/* Загрузка только для области timeline */}\n        {isLoading && (\n          <div className=\"loading-overlay\" role=\"status\" aria-live=\"polite\">\n            <div className=\"spinner\" aria-hidden=\"true\"></div>\n            <span>Загрузка данных...</span>\n          </div>\n        )}\n        \n        <main \n          ref={timelineRef}\n          className={`timeline-container ${isDragging ? 'dragging' : ''}`}\n          id=\"timeline-viewport\" \n          role=\"region\" \n          aria-label=\"Область просмотра временной линии\"\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onTouchStart={handleTouchStart}\n          onTouchMove={handleTouchMove}\n          onTouchEnd={handleTouchEnd}\n        >\n          <Timeline\n          isLoading={false}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={(person) => {\n            if (person) {\n              // Используем текущую позицию мыши из состояния\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\n            } else {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          mousePosition={mousePosition}\n          setMousePosition={(position) => {\n            // Обновляем позицию мыши\n            if (hoveredPerson) {\n              handlePersonHover(hoveredPerson, position.x, position.y);\n            }\n          }}\n          showTooltip={showTooltip}\n          setShowTooltip={(show) => {\n            if (!show && hoveredPerson) {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={setHoveredAchievement}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={setAchievementTooltipPosition}\n          showAchievementTooltip={showAchievementTooltip}\n                  setShowAchievementTooltip={(show) => {\n          if (!show && hoveredAchievement) {\n            handleAchievementHover(null, 0, 0);\n          }\n        }}\n        handlePersonHover={handlePersonHover}\n        handleAchievementHover={handleAchievementHover}\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n        </main>\n      </div>\n\n      <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          getCategoryColor={getGroupColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n        getCategoryColor={getGroupColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}