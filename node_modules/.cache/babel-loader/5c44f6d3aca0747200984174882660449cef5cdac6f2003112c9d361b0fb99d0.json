{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Selecty\\\\Documents\\\\PetProjects\\\\chronoline-frontend\\\\src\\\\App.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { AppHeader } from './components/AppHeader';\nimport { Timeline } from './components/Timeline';\nimport { Tooltips } from './components/Tooltips';\nimport { MobilePersonPanel } from './components/MobilePersonPanel';\nimport { useTimelineData } from './hooks/useTimelineData';\nimport { useFilters } from './hooks/useFilters';\nimport { useSlider } from './hooks/useSlider';\nimport { useTooltip } from './hooks/useTooltip';\nimport { useTimelineDrag } from './hooks/useTimelineDrag';\nimport { generateCenturyBoundaries, getFirstCountry } from './utils/timelineUtils';\nimport { getGroupColor, getGroupColorDark, getGroupColorMuted, getPersonGroup, sortGroupedData } from './utils/groupingUtils';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [isScrolled, setIsScrolled] = useState(false);\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState(null);\n  const [selectedPerson, setSelectedPerson] = useState(null);\n  const [showControls, setShowControls] = useState(true);\n\n  // Используем кастомные хуки\n  const {\n    filters,\n    setFilters,\n    groupingType,\n    setGroupingType,\n    yearInputs,\n    setYearInputs,\n    applyYearFilter,\n    handleYearKeyPress,\n    resetAllFilters\n  } = useFilters();\n  const {\n    persons,\n    allCategories,\n    allCountries,\n    isLoading\n  } = useTimelineData(filters);\n\n  // Безопасная версия хука useSlider\n  const sliderHook = useSlider();\n\n  // Проверяем, что все функции slider определены\n  console.log('Slider functions check:', {\n    handleSliderMouseDown: typeof sliderHook.handleSliderMouseDown,\n    handleSliderMouseMove: typeof sliderHook.handleSliderMouseMove,\n    handleSliderMouseUp: typeof sliderHook.handleSliderMouseUp\n  });\n\n  // Создаем безопасные функции-обертки\n  const safeHandleSliderMouseDown = useMemo(() => sliderHook.handleSliderMouseDown || (() => {\n    console.warn('handleSliderMouseDown is not defined');\n  }), [sliderHook.handleSliderMouseDown]);\n  const safeHandleSliderMouseMove = useMemo(() => sliderHook.handleSliderMouseMove || (() => {\n    console.warn('handleSliderMouseMove is not defined');\n  }), [sliderHook.handleSliderMouseMove]);\n  const safeHandleSliderMouseUp = useMemo(() => sliderHook.handleSliderMouseUp || (() => {\n    console.warn('handleSliderMouseUp is not defined');\n  }), [sliderHook.handleSliderMouseUp]);\n  const {\n    isDraggingSlider\n  } = sliderHook;\n  const {\n    hoveredPerson,\n    mousePosition,\n    showTooltip,\n    hoveredAchievement,\n    setHoveredAchievement,\n    achievementTooltipPosition,\n    setAchievementTooltipPosition,\n    showAchievementTooltip,\n    hoverTimerRef,\n    handlePersonHover,\n    handleAchievementHover\n  } = useTooltip();\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    // Проверяем, что все функции определены\n    if (!safeHandleSliderMouseMove || !safeHandleSliderMouseDown || !safeHandleSliderMouseUp) {\n      console.error('Safe slider functions are not defined:', {\n        safeHandleSliderMouseMove,\n        safeHandleSliderMouseDown,\n        safeHandleSliderMouseUp\n      });\n      return;\n    }\n    if (isDraggingSlider) {\n      const handleMouseMove = e => safeHandleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs);\n      const handleMouseUp = () => safeHandleSliderMouseUp();\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      document.addEventListener('touchmove', handleMouseMove);\n      document.addEventListener('touchend', handleMouseUp);\n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        document.removeEventListener('touchmove', handleMouseMove);\n        document.removeEventListener('touchend', handleMouseUp);\n      };\n    }\n  }, [isDraggingSlider, safeHandleSliderMouseDown, safeHandleSliderMouseMove, safeHandleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs]);\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType);\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n\n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      let newTimeRange = {\n        ...filters.timeRange\n      };\n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n\n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n\n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      setIsScrolled(scrollTop > 50);\n    };\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  // Обработчик для закрытия achievement tooltip на мобильных\n  useEffect(() => {\n    const handleCloseAchievementTooltip = () => {\n      handleAchievementHover(null, 0, 0);\n    };\n    const handleClickOutside = event => {\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\n      const target = event.target;\n      const tooltip = document.getElementById('achievement-tooltip');\n      const isClickInsideTooltip = tooltip === null || tooltip === void 0 ? void 0 : tooltip.contains(target);\n      const isClickOnMarker = target.closest('.achievement-marker');\n\n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\n        if (event.type === 'touchstart') {\n          setTimeout(() => {\n            handleAchievementHover(null, 0, 0);\n          }, 100);\n        } else {\n          handleAchievementHover(null, 0, 0);\n        }\n      }\n    };\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('touchstart', handleClickOutside);\n    return () => {\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('touchstart', handleClickOutside);\n    };\n  }, [handleAchievementHover, showAchievementTooltip]);\n\n  // Мемоизируем вычисления диапазона лет\n  const {\n    minYear,\n    totalYears,\n    effectiveMinYear,\n    effectiveMaxYear\n  } = useMemo(() => {\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start);\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end);\n    const totalYears = maxYear - minYear;\n    const effectiveMinYear = filters.hideEmptyCenturies ? Math.min(...sortedData.map(p => p.birthYear)) : minYear;\n    const effectiveMaxYear = filters.hideEmptyCenturies ? Math.max(...sortedData.map(p => p.deathYear)) : maxYear;\n    return {\n      minYear,\n      totalYears,\n      effectiveMinYear,\n      effectiveMaxYear\n    };\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies]);\n\n  // Настройки масштаба\n  const pixelsPerYear = 3; // 3 пикселя на год\n  const LEFT_PADDING_PX = 30; // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX;\n\n  // Хук для перетаскивания timeline\n  const {\n    timelineRef,\n    isDragging,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  } = useTimelineDrag({\n    timelineWidth,\n    containerWidth: window.innerWidth\n  });\n\n  // Мемоизируем границы веков\n  const centuryBoundaries = useMemo(() => generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear), [effectiveMinYear, effectiveMaxYear]);\n\n  // Мемоизируем алгоритм размещения полосок на строках\n  const calculateRowPlacement = useCallback(people => {\n    const rows = [];\n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows = [];\n      people.forEach(person => {\n        let placed = false;\n\n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex];\n          let canPlaceInRow = true;\n\n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n              canPlaceInRow = false;\n              break;\n            }\n          }\n\n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person);\n            placed = true;\n            break;\n          }\n        }\n\n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person]);\n        }\n      });\n      return allRows;\n    }\n\n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country';\n    const allGroups = groupingType === 'category' ? allCategories : allCountries;\n    const groups = {};\n\n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue;\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country);\n      } else {\n        groupValue = person[groupField];\n      }\n      if (!groups[groupValue]) {\n        groups[groupValue] = [];\n      }\n      groups[groupValue].push(person);\n    });\n\n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue];\n        const groupRows = [];\n\n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false;\n\n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex];\n            let canPlaceInRow = true;\n\n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (person.birthYear - BUFFER <= existingPerson.deathYear && person.deathYear + BUFFER >= existingPerson.birthYear) {\n                canPlaceInRow = false;\n                break;\n              }\n            }\n\n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person);\n              placed = true;\n              break;\n            }\n          }\n\n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person]);\n          }\n        });\n\n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows);\n\n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([]);\n        }\n      }\n    });\n    return rows;\n  }, [groupingType, allCategories, allCountries]);\n\n  // Мемоизируем размещение по строкам\n  const rowPlacement = useMemo(() => calculateRowPlacement(sortedData), [calculateRowPlacement, sortedData]);\n\n  // Мемоизируем общую высоту\n  const totalHeight = useMemo(() => rowPlacement.reduce((height, row) => {\n    return height + (row.length === 0 ? 20 : 70); // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n  }, 0), [rowPlacement]);\n\n  // Функция для создания разделителей категорий\n  // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Мемоизируем вычисление позиций строк\n  const rowTops = useMemo(() => {\n    const tops = [];\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      tops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n    return tops;\n  }, [rowPlacement]);\n  const createCategoryDividers = useCallback(() => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n    const dividers = [];\n    let currentGroup = '';\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue;\n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({\n              category: currentGroup,\n              top: rowTops[rowIndex] - 5\n            });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({\n        category: currentGroup,\n        top: rowTops[rowPlacement.length - 1] - 5\n      });\n    }\n    return dividers;\n  }, [groupingType, rowPlacement, rowTops]);\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    id: \"chrononinja-app\",\n    role: \"main\",\n    \"aria-label\": \"Chrono Ninja - \\u0418\\u043D\\u0442\\u0435\\u0440\\u0430\\u043A\\u0442\\u0438\\u0432\\u043D\\u0430\\u044F \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0430\\u044F \\u043B\\u0438\\u043D\\u0438\\u044F \\u0438\\u0441\\u0442\\u043E\\u0440\\u0438\\u0447\\u0435\\u0441\\u043A\\u0438\\u0445 \\u043B\\u0438\\u0447\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439\",\n    children: [/*#__PURE__*/_jsxDEV(AppHeader, {\n      isScrolled: isScrolled,\n      showControls: showControls,\n      setShowControls: setShowControls,\n      filters: filters,\n      setFilters: setFilters,\n      groupingType: groupingType,\n      setGroupingType: setGroupingType,\n      allCategories: allCategories,\n      allCountries: allCountries,\n      yearInputs: yearInputs,\n      setYearInputs: setYearInputs,\n      applyYearFilter: applyYearFilter,\n      handleYearKeyPress: handleYearKeyPress,\n      resetAllFilters: resetAllFilters,\n      getCategoryColor: getGroupColor,\n      sortedData: sortedData,\n      handleSliderMouseDown: safeHandleSliderMouseDown,\n      handleSliderMouseMove: safeHandleSliderMouseMove,\n      handleSliderMouseUp: safeHandleSliderMouseUp,\n      isDraggingSlider: isDraggingSlider\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 460,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"timeline-wrapper\",\n      children: [isLoading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"loading-overlay\",\n        role: \"status\",\n        \"aria-live\": \"polite\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"spinner\",\n          \"aria-hidden\": \"true\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 487,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445...\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 488,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 486,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n        ref: timelineRef,\n        className: `timeline-container ${isDragging ? 'dragging' : ''}`,\n        id: \"timeline-viewport\",\n        role: \"region\",\n        \"aria-label\": \"\\u041E\\u0431\\u043B\\u0430\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0430 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 \\u043B\\u0438\\u043D\\u0438\\u0438\",\n        onMouseDown: handleMouseDown,\n        onMouseMove: handleMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        onTouchStart: handleTouchStart,\n        onTouchMove: handleTouchMove,\n        onTouchEnd: handleTouchEnd,\n        children: /*#__PURE__*/_jsxDEV(Timeline, {\n          isLoading: false,\n          timelineWidth: timelineWidth,\n          totalHeight: totalHeight,\n          centuryBoundaries: centuryBoundaries,\n          minYear: minYear,\n          pixelsPerYear: pixelsPerYear,\n          LEFT_PADDING_PX: LEFT_PADDING_PX,\n          rowPlacement: rowPlacement,\n          filters: filters,\n          groupingType: groupingType,\n          categoryDividers: categoryDividers,\n          getGroupColor: getGroupColor,\n          getGroupColorDark: getGroupColorDark,\n          getGroupColorMuted: getGroupColorMuted,\n          getPersonGroup: person => getPersonGroup(person, groupingType),\n          hoveredPerson: hoveredPerson,\n          setHoveredPerson: person => {\n            if (person) {\n              // Используем текущую позицию мыши из состояния\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\n            } else {\n              handlePersonHover(null, 0, 0);\n            }\n          },\n          mousePosition: mousePosition,\n          setMousePosition: position => {\n            // Обновляем позицию мыши\n            if (hoveredPerson) {\n              handlePersonHover(hoveredPerson, position.x, position.y);\n            }\n          },\n          showTooltip: showTooltip,\n          setShowTooltip: show => {\n            if (!show && hoveredPerson) {\n              handlePersonHover(null, 0, 0);\n            }\n          },\n          activeAchievementMarker: activeAchievementMarker,\n          setActiveAchievementMarker: setActiveAchievementMarker,\n          hoveredAchievement: hoveredAchievement,\n          setHoveredAchievement: setHoveredAchievement,\n          achievementTooltipPosition: achievementTooltipPosition,\n          setAchievementTooltipPosition: setAchievementTooltipPosition,\n          showAchievementTooltip: showAchievementTooltip,\n          setShowAchievementTooltip: show => {\n            if (!show && hoveredAchievement) {\n              handleAchievementHover(null, 0, 0);\n            }\n          },\n          handlePersonHover: handlePersonHover,\n          handleAchievementHover: handleAchievementHover,\n          hoverTimerRef: hoverTimerRef,\n          sortedData: sortedData,\n          selectedPerson: selectedPerson,\n          setSelectedPerson: setSelectedPerson\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 506,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 492,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 483,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"aside\", {\n      className: \"tooltips-container\",\n      id: \"tooltips-aside\",\n      \"aria-label\": \"\\u0418\\u043D\\u0444\\u043E\\u0440\\u043C\\u0430\\u0446\\u0438\\u043E\\u043D\\u043D\\u044B\\u0435 \\u043F\\u043E\\u0434\\u0441\\u043A\\u0430\\u0437\\u043A\\u0438\",\n      children: /*#__PURE__*/_jsxDEV(Tooltips, {\n        hoveredPerson: hoveredPerson,\n        showTooltip: showTooltip,\n        mousePosition: mousePosition,\n        hoveredAchievement: hoveredAchievement,\n        showAchievementTooltip: showAchievementTooltip,\n        achievementTooltipPosition: achievementTooltipPosition,\n        getGroupColor: getGroupColor,\n        getPersonGroup: person => getPersonGroup(person, groupingType),\n        getCategoryColor: getGroupColor\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 567,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 566,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(MobilePersonPanel, {\n      selectedPerson: selectedPerson,\n      onClose: () => setSelectedPerson(null),\n      getGroupColor: getGroupColor,\n      getPersonGroup: person => getPersonGroup(person, groupingType),\n      getCategoryColor: getGroupColor\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 581,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 459,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"/sNkBZBYxkXKioD5DacyJjBdAAU=\", false, function () {\n  return [useFilters, useTimelineData, useSlider, useTooltip, useTimelineDrag];\n});\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useMemo","useCallback","AppHeader","Timeline","Tooltips","MobilePersonPanel","useTimelineData","useFilters","useSlider","useTooltip","useTimelineDrag","generateCenturyBoundaries","getFirstCountry","getGroupColor","getGroupColorDark","getGroupColorMuted","getPersonGroup","sortGroupedData","jsxDEV","_jsxDEV","App","_s","isScrolled","setIsScrolled","activeAchievementMarker","setActiveAchievementMarker","selectedPerson","setSelectedPerson","showControls","setShowControls","filters","setFilters","groupingType","setGroupingType","yearInputs","setYearInputs","applyYearFilter","handleYearKeyPress","resetAllFilters","persons","allCategories","allCountries","isLoading","sliderHook","console","log","handleSliderMouseDown","handleSliderMouseMove","handleSliderMouseUp","safeHandleSliderMouseDown","warn","safeHandleSliderMouseMove","safeHandleSliderMouseUp","isDraggingSlider","hoveredPerson","mousePosition","showTooltip","hoveredAchievement","setHoveredAchievement","achievementTooltipPosition","setAchievementTooltipPosition","showAchievementTooltip","hoverTimerRef","handlePersonHover","handleAchievementHover","error","handleMouseMove","e","handleMouseUp","document","addEventListener","removeEventListener","sortedData","hideEmptyCenturies","length","effectiveMinYear","Math","min","map","p","birthYear","effectiveMaxYear","max","deathYear","hasActiveFilters","categories","countries","newTimeRange","timeRange","start","end","prev","toString","handleScroll","scrollTop","window","pageYOffset","documentElement","handleCloseAchievementTooltip","handleClickOutside","event","target","tooltip","getElementById","isClickInsideTooltip","contains","isClickOnMarker","closest","type","setTimeout","minYear","totalYears","maxYear","pixelsPerYear","LEFT_PADDING_PX","timelineWidth","timelineRef","isDragging","handleMouseDown","handleTouchStart","handleTouchMove","handleTouchEnd","containerWidth","innerWidth","centuryBoundaries","calculateRowPlacement","people","rows","allRows","forEach","person","placed","rowIndex","row","canPlaceInRow","existingPerson","BUFFER","push","groupField","allGroups","groups","groupValue","country","groupPeople","groupRows","rowPlacement","totalHeight","reduce","height","ROW_HEIGHT","ROW_MARGIN","EMPTY_ROW_HEIGHT","rowTops","tops","acc","createCategoryDividers","dividers","currentGroup","firstPersonInRow","currentGroupValue","category","top","categoryDividers","className","id","role","children","getCategoryColor","fileName","_jsxFileName","lineNumber","columnNumber","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","setHoveredPerson","x","y","setMousePosition","position","setShowTooltip","show","setShowAchievementTooltip","onClose","_c","$RefreshReg$"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/App.tsx"],"sourcesContent":["import React, { useState, useEffect, useMemo, useCallback } from 'react'\nimport { Person } from './types'\nimport { AppHeader } from './components/AppHeader'\nimport { Timeline } from './components/Timeline'\nimport { Tooltips } from './components/Tooltips'\nimport { MobilePersonPanel } from './components/MobilePersonPanel'\nimport { useTimelineData } from './hooks/useTimelineData'\nimport { useFilters } from './hooks/useFilters'\nimport { useSlider } from './hooks/useSlider'\nimport { useTooltip } from './hooks/useTooltip'\nimport { useTimelineDrag } from './hooks/useTimelineDrag'\nimport { \n  generateCenturyBoundaries,\n  getFirstCountry\n} from './utils/timelineUtils'\nimport { \n  getGroupColor, \n  getGroupColorDark, \n  getGroupColorMuted, \n  getPersonGroup,\n  sortGroupedData\n} from './utils/groupingUtils'\nimport './App.css'\n\nfunction App() {\n  const [isScrolled, setIsScrolled] = useState(false)\n  const [activeAchievementMarker, setActiveAchievementMarker] = useState<{ personId: string; index: number } | null>(null)\n  const [selectedPerson, setSelectedPerson] = useState<Person | null>(null)\n  const [showControls, setShowControls] = useState(true)\n\n  // Используем кастомные хуки\n  const { \n    filters, \n    setFilters, \n    groupingType, \n    setGroupingType, \n    yearInputs, \n    setYearInputs, \n    applyYearFilter, \n    handleYearKeyPress, \n    resetAllFilters \n  } = useFilters()\n  \n  const { persons, allCategories, allCountries, isLoading } = useTimelineData(filters)\n\n  // Безопасная версия хука useSlider\n  const sliderHook = useSlider();\n  \n  // Проверяем, что все функции slider определены\n  console.log('Slider functions check:', {\n    handleSliderMouseDown: typeof sliderHook.handleSliderMouseDown,\n    handleSliderMouseMove: typeof sliderHook.handleSliderMouseMove,\n    handleSliderMouseUp: typeof sliderHook.handleSliderMouseUp\n  });\n\n  // Создаем безопасные функции-обертки\n  const safeHandleSliderMouseDown = useMemo(() => \n    sliderHook.handleSliderMouseDown || (() => {\n      console.warn('handleSliderMouseDown is not defined');\n    }), [sliderHook.handleSliderMouseDown]\n  );\n  \n  const safeHandleSliderMouseMove = useMemo(() => \n    sliderHook.handleSliderMouseMove || (() => {\n      console.warn('handleSliderMouseMove is not defined');\n    }), [sliderHook.handleSliderMouseMove]\n  );\n  \n  const safeHandleSliderMouseUp = useMemo(() => \n    sliderHook.handleSliderMouseUp || (() => {\n      console.warn('handleSliderMouseUp is not defined');\n    }), [sliderHook.handleSliderMouseUp]\n  );\n\n  const { isDraggingSlider } = sliderHook;\n\n\n  \n  const { \n    hoveredPerson, \n    mousePosition, \n    showTooltip, \n    hoveredAchievement, \n    setHoveredAchievement,\n    achievementTooltipPosition, \n    setAchievementTooltipPosition,\n    showAchievementTooltip, \n    hoverTimerRef, \n    handlePersonHover, \n    handleAchievementHover \n  } = useTooltip()\n\n\n\n\n\n\n\n  // Добавляем обработчики событий мыши и touch\n  useEffect(() => {\n    // Проверяем, что все функции определены\n    if (!safeHandleSliderMouseMove || !safeHandleSliderMouseDown || !safeHandleSliderMouseUp) {\n      console.error('Safe slider functions are not defined:', { safeHandleSliderMouseMove, safeHandleSliderMouseDown, safeHandleSliderMouseUp });\n      return;\n    }\n\n    if (isDraggingSlider) {\n      const handleMouseMove = (e: MouseEvent | TouchEvent) => \n        safeHandleSliderMouseMove(e, yearInputs, applyYearFilter, setYearInputs)\n      \n      const handleMouseUp = () => safeHandleSliderMouseUp()\n      \n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.addEventListener('touchmove', handleMouseMove)\n      document.addEventListener('touchend', handleMouseUp)\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove)\n        document.removeEventListener('mouseup', handleMouseUp)\n        document.removeEventListener('touchmove', handleMouseMove)\n        document.removeEventListener('touchend', handleMouseUp)\n      }\n    }\n  }, [isDraggingSlider, safeHandleSliderMouseDown, safeHandleSliderMouseMove, safeHandleSliderMouseUp, yearInputs, applyYearFilter, setYearInputs])\n\n\n\n  // Функция фильтрации данных (теперь данные фильтруются на бэкенде, но сортировка остается)\n  const sortedData = sortGroupedData(persons, groupingType)\n\n  // Автоматически обновляем диапазон дат при изменении настройки скрытия пустых веков\n  useEffect(() => {\n    if (filters.hideEmptyCenturies && sortedData.length > 0) {\n      // Вычисляем эффективный диапазон на основе отфильтрованных данных\n      const effectiveMinYear = Math.min(...sortedData.map(p => p.birthYear));\n      const effectiveMaxYear = Math.max(...sortedData.map(p => p.deathYear));\n      \n      // Проверяем, есть ли активные фильтры (категории или страны)\n      const hasActiveFilters = filters.categories.length > 0 || filters.countries.length > 0;\n      \n      let newTimeRange = { ...filters.timeRange };\n      \n      if (hasActiveFilters) {\n        // Если есть активные фильтры, сужаем диапазон до отфильтрованных данных\n        newTimeRange = {\n          start: Math.max(filters.timeRange.start, effectiveMinYear),\n          end: Math.min(filters.timeRange.end, effectiveMaxYear)\n        };\n      } else {\n        // Если нет активных фильтров, НЕ сужаем диапазон\n        // Пользователь может хотеть видеть данные за пределами текущего диапазона\n        newTimeRange = filters.timeRange;\n      }\n      \n      // Обновляем только если диапазон изменился\n      if (newTimeRange.start !== filters.timeRange.start || newTimeRange.end !== filters.timeRange.end) {\n        setFilters(prev => ({\n          ...prev,\n          timeRange: newTimeRange\n        }));\n        \n        // Обновляем поля ввода\n        setYearInputs({\n          start: newTimeRange.start.toString(),\n          end: newTimeRange.end.toString()\n        });\n      }\n    }\n  }, [filters.hideEmptyCenturies, sortedData, filters.categories, filters.countries, filters.timeRange, setFilters, setYearInputs]);\n\n  // Отслеживаем скролл\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop\n      setIsScrolled(scrollTop > 50)\n    }\n\n    window.addEventListener('scroll', handleScroll)\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [])\n\n  // Обработчик для закрытия achievement tooltip на мобильных\n  useEffect(() => {\n    const handleCloseAchievementTooltip = () => {\n      handleAchievementHover(null, 0, 0);\n    };\n\n    const handleClickOutside = (event: Event) => {\n      // Проверяем, что клик был вне tooltip'а и вне маркеров достижений\n      const target = event.target as Element;\n      const tooltip = document.getElementById('achievement-tooltip');\n      const isClickInsideTooltip = tooltip?.contains(target);\n      const isClickOnMarker = target.closest('.achievement-marker');\n      \n      // Добавляем небольшую задержку для touch событий, чтобы избежать случайного закрытия\n      if (!isClickInsideTooltip && !isClickOnMarker && showAchievementTooltip) {\n        if (event.type === 'touchstart') {\n          setTimeout(() => {\n            handleAchievementHover(null, 0, 0);\n          }, 100);\n        } else {\n          handleAchievementHover(null, 0, 0);\n        }\n      }\n    };\n\n    window.addEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('touchstart', handleClickOutside);\n    \n    return () => {\n      window.removeEventListener('closeAchievementTooltip', handleCloseAchievementTooltip);\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('touchstart', handleClickOutside);\n    };\n  }, [handleAchievementHover, showAchievementTooltip]);\n\n  // Мемоизируем вычисления диапазона лет\n  const { minYear, totalYears, effectiveMinYear, effectiveMaxYear } = useMemo(() => {\n    const minYear = Math.min(...sortedData.map(p => p.birthYear), filters.timeRange.start)\n    const maxYear = Math.max(...sortedData.map(p => p.deathYear), filters.timeRange.end)\n    const totalYears = maxYear - minYear\n    \n    const effectiveMinYear = filters.hideEmptyCenturies \n      ? Math.min(...sortedData.map(p => p.birthYear))\n      : minYear\n    const effectiveMaxYear = filters.hideEmptyCenturies \n      ? Math.max(...sortedData.map(p => p.deathYear))\n      : maxYear\n    \n    return { minYear, totalYears, effectiveMinYear, effectiveMaxYear }\n  }, [sortedData, filters.timeRange.start, filters.timeRange.end, filters.hideEmptyCenturies])\n\n  // Настройки масштаба\n  const pixelsPerYear = 3 // 3 пикселя на год\n  const LEFT_PADDING_PX = 30 // отступ слева, чтобы крайняя левая подпись не упиралась в край\n  const timelineWidth = totalYears * pixelsPerYear + LEFT_PADDING_PX\n\n  // Хук для перетаскивания timeline\n  const {\n    timelineRef,\n    isDragging,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchEnd\n  } = useTimelineDrag({\n    timelineWidth,\n    containerWidth: window.innerWidth\n  })\n\n  // Мемоизируем границы веков\n  const centuryBoundaries = useMemo(() => \n    generateCenturyBoundaries(effectiveMinYear, effectiveMaxYear),\n    [effectiveMinYear, effectiveMaxYear]\n  )\n\n  // Мемоизируем алгоритм размещения полосок на строках\n  const calculateRowPlacement = useCallback((people: Person[]) => {\n    const rows: Person[][] = []\n    \n    if (groupingType === 'none') {\n      // Без группировки - просто размещаем всех в строки\n      const allRows: Person[][] = []\n      \n      people.forEach(person => {\n        let placed = false\n        \n        // Проверяем каждую существующую строку\n        for (let rowIndex = 0; rowIndex < allRows.length; rowIndex++) {\n          const row = allRows[rowIndex]\n          let canPlaceInRow = true\n          \n          // Проверяем, не пересекается ли с кем-то в этой строке\n          for (const existingPerson of row) {\n            const BUFFER = 20; // минимальный зазор между персонами\n            if (\n              person.birthYear - BUFFER <= existingPerson.deathYear &&\n              person.deathYear + BUFFER >= existingPerson.birthYear\n            ) {\n              canPlaceInRow = false\n              break\n            }\n          }\n          \n          // Если можно разместить в этой строке\n          if (canPlaceInRow) {\n            allRows[rowIndex].push(person)\n            placed = true\n            break\n          }\n        }\n        \n        // Если не удалось разместить в существующих строках, создаем новую\n        if (!placed) {\n          allRows.push([person])\n        }\n      })\n      \n      return allRows\n    }\n    \n    // Группировка по категориям или странам\n    const groupField = groupingType === 'category' ? 'category' : 'country'\n    const allGroups = groupingType === 'category' ? allCategories : allCountries\n    const groups: { [key: string]: Person[] } = {}\n    \n    // Группируем людей по выбранному полю\n    people.forEach(person => {\n      let groupValue: string\n      if (groupField === 'country') {\n        // Для стран берем первую из списка, если есть несколько через \"/\"\n        groupValue = getFirstCountry(person.country)\n      } else {\n        groupValue = person[groupField]\n      }\n      \n      if (!groups[groupValue]) {\n        groups[groupValue] = []\n      }\n      groups[groupValue].push(person)\n    })\n    \n    // Обрабатываем каждую группу в заданном порядке\n    allGroups.forEach(groupValue => {\n      if (groups[groupValue]) {\n        const groupPeople = groups[groupValue]\n        const groupRows: Person[][] = []\n        \n        // Размещаем людей данной группы в отдельные строки\n        groupPeople.forEach(person => {\n          let placed = false\n          \n          // Проверяем каждую существующую строку для этой группы\n          for (let rowIndex = 0; rowIndex < groupRows.length; rowIndex++) {\n            const row = groupRows[rowIndex]\n            let canPlaceInRow = true\n            \n            // Проверяем, не пересекается ли с кем-то в этой строке\n            for (const existingPerson of row) {\n              const BUFFER = 20; // минимальный зазор между персонами\n              if (\n                person.birthYear - BUFFER <= existingPerson.deathYear &&\n                person.deathYear + BUFFER >= existingPerson.birthYear\n              ) {\n                canPlaceInRow = false\n                break\n              }\n            }\n            \n            // Если можно разместить в этой строке\n            if (canPlaceInRow) {\n              groupRows[rowIndex].push(person)\n              placed = true\n              break\n            }\n          }\n          \n          // Если не удалось разместить в существующих строках, создаем новую\n          if (!placed) {\n            groupRows.push([person])\n          }\n        })\n        \n        // Добавляем строки данной группы к общему списку\n        rows.push(...groupRows)\n        \n        // Добавляем пустую строку для визуального разделения (кроме последней группы)\n        if (groupValue !== allGroups[allGroups.length - 1]) {\n          rows.push([])\n        }\n      }\n    })\n    \n    return rows\n  }, [groupingType, allCategories, allCountries])\n\n  // Мемоизируем размещение по строкам\n  const rowPlacement = useMemo(() => \n    calculateRowPlacement(sortedData),\n    [calculateRowPlacement, sortedData]\n  )\n\n  // Мемоизируем общую высоту\n  const totalHeight = useMemo(() => \n    rowPlacement.reduce((height, row) => {\n      return height + (row.length === 0 ? 20 : 70) // 20px для пустых строк, 70px для обычных (60px + 10px margin)\n    }, 0),\n    [rowPlacement]\n  )\n\n  // Функция для создания разделителей категорий\n    // Высота строки и отступ вниз для непустой строки\n  const ROW_HEIGHT = 60;\n  const ROW_MARGIN = 10; // margin-bottom, используется только для непустых строк\n  const EMPTY_ROW_HEIGHT = 20;\n\n  // Мемоизируем вычисление позиций строк\n  const rowTops = useMemo(() => {\n    const tops: number[] = [];\n    let acc = 0;\n    rowPlacement.forEach(row => {\n      tops.push(acc);\n      if (row.length === 0) {\n        acc += EMPTY_ROW_HEIGHT;\n      } else {\n        acc += ROW_HEIGHT + ROW_MARGIN;\n      }\n    });\n    return tops;\n  }, [rowPlacement]);\n\n  const createCategoryDividers = useCallback(() => {\n    if (groupingType === 'none') {\n      return []; // Без группировки нет разделителей\n    }\n\n    const dividers: { category: string; top: number }[] = [];\n    let currentGroup = '';\n\n    rowPlacement.forEach((row, rowIndex) => {\n      if (row.length > 0) {\n        const firstPersonInRow = row[0];\n        let currentGroupValue: string;\n        \n        if (groupingType === 'category') {\n          currentGroupValue = firstPersonInRow.category;\n        } else if (groupingType === 'country') {\n          // Для стран берем первую из списка\n          currentGroupValue = getFirstCountry(firstPersonInRow.country);\n        } else {\n          currentGroupValue = firstPersonInRow.category;\n        }\n        \n        if (currentGroupValue !== currentGroup) {\n          if (currentGroup !== '') {\n            // закрываем предыдущую группу\n            dividers.push({ category: currentGroup, top: rowTops[rowIndex] - 5 });\n          }\n          currentGroup = currentGroupValue;\n        }\n      }\n    });\n\n    // Добавляем разделитель для последней группы\n    if (currentGroup !== '') {\n      dividers.push({ category: currentGroup, top: rowTops[rowPlacement.length - 1] - 5 });\n    }\n\n    return dividers;\n  }, [groupingType, rowPlacement, rowTops]);\n\n  const categoryDividers = useMemo(() => createCategoryDividers(), [createCategoryDividers]);\n\n  return (\n    <div className=\"app\" id=\"chrononinja-app\" role=\"main\" aria-label=\"Chrono Ninja - Интерактивная временная линия исторических личностей\">\n      <AppHeader\n        isScrolled={isScrolled}\n        showControls={showControls}\n        setShowControls={setShowControls}\n        filters={filters}\n        setFilters={setFilters}\n        groupingType={groupingType}\n        setGroupingType={setGroupingType}\n        allCategories={allCategories}\n        allCountries={allCountries}\n        yearInputs={yearInputs}\n        setYearInputs={setYearInputs}\n        applyYearFilter={applyYearFilter}\n        handleYearKeyPress={handleYearKeyPress}\n        resetAllFilters={resetAllFilters}\n        getCategoryColor={getGroupColor}\n        sortedData={sortedData}\n        handleSliderMouseDown={safeHandleSliderMouseDown}\n        handleSliderMouseMove={safeHandleSliderMouseMove}\n        handleSliderMouseUp={safeHandleSliderMouseUp}\n        isDraggingSlider={isDraggingSlider}\n      />\n      \n      <div className=\"timeline-wrapper\">\n        {/* Загрузка только для области timeline */}\n        {isLoading && (\n          <div className=\"loading-overlay\" role=\"status\" aria-live=\"polite\">\n            <div className=\"spinner\" aria-hidden=\"true\"></div>\n            <span>Загрузка данных...</span>\n          </div>\n        )}\n        \n        <main \n          ref={timelineRef}\n          className={`timeline-container ${isDragging ? 'dragging' : ''}`}\n          id=\"timeline-viewport\" \n          role=\"region\" \n          aria-label=\"Область просмотра временной линии\"\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onTouchStart={handleTouchStart}\n          onTouchMove={handleTouchMove}\n          onTouchEnd={handleTouchEnd}\n        >\n          <Timeline\n          isLoading={false}\n          timelineWidth={timelineWidth}\n          totalHeight={totalHeight}\n          centuryBoundaries={centuryBoundaries}\n          minYear={minYear}\n          pixelsPerYear={pixelsPerYear}\n          LEFT_PADDING_PX={LEFT_PADDING_PX}\n          rowPlacement={rowPlacement}\n          filters={filters}\n          groupingType={groupingType}\n          categoryDividers={categoryDividers}\n          getGroupColor={getGroupColor}\n          getGroupColorDark={getGroupColorDark}\n          getGroupColorMuted={getGroupColorMuted}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          hoveredPerson={hoveredPerson}\n          setHoveredPerson={(person) => {\n            if (person) {\n              // Используем текущую позицию мыши из состояния\n              handlePersonHover(person, mousePosition.x, mousePosition.y);\n            } else {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          mousePosition={mousePosition}\n          setMousePosition={(position) => {\n            // Обновляем позицию мыши\n            if (hoveredPerson) {\n              handlePersonHover(hoveredPerson, position.x, position.y);\n            }\n          }}\n          showTooltip={showTooltip}\n          setShowTooltip={(show) => {\n            if (!show && hoveredPerson) {\n              handlePersonHover(null, 0, 0);\n            }\n          }}\n          activeAchievementMarker={activeAchievementMarker}\n          setActiveAchievementMarker={setActiveAchievementMarker}\n          hoveredAchievement={hoveredAchievement}\n          setHoveredAchievement={setHoveredAchievement}\n          achievementTooltipPosition={achievementTooltipPosition}\n          setAchievementTooltipPosition={setAchievementTooltipPosition}\n          showAchievementTooltip={showAchievementTooltip}\n                  setShowAchievementTooltip={(show) => {\n          if (!show && hoveredAchievement) {\n            handleAchievementHover(null, 0, 0);\n          }\n        }}\n        handlePersonHover={handlePersonHover}\n        handleAchievementHover={handleAchievementHover}\n          hoverTimerRef={hoverTimerRef}\n          sortedData={sortedData}\n          selectedPerson={selectedPerson}\n          setSelectedPerson={setSelectedPerson}\n        />\n        </main>\n      </div>\n\n      <aside className=\"tooltips-container\" id=\"tooltips-aside\" aria-label=\"Информационные подсказки\">\n        <Tooltips\n          hoveredPerson={hoveredPerson}\n          showTooltip={showTooltip}\n          mousePosition={mousePosition}\n          hoveredAchievement={hoveredAchievement}\n          showAchievementTooltip={showAchievementTooltip}\n          achievementTooltipPosition={achievementTooltipPosition}\n          getGroupColor={getGroupColor}\n          getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n          getCategoryColor={getGroupColor}\n        />\n      </aside>\n      \n      {/* Мобильная панель с информацией о человеке */}\n      <MobilePersonPanel\n        selectedPerson={selectedPerson}\n        onClose={() => setSelectedPerson(null)}\n        getGroupColor={getGroupColor}\n        getPersonGroup={(person) => getPersonGroup(person, groupingType)}\n        getCategoryColor={getGroupColor}\n      />\n    </div>\n  )\n}\n\nexport default App "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}