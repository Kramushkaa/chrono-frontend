{"ast":null,"code":"// Функция для конвертации в римские цифры\nexport const toRomanNumeral = num => {\n  const romanNumerals = [{\n    value: 1000,\n    numeral: 'M'\n  }, {\n    value: 900,\n    numeral: 'CM'\n  }, {\n    value: 500,\n    numeral: 'D'\n  }, {\n    value: 400,\n    numeral: 'CD'\n  }, {\n    value: 100,\n    numeral: 'C'\n  }, {\n    value: 90,\n    numeral: 'XC'\n  }, {\n    value: 50,\n    numeral: 'L'\n  }, {\n    value: 40,\n    numeral: 'XL'\n  }, {\n    value: 10,\n    numeral: 'X'\n  }, {\n    value: 9,\n    numeral: 'IX'\n  }, {\n    value: 5,\n    numeral: 'V'\n  }, {\n    value: 4,\n    numeral: 'IV'\n  }, {\n    value: 1,\n    numeral: 'I'\n  }];\n  let result = '';\n  let remaining = Math.abs(num);\n  for (const {\n    value,\n    numeral\n  } of romanNumerals) {\n    while (remaining >= value) {\n      result += numeral;\n      remaining -= value;\n    }\n  }\n  return num < 0 ? `-${result}` : result;\n};\n\n// Функция для получения номера века\nexport const getCenturyNumber = year => {\n  if (year < 0) {\n    // Для отрицательных лет: -1 до -100 = 1 век до н.э., -101 до -200 = 2 век до н.э.\n    return Math.floor((Math.abs(year) - 1) / 100) + 1;\n  } else if (year === 0) {\n    // Год 0 не существует в исторической хронологии\n    return 1;\n  } else {\n    // Для положительных лет: 1-100 = 1 век, 101-200 = 2 век и т.д.\n    return Math.floor((year - 1) / 100) + 1;\n  }\n};\n\n// Функция для получения цвета века\nexport const getCenturyColor = (year, minYear) => {\n  const colors = ['rgba(255, 107, 107, 0.1)',\n  // Светло-красный\n  'rgba(78, 205, 196, 0.1)',\n  // Светло-голубой\n  'rgba(150, 206, 180, 0.1)',\n  // Светло-зеленый\n  'rgba(255, 234, 167, 0.1)',\n  // Светло-оранжевый\n  'rgba(221, 160, 221, 0.1)',\n  // Светло-фиолетовый\n  'rgba(120, 219, 255, 0.1)',\n  // Светло-бирюзовый\n  'rgba(255, 255, 229, 0.1)',\n  // Светло-желтый\n  'rgba(255, 229, 240, 0.1)' // Светло-розовый\n  ];\n  const centuryIndex = Math.floor((year - minYear) / 100);\n  return colors[centuryIndex % colors.length];\n};\n\n// Функция для генерации границ веков\nexport const generateCenturyBoundaries = (minYear, maxYear) => {\n  const boundaries = [];\n  const startCentury = Math.floor(minYear / 100) * 100;\n  const endCentury = Math.ceil(maxYear / 100) * 100;\n  for (let year = startCentury; year <= endCentury; year += 100) {\n    // Включаем границу, если она попадает в диапазон данных или является границей века\n    if (year <= maxYear) {\n      boundaries.push(year);\n    }\n  }\n  return boundaries;\n};\n\n// Функция для вычисления позиции в пикселях\nexport const getPosition = (year, minYear, pixelsPerYear, leftPadding) => {\n  return leftPadding + (year - minYear) * pixelsPerYear;\n};\n\n// Функция для вычисления ширины полоски в пикселях\nexport const getWidth = (birthYear, deathYear, pixelsPerYear) => {\n  return (deathYear - birthYear) * pixelsPerYear;\n};\n\n// Вспомогательная функция для извлечения первой страны из списка\nexport const getFirstCountry = countryString => {\n  const countries = countryString.split('/').map(c => c.trim());\n  return countries[0] || countryString;\n};","map":{"version":3,"names":["toRomanNumeral","num","romanNumerals","value","numeral","result","remaining","Math","abs","getCenturyNumber","year","floor","getCenturyColor","minYear","colors","centuryIndex","length","generateCenturyBoundaries","maxYear","boundaries","startCentury","endCentury","ceil","push","getPosition","pixelsPerYear","leftPadding","getWidth","birthYear","deathYear","getFirstCountry","countryString","countries","split","map","c","trim"],"sources":["C:/Users/Selecty/Documents/PetProjects/chronoline-frontend/src/utils/timelineUtils.ts"],"sourcesContent":["// Функция для конвертации в римские цифры\r\nexport const toRomanNumeral = (num: number): string => {\r\n  const romanNumerals = [\r\n    { value: 1000, numeral: 'M' },\r\n    { value: 900, numeral: 'CM' },\r\n    { value: 500, numeral: 'D' },\r\n    { value: 400, numeral: 'CD' },\r\n    { value: 100, numeral: 'C' },\r\n    { value: 90, numeral: 'XC' },\r\n    { value: 50, numeral: 'L' },\r\n    { value: 40, numeral: 'XL' },\r\n    { value: 10, numeral: 'X' },\r\n    { value: 9, numeral: 'IX' },\r\n    { value: 5, numeral: 'V' },\r\n    { value: 4, numeral: 'IV' },\r\n    { value: 1, numeral: 'I' }\r\n  ]\r\n\r\n  let result = ''\r\n  let remaining = Math.abs(num)\r\n\r\n  for (const { value, numeral } of romanNumerals) {\r\n    while (remaining >= value) {\r\n      result += numeral\r\n      remaining -= value\r\n    }\r\n  }\r\n\r\n  return num < 0 ? `-${result}` : result\r\n}\r\n\r\n// Функция для получения номера века\r\nexport const getCenturyNumber = (year: number): number => {\r\n  if (year < 0) {\r\n    // Для отрицательных лет: -1 до -100 = 1 век до н.э., -101 до -200 = 2 век до н.э.\r\n    return Math.floor((Math.abs(year) - 1) / 100) + 1\r\n  } else if (year === 0) {\r\n    // Год 0 не существует в исторической хронологии\r\n    return 1\r\n  } else {\r\n    // Для положительных лет: 1-100 = 1 век, 101-200 = 2 век и т.д.\r\n    return Math.floor((year - 1) / 100) + 1\r\n  }\r\n}\r\n\r\n// Функция для получения цвета века\r\nexport const getCenturyColor = (year: number, minYear: number) => {\r\n  const colors = [\r\n    'rgba(255, 107, 107, 0.1)', // Светло-красный\r\n    'rgba(78, 205, 196, 0.1)', // Светло-голубой\r\n    'rgba(150, 206, 180, 0.1)', // Светло-зеленый\r\n    'rgba(255, 234, 167, 0.1)', // Светло-оранжевый\r\n    'rgba(221, 160, 221, 0.1)', // Светло-фиолетовый\r\n    'rgba(120, 219, 255, 0.1)', // Светло-бирюзовый\r\n    'rgba(255, 255, 229, 0.1)', // Светло-желтый\r\n    'rgba(255, 229, 240, 0.1)', // Светло-розовый\r\n  ]\r\n  \r\n  const centuryIndex = Math.floor((year - minYear) / 100)\r\n  return colors[centuryIndex % colors.length]\r\n}\r\n\r\n// Функция для генерации границ веков\r\nexport const generateCenturyBoundaries = (minYear: number, maxYear: number) => {\r\n  const boundaries = []\r\n  const startCentury = Math.floor(minYear / 100) * 100\r\n  const endCentury = Math.ceil(maxYear / 100) * 100\r\n  \r\n  for (let year = startCentury; year <= endCentury; year += 100) {\r\n    // Включаем границу, если она попадает в диапазон данных или является границей века\r\n    if (year <= maxYear) {\r\n      boundaries.push(year)\r\n    }\r\n  }\r\n  return boundaries\r\n}\r\n\r\n// Функция для вычисления позиции в пикселях\r\nexport const getPosition = (year: number, minYear: number, pixelsPerYear: number, leftPadding: number) => {\r\n  return leftPadding + (year - minYear) * pixelsPerYear\r\n}\r\n\r\n// Функция для вычисления ширины полоски в пикселях\r\nexport const getWidth = (birthYear: number, deathYear: number, pixelsPerYear: number) => {\r\n  return (deathYear - birthYear) * pixelsPerYear\r\n}\r\n\r\n// Вспомогательная функция для извлечения первой страны из списка\r\nexport const getFirstCountry = (countryString: string): string => {\r\n  const countries = countryString.split('/').map(c => c.trim())\r\n  return countries[0] || countryString\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}